# Python

## Содержание:
<a id="sections"></a>

* [Разница 2 и 3 версии python](#Difference-2-and-3-python-version)  
* [ООП](#oop)  
  - [SOLID](#SOLID)  
  - [Что такое классы?](#classes)  
  - [Что такое магические методы?](#magic-methods)  
  - [Что такое миксин?](#mixin) 
  - [Что такое наследование классов и как его использовать?](#class-inheritance)
  - [Что такое полиморфизм и как его реализовать в python?](#)
  - [Как работает инкапсуляция в python?](#)
  - [Как можно реализовать инкапсуляцию в Python, используя только публичные методы?](#)
  - [Что такое дескрипторы и как они используются в Python?](#)
  - [Что такое абстрактные классы и зачем они нужны в Python?](#)
  - [Что такое множественное наследование и какие проблемы могут возникнуть при его использовании в Python?](#)
  - [Как можно реализовать агрегацию объектов в Python?](#)
  - [Что такое примеси (mixins) и как они используются в Python?](#)
  - [Что такое композиция объектов и как ее можно использовать в Python?](#)
* [Типы и структуры данных в python](#Types-and-data-structures-in-python)  
  - [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
  - [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
  - [Что может быть в качестве ключа словаря?](#dictionary-key)  
  - [Что такое хеш-функция?](#python-hash)  
  - [В чём особенность словаря в python?](#dictionary-in-python)  
  - [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets) 
* [GIL](#GIL) 
  - [Что такое GIL?](#what-is-GIL)  
  - [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
  - [Разница между потоками и процессами](#difference-between-threads-and-processes)  
  - [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
  - [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  
* [GC](#GC)  
  - [Как в питоне обстоят дела с памятью (управлением памятью)](#memory-management-in-python)  
  - [Сколько стоит проверка элемента в нотации?](#how-much-does-it-cost-to-validate-an-element-in-notation)  
  - [Если есть два объекта и они указывают друг на друга](#two-objects) 
* [Итераторы, декораторы и генераторы](#Iterators-decorators-and-generators)  
  - [Что такое итератор?](#what-is-iterator)  
  - [Что такое генератор?](#what-is-generator)
  - [Что такое декоратор?](#what-is-decorator)  
  - [Какие декораторы стандартной библиотеки вы знаете?](#standard-library-decorators) 
  - [Что такое list comprehension, какой синтаксис создания генераторов?](list-comprehension)
  - [Является ли range итератором?](is-range-an-iterator)
* [Алгоритмы](#Algorithms)  


<a id="Python"></a>


## Разница 2 и 3 версии python
<a id="Difference-2-and-3-python-version"></a>

В Python 2 print был оператором: `print "Hello, world"`
В Python 3 print - функция: `print ("Hello, world")`

В Python 2 были две функции: range - возвращает список; xrange - возвращает итератор  
В Python 3 есть только функция range, и она возвращает итератор

В Python 2 при делении целых чисел возвращает целоче число  
В Python 3 при делении целых чисел возвращает вещественное число

**Магические методы**

* Так как в 3 Питоне различий между строкой и юникодом больше нет, ` __unicode__`  исчез, а появился ` __bytes__`  (который ведёт себя так же как ` __str__`  и ` __unicode__`  в 2.7) для новых встроенных функций построения байтовых массивов.  
* Так как деление в 3 Питоне теперь по-умолчанию «правильное деление», ` __div__`  больше нет.  
* ` __coerce__`  больше нет, из-за избыточности и странного поведения.  
* ` __cmp__`  больше нет, из-за избыточности.  
* ` __nonzero__`  было переименовано в ` __bool__` .  
* ` next`  у итераторов был переименован в ` __next__` .

# ООП
<a id="oop"></a>
* [SOLID](#SOLID)  
* [Что такое классы?](#classes)  
* [Магические методы](#magic-methods)  
* [Что такое миксин?](#mixin)  

([наверх](#sections))

## SOLID
<a id="SOLID"></a>

*S* - Принцип единственной ответственности (single responsibility principle)  
Для каждого класса должно быть определено единственное назначение. Не должно возникать God object, который занимается всем в программе. 

*O* - Принцип открытости/закрытости (open–closed principle)  
«программные сущности … должны быть открыты для расширения, но закрыты для модификации». Мы должны иметь возможность добавлять функциональность. 

*L* - Принцип подстановки Барбары Лисков (Liskov substitution principle)  
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения 
правильности выполнения программы». У объекта есть тип, но сами классы выстраиваются в иерархию классов. Подтип типа всю старую функциональность должен выполнять. 

*I* - Принцип разделения интерфейса (interface segregation principle)  
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс 
общего назначения». Интерфейс - способ провзаимодействовать с какой-то программной действующей функцией. 

*D* - Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». 
## Что такое классы?
<a id="classes"></a>
([наверх](#sections))

Класс — тип, описывающий устройство объектов. Объект — это экземпляр класса.

```py
class C: 
  pass
имя_объекта = имя_класса()
```

У класса может не быть тела. 

Простейший пример класса:

```py
class Rectangle:
  default_color = "green" # статический атрибут
  def __init__(self, width, height): # конструктор класса
    self.width = width # динамический атрибут
    self.height = height # динамический атрибут
```

В python нет возможности сделать несколько конструкторов. 

## Магические методы
<a id="magic-methods"></a>
([наверх](#sections))

Если какой-то идентификатор начинается с двух подчёркиваний, дальше пишется что-либо, потом снова два подчёркивания, то это спец метод. 

**Какие магические методы и для чего используются?**

```py
class FileObject:
  def __init__(self, filepath='~', filename='sample.txt'): # Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.
    self.file = open(join(filepath, filename), 'r+') # Открыть файл filename в filepath в режиме чтения и записи
  def __del__(self):
    self.file.close()
    del self.file
``` 

Метод, который будет вызван при инициализации объекта.  
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в ` __init__` . ` __new__`  используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка.

```py
__new__(cls, [...])
``` 
Инициализатор класса. Самый базовый магический метод, ` __init__` . С его помощью мы можем инициализировать объект.
```py
__init__(self, [...]) 
``` 
Деструктор объекта
```py
__del__
``` 

Самый базовый из методов сравнения ` __cmp__(self, other)` . Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). ` __cmp__`  должен вернуть отрицательное число, если ` self < other` , ноль, если ` self == other` , и положительное число в случае ` self > other` . Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в ` __cmp__` . Но ` __cmp__`  может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперируют одним критерием.

* ` __eq__(self, other)` 
Определяет поведение оператора равенства, ==.

* ` __ne__(self, other)` 
Определяет поведение оператора неравенства, !=.

* ` __lt__(self, other)` 
Определяет поведение оператора меньше, <.

* ` __gt__(self, other)` 
Определяет поведение оператора больше, >.

* ` __le__(self, other)` 
Определяет поведение оператора меньше или равно, <=.

* ` __ge__(self, other)` 
Определяет поведение оператора больше или равно, >=.

**Унарные операторы и функции**

Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.

* ` __pos__(self)` 
Определяет поведение для унарного плюса `(+some_object)`

* ` __neg__(self)` 
Определяет поведение для отрицания`(-some_object)`

* ` __abs__(self)` 
Определяет поведение для встроенной функции `abs()`.

* ` __invert__(self)` 
Определяет поведение для инвертирования оператором ~. Для объяснения что он делает смотри статью в Википедии о бинарных операторах.

* ` __round__(self, n)` 
Определяет поведение для встроенной функции `round()`. n это число знаков после запятой, до которого округлить.

* ` __floor__(self)` 
Определяет поведение для `math.floor()`, то есть, округления до ближайшего меньшего целого.

* ` __ceil__(self)` 
Определяет поведение для `math.ceil()`, то есть, округления до ближайшего большего целого.

* ` __trunc__(self)` 
Определяет поведение для `math.trunc()`, то есть, обрезания до целого.

**Обычные арифметические операторы**

* `__add__(self, other)`
Сложение.

* `__sub__(self, other)`
Вычитание.

* `__mul__(self, other)`
Умножение.

* `__floordiv__(self, other)`
Целочисленное деление, оператор //.

* `__div__(self, other)`
Деление, оператор /.

* `__truediv__(self, other)`
Правильное деление. Заметьте, что это работает только когда используется `from __future__ import division`.

* `__mod__(self, other)`
Остаток от деления, оператор %.

* `__divmod__(self, other)`
Определяет поведение для встроенной функции divmod().

* `__pow__`
Возведение в степень, оператор **.

* `__lshift__(self, other)`
Двоичный сдвиг влево, оператор <<.

* `__rshift__(self, other)`
Двоичный сдвиг вправо, оператор >>.

* `__and__(self, other)`
Двоичное И, оператор &.

* `__or__(self, other)`
Двоичное ИЛИ, оператор |.

* `__xor__(self, other)`
Двоичный xor, оператор ^.

**Магические методы преобразования типов**

В Питоне множество магических методов, предназначенных для определения поведения для встроенных функций преобразования типов.

* `__int__(self)`
Преобразование типа в int.

* `__long__(self)`
Преобразование типа в long.

* `__float__(self)`
Преобразование типа в float.

* `__complex__(self)`
Преобразование типа в комплексное число.

* `__oct__(self)`
Преобразование типа в восьмеричное число.

* `__hex__(self)`
Преобразование типа в шестнадцатеричное число.

* `__index__(self)`
Преобразование типа к int, когда объект используется в срезах (выражения вида `[start:stop:step]`). Если вы определяете свой числовой тип, который может использоваться как индекс списка, вы должны определить `__index__`.

* `__trunc__(self)`
Вызывается при `math.trunc(self)`. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

* `__coerce__(self, other)`
Метод для реализации арифметики с операндами разных типов. `__coerce__` должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.

**Представление своих классов**

Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.

* `__str__(self)`
Определяет поведение функции `str()`, вызванной для экземпляра вашего класса.

* `__repr__(self)`
Определяет поведение функции `repr()`, вызванной для экземпляра вашего класса. Главное отличие от `str()` в целевой аудитории. `repr()` больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне), а `str()` предназначен для чтения людьми.

* `__unicode__(self)`
Определяет поведение функции `unicode()`, вызванной для экземпляра вашего класса. `unicode()` похож на `str()`, но возвращает строку в юникоде. Если клиент вызывает `str()` на экземпляре вашего класса, а вы определили только `__unicode__()`, то это не будет работать. Постарайтесь всегда определять `__str__()` для случая, когда кто-то не имеет такой роскоши как юникод.

* `__format__(self, formatstr)`
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, `"Hello, {0:abc}!".format(a)` приведёт к вызову ` a.__format__("abc")`. Это может быть полезно для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.

* `__hash__(self)`
Определяет поведение функции `hash()`, вызванной для экземпляра вашего класса. Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно нужно определять и `__eq__` тоже. Руководствуйтесь следующим правилом: `a == b` подразумевает `hash(a) == hash(b)`.

* `__nonzero__(self)`
Определяет поведение функции `bool()`, вызванной для экземпляра вашего класса. Должна вернуть `True` или `False`, в зависимости от того, когда вы считаете экземпляр соответствующим `True` или `False`.

* `__dir__(self)`
Определяет поведение функции `dir()`, вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю список атрибутов. Обычно, определение `__dir__` не требуется, но может быть жизненно важно для интерактивного использования вашего класса, если вы переопределили `__getattr__` или `__getattribute__`.

* `__sizeof__(self)`
Определяет поведение функции` sys.getsizeof()`, вызванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах.

**Магия контейнеров**

Магические методы, используемые контейнерами.

* `__len__(self)`
Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.

* `__getitem__(self, key)`
Определяет поведение при доступе к элементу, используя синтаксис `self[key]`. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: TypeError если неправильный тип ключа и KeyError если ключу не соответствует никакого значения.

* `__setitem__(self, key, value)`
Определяет поведение при присваивании значения элементу, используя синтаксис `self[nkey] = value`. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать KeyError и TypeError в соответствующих случаях.

* `__delitem__(self, key)`
Определяет поведение при удалении элемента (то есть `del self[key]`). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.

* `__iter__(self)`
Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции `iter()` и в случае перебора элементов контейнера выражением `for x in container:`. Итераторы сами по себе объекты и они тоже должны определять метод `__iter__`, который возвращает `self`.

* `__reversed__(self)`
Вызывается чтобы определить поведения для встроенной функции `reversed()`. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.

* `__contains__(self, item)`
`__contains__` предназначен для проверки принадлежности элемента с помощью in и not in. Вы спросите, почему же это не часть протокола последовательности? Потому что когда `__contains__` не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает True если находит нужный.

* `__missing__(self, key)`
`__missing__` используется при наследовании от `dict`. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь `d` и я пишу `d["george"]` когда "george" не является ключом в словаре, вызывается `d.__missing__("george"))`.

**Построение дескрипторов**

Дескрипторы — это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).

Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из `__get__`, `__set__` или `__delete__`. 

* `__get__(self, instance, instance_class)`
Определяет поведение при возвращении значения из дескриптора. `instance` это объект, для чьего атрибута-дескриптора вызывается метод. owner это тип (класс) объекта.

* `__set__(self, instance, value)`
Определяет поведение при изменении значения из дескриптора. `instance` это объект, для чьего атрибута-дескриптора вызывается метод. value это значение для установки в дескриптор.

* `__delete__(self, instance)`
Определяет поведение для удаления значения из дескриптора. `instance` это объект, владеющий дескриптором.

**Как вызывать магические методы** 

| **Магический метод**                  |	**Когда он вызывается (пример)**        |	**Объяснение**                                       |
|:--------------------------------------|:----------------------------------------|:-----------------------------------------------------| 
| `__new__(cls [,...])`             |	`instance = MyClass(arg1, arg2)`    |	`__new__` вызывается при создании экземпляра     |
| `__init__(self [,...])`           |	`instance = MyClass(arg1, arg2)`    |	`__init__` вызывается при создании экземпляра    |
| `__cmp__(self, other)`            |	`self == other, self > other, etc.`	| Вызывается для любого сравнения                      |
| `__pos__(self)`                   |	`+self`                            	| Унарный знак плюса                                   |
| `__neg__(self)`                   |	`-self`	                            | Унарный знак минуса                                  |
| `__invert__(self)`                |	`~self`	                            | Побитовая инверсия                                   |
| `__index__(self)`                 |	`x[self]`	                          | Преобразование, когда объект используется как индекс |
| `__nonzero__(self)`               |	`bool(self), if self:`             	| Булевое значение объекта                             |
| `__getattr__(self, name)`         |	`self.name # name не определено`	  | Пытаются получить несуществующий атрибут             |
| `__setattr__(self, name, val)`    |	`self.name = val`	                  | Присвоение любому атрибуту                           |
| `__delattr__(self, name)`         |	`del self.name`	                    | Удаление атрибута                                    |
| `__getattribute__(self, name)`    |	`self.name`	                        | Получить любой атрибут                               |
| `__getitem__(self, key)`          |	`self[key]`	                        | Получение элемента через индекс                      |
| `__setitem__(self, key, val)`     |	`self[key] = val`                  	| Присвоение элементу через индекс                     |
| `__delitem__(self, key)`          |	`del self[key]`	                    | Удаление элемента через индекс                       |
| `__iter__(self)`                  |	`for x in self`	                    | Итерация                                             |
| `__contains__(self, value)`       |	`value in self, value not in self`	| Проверка принадлежности с помощью in                 |
| `__call__(self [,...])`           |	`self(args)`	                      | «Вызов» экземпляра                                   |
| `__enter__(self)`                 |	`with self as x:`	                  | `with` оператор менеджеров контекста             |
| `__exit__(self, exc, val, trace)` |	`with self as x:`	                  | `with` оператор менеджеров контекста             |
| `__getstate__(self)`              |	`pickle.dump(pkl_file, self)`	      | Сериализация                                         |
| `__setstate__(self)`              |	`data = pickle.load(pkl_file)`	    | Сериализация                                         |

## Что такое миксин?
<a id="mixin"></a>
([наверх](#sections))

Это класс, который реализует несколько методов, которые ты добавляешь к разным классам для того, чтобы они унаследовали и тоже получили какие-то методы. 

## Что такое наследование классов и как его использовать?
<a id="class-inheritance"></a>
([наверх](#sections))

Наследование классов в объектно-ориентированном программировании позволяет создавать новые классы на основе уже существующих классов. Это позволяет наследующему классу наследовать атрибуты (переменные и методы) от родительского класса, что способствует повторному использованию кода и созданию иерархии классов.

Для создания наследования классов в Python используется следующий синтаксис:

```py
class РодительскийКласс:
    # Атрибуты и методы родительского класса

class НаследующийКласс(РодительскийКласс):
    # Атрибуты и методы наследующего класса
```

В примере выше класс `НаследующийКласс` наследует атрибуты и методы от класса `РодительскийКласс`. Это означает, что `НаследующийКласс` может использовать все публичные атрибуты и методы, определенные в `РодительскомКлассе`, а также добавлять свои собственные атрибуты и методы.

Пример кода:

```py
class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        pass  # Абстрактный метод, будет переопределен в дочерних классах

class Dog(Animal):
    def sound(self):
        return "Woof!"

class Cat(Animal):
    def sound(self):
        return "Meow!"

dog = Dog("Buddy")
print(dog.name)  # Выводит "Buddy"
print(dog.sound())  # Выводит "Woof!"

cat = Cat("Kitty")
print(cat.name)  # Выводит "Kitty"
print(cat.sound())  # Выводит "Meow!"
```

В этом примере `Animal` является родительским классом, а `Dog` и `Cat` являются наследующими классами. У них есть общий атрибут name, наследуемый от `Animal`, и переопределенный метод `sound()`. Созданные объекты классов `Dog` и `Cat` могут использовать как унаследованный атрибут `name`, так и метод `sound()`, соответствующий каждому классу.

Таким образом, наследование классов позволяет эффективно организовывать иерархию классов и переиспользовать код, что является одной из ключевых концепций объектно-ориентированного программирования.

# Типы и структуры данных в python
<a id="Types-and-data-structures-in-python"></a>

* [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
* [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
* [Что может быть в качестве ключа словаря?](#dictionary-key)  
* [Что такое хеш-функция?](#python-hash)  
* [В чём особенность словаря в python?](#dictionary-in-python)  
* [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets)  

([наверх](#sections))

## Какие типы и структуры данных бывают в python?
<a id="Types-and-data-structures"></a>

| *Объект*                          | *Тип*                      | 
|:---------------------------------:|:--------------------------:| 
| Строка                            | str                        |
| Целое число                       | int                        |
| Число с плавающей точкой          | float                      |
| Список                            | list                       |
| Кортеж                            | tuple                      |
| Словарь                           | dict                       |
| Множество                         | set                        |
| Логический                        | bool                       |
| Функция                           | function                   |
| Класс, определяемый пользователем | type                       |
| Экземпляр класса                  | class                      |
| Встроенная функция                | builtin_function_or_method |
| type                              | type                       |

## Что такое мутабельные и иммутабельные типы данных?
<a id="mutable-and-immutable-data-types"></a>
([наверх](#sections))

Объекты в питоне бывают двух значительно отличающихся сортов: изменяемые (mutable) и неизменяемые (immutable). Неизменяемыми являются целые и действительные числа (int, float), строки (str), последовательности байтов (бинарные данные, bytes), а также кортежи, все элементы которых неизменяемы (tuple). Напротив, списки (list), словари (dict) и множества (set) являются изменяемыми.

## Что может быть в качестве ключа словаря?
<a id="dictionary-key"></a>
([наверх](#sections))

Только неизменяемые типы данных. Ключами словаря могут являться только объекты, поддерживающие хеширование. Таким образом, использовать в качестве ключей списки, словари и другие изменяемые типы не получится. Если в словарь будут добавлены несколько значений с одним и тем же ключом, словарь сохранит последнее.

Не рекомендуется использоваться в качестве ключей числа с плавающей запятой, так как они хранятся в памяти в виде приближений.

## Что такое хеш-функция?
<a id="python-hash"></a>
([наверх](#sections))

Хэш-функция - это функция, которая принимает на вход какие-либо данные (например, строки) и возвращает число по некоторому заданному алгоритму.  
Назначением хэш-функций является возможность помещения некоторого элемента (например, строки) в хэш-таблицу, на основе которых реализованы, например, словари и множества в Python. 

Одинаковые данные будут иметь одинаковое хеш-значение.  
* Даже небольшое изменение исходных данных может привести к совершенно иному хеш-значению.  
* Хеш получается из хеш-функции, в обязанности которой входит преобразование данной информации в закодированный хеш.   
* Очевидно, что количество объектов может быть намного больше, чем количество хеш-значений, и поэтому два объекта могут хешировать одно и то же. Это называется конфликтом хэша. Это означает, что если два объекта имеют одинаковый хэш-код, они не обязательно имеют одно и то же значение.  

Cрок жизни хэша зависит только от области действия программы, и он может измениться, как только программа завершится.

## В чём особенность словаря в python?
<a id="dictionary-in-python"></a>
([наверх](#sections))

Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.  

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами:  

* Во-первых, с помощью литерала:

```py
d = {}
print(d)
{}
d = {'dict': 1, 'dictionary': 2}
prtin(d)
{'dict': 1, 'dictionary': 2}
```
  
* Во-вторых, с помощью функции dict:

```py
d = dict(short='dict', long='dictionary')
prtin(d)
{'short': 'dict', 'long': 'dictionary'}
d = dict([(1, 1), (2, 4)])
prtin(d)
{1: 1, 2: 4}
```

* В-третьих, с помощью метода fromkeys:

```py
d = dict.fromkeys(['a', 'b'])
prtin(d)
{'a': None, 'b': None}
d = dict.fromkeys(['a', 'b'], 100)
prtin(d)
{'a': 100, 'b': 100}
```

* В-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.

```py
d = {a: a ** 2 for a in range(7)}
prtin(d)
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

**Методы словарей**  

* `dict.clear()` - очищает словарь.
* `dict.copy()` - возвращает копию словаря.
* `classmethod dict.fromkeys(seq[, value])` - создает словарь с ключами из `seq` и значением `value` (по умолчанию `None`).
* `dict.get(key[, default])` - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает `default` (по умолчанию `None`).
* `dict.items()` - возвращает пары (ключ, значение).
* `dict.keys()` - возвращает ключи в словаре.
* `dict.pop(key[, default])` - удаляет ключ и возвращает значение. Если ключа нет, возвращает `default` (по умолчанию бросает исключение).
* `dict.popitem()` - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение `KeyError`. Важно помнить, что словари неупорядочены.
* `dict.setdefault(key[, default])` - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением `default` (по умолчанию `None`).
* `dict.update([other])` - обновляет словарь, добавляя пары (ключ, значение) из `other`. Существующие ключи перезаписываются. Возвращает `None` (не новый словарь!).
* `dict.values()` - возвращает значения в словаре.

## Списки, кортежи и множества в чём их отличие?
<a id="lists-tuples-and-sets"></a>
([наверх](#sections))

_List (список)_  
Базовая структура данных в python. Элементы в списке хранятся последовательно, каждому из них присвоены индексы, начиная с нуля. В отличие от массива, список может хранить объекты любого типа.

Создание списка

```py
my_list = [] # Создание пустого списка с помощью литерала списка
my_list = list() # Создание пустого списка с помощью встроенной функции

my_list = [1,2,['a','b'],4,5] # Инициализация списка

my_list = list('hello world') # Создание списка из итерируемого объекта
print(my_list)
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

my_list = [x for x in range(10)] # Генератор списков в действии
print(my_list)

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Доступные методы
* `my_list.append(x)` - добавляет x в конец списка
* `my_list.clear()` - очищает 
* `my_list.copy()` - возвращает копию списка `my_list`
* `my_list.count(x)` - возвращает кол-во элементов со значением x
* `my_list.extend(x)` - добавляет элементы списка x к концу списка `my_list`
* `my_list.index(x,start,end)` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)
* `my_list.insert(index, x)` - вставляет x на заданную позицию
* `my_list.pop(index)` - возвращает элемент с указанным индексом и удаляет его, если индекс не указан - возвращается и удаляется последний элемент
* `my_list.remove(x)` - удаляет первый элемент со значением x
* `my_list.reverse()` - инвертирует порядок элементов в списке
* `my_list.sort(key=x)` сортирует список на основе функции x  

В каких случаях использовать?
Для хранения элементов, объединенных каким либо признаком. В случае, если изменение элементов и/или расширение списка не предполагается, следует использовать неизменяемый аналог - кортеж.

_Tuple (кортёж)_  
Кортеж - это неизменяемый и более быстрый аналог списка. Он защищает хранимые данные от непреднамеренных изменений и может использоваться в качестве ключа в словарях (словарь - ассоциативный массив в python).

Создание кортежа.

```py
my_tuple = () # Создание кортежа с помощью литерала
my_tuple = tuple() # Создание кортежа с помощью встроенной функции

my_tuple = (1,2,['a','b'],4,5) # Инициализация кортежа

my_tuple = tuple('hello world') # Создание кортежа из итерируемого объекта
print(my_tuple)
('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')

my_tuple = tuple(2**x for x in [0, 1, 2, 3]) # Генератор кортежей
print(my_tuple)
(1, 2, 4, 8)
```

Доступные методы

* `my_tuple.count(x)` - возвращает кол-во элементов со значением x
* `my_tuple.index(x,start,end)` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)  

В каких случаях использовать?
Для хранения данных вместо списка (если они не предполагают изменений).

_Set (множество)_  
Множество - это набор уникальных элементов в случайном порядке (неупорядоченный список). Множества примечательны тем, что операция проверки "принадлежит ли объект множеству" происходит значительно быстрее аналогичных операций в других структурах данных.

Создание множества

```py
my_something = {} # !!! Попытка создать множество при помощи литерала даст нам словарь
type(my_something)
<class 'dict'> 

my_set = set() # Создание при помощи встроенной функции

my_set = {1,2,3,4,5} # Инициализация множества

my_set = set('hello world') # Создания множества из итерируемого объекта
print(my_set)
{'r', 'o', 'e', 'h', 'd', 'w', 'l', ' '}

my_set = {x for x in range(10)} # Генератор множеств
print(my_set)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

Доступные методы
* `my_set.add(x)` - добавляет x во множество
* `my_set.difference(x)` - возвращает множество элементов `my_set`, которые не входят во множество `x`
* `my_set.difference_update(x)` - удаляет из множества my_set все элементы, которые входят во множество `x`
* `my_set.discard(x)` - удаляет элемент `x` из `my_set`
* `my_set.intersection(x)` - возвращает элементы общие для множеств `my_set` и `x`
* `my_set.intersection_update(x)` - удаляет из множества `my_set` элементы, которых нет во множестве `x`
* `my_set.isdisjoint(x)` - возвращает `true` если `my_set` и `x` не содержат одинаковых значений
* `my_set.issubset(x)` - возвращает true если все элементы `my_set` входят во множество `x`
* `my_set.issuperset(x)` - возвращает `true` если все элементы x входят во множество `my_set`
* `my_set.pop()` - возвращает и удаляет первый (на данный момент) элемент множества
* `my_set.remove(x)` - удаляет `x` из множества
* `my_set.symmetric_difference(x)` - возвращает все элементы из `x` и `my_set`, которые встречаются только в одном из множеств
* `my_set.symmetric_difference_update(x)` - обновляет исходное множество таким образом, что оно будет состоять из всех элементов `x` и `my_set`, которые встречаются только в одном из множеств
* `my_set.union(x)` - возвращает новое множество, состоящее из всех элементов `x` и `my_set`
* `my_set.update(x)` - добавляет в `my_set` все элементы `x` 

В каких случаях использовать?
Когда необходимо проверять принадлежит ли значение набору уникальных элементов и отсутствует необходимость поддерживать порядок в данном наборе.

# GIL
<a id="GIL"></a>

* [Что такое GIL?](#what-is-GIL)  
* [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
* [Разница между потоками и процессами](#difference-between-threads-and-processes)  
* [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
* [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  

([наверх](#sections))

## Что такое GIL?
<a id="what-is-GIL"></a>

В Python используется глобальная блокировка интерпретатора (Global Interpreter Lock — GIL), накладывающая некоторые ограничения на потоки. А именно, нельзя использовать несколько процессоров одновременно. Блокировка, позволяет только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток. Из этого следует, что с потоками невозможно использовать несколько ядер процессора.

GIL был введен в Python потому, что управление памятью CPython не является потокобезопасным. Имея такую блокировку Python может быть уверен, что никогда не будет условий гонки.

Во многопоточных программах отсутствие GIL может негативно сказываться на производительности процессоро-зависымых программ.

![image](https://user-images.githubusercontent.com/54559853/127723378-17c5daa9-46c0-4a24-b493-de66914bd3b1.png)  

Python подсчитывает количество ссылок для корректного управления памятью. Это означает, что созданные в Python объекты имеют переменную подсчёта ссылок, в которой хранится количество всех ссылок на этот объект. Как только эта переменная становится равной нулю, память, выделенная под этот объект, освобождается.

## Многопоточные и многопроцессорные программы в python
<a id="multithreaded-and-multiprocessing-programs-in-python"></a>
([наверх](#sections))

Параллелизм дает возможность работать над несколькими вычислениями одновременно в одной программе. Такого поведения в Python можно добиться несколькими способами:  
* Используя многопоточность `threading`, позволяя нескольким потокам работать по очереди.  
* Используя несколько ядер процессора `multiprocessing`. Делать сразу несколько вычислений, используя несколько ядер процессора. Это и называется параллелизмом.  
* Используя асинхронный ввод-вывод с модулем `asyncio`. Запуская какую то задачу, продолжать делать другие вычисления, вместо ожидания ответа от сетевого подключения или от операций чтения/записи.  

## Разница между потоками и процессами
<a id="difference-between-threads-and-processes"></a>
([наверх](#sections))

Поток `threading` - это независимая последовательность выполнения каких то вычислений. Поток `thread` делит выделенную память ядру процессора, а так же его процессорное время со всеми другими потоками, которые создаются программой в рамках одного ядра процессора. Программы на языке Python имеют, по умолчанию, один основной поток. Можно создать их больше и позволить Python переключаться между ними. Это переключение происходит очень быстро и кажется, что они работают параллельно.

Понятие процесс в `multiprocessing` - представляет собой так же независимую последовательность выполнения вычислений. В отличие от потоков `threading`, процесс имеет собственное ядро и следовательно выделенную ему память, которое не используется совместно с другими процессами. Процесс может клонировать себя, создавая два или более экземпляра в одном ядре процессора.

Асинхронный ввод-вывод не является ни потоковым (`threading`), ни многопроцессорным (`multiprocessing`). По сути, это однопоточная, однопроцессная парадигма и не относится к параллельным вычислениям.

## Что такое условия гонки и потокобезопасность?
<a id="what-are-race-conditions-and-thread-safety"></a>
([наверх](#sections))

Состояние гонки возникает, когда несколько потоков могут одновременно получать доступ к общей структуре данных или местоположению в памяти и изменять их, в следствии чего могут произойти непредсказуемые вещи.
  
Если два пользователя одновременно редактируют один и тот же документ онлайн и второй пользователь сохранит данные в базу, то перезапишет работу первого пользователя. Чтобы избежать условий гонки, необходимо заставить второго пользователя ждать, пока первый закончит работу с документом и только после этого разрешить второму пользователю открыть и начать редактировать документ.

Потокобезопасность работает путем создания копии локального хранилища в каждом потоке, чтобы данные не сталкивались с другим потоком.

## Алгоритм планирования доступа потоков к общим данным
<a id="algorithm-for-scheduling-access-of-streams-to-shared-data"></a>
([наверх](#sections))

Потоки используют одну и ту же выделенную память. Когда несколько потоков работают одновременно, то нельзя угадать порядок, в котором потоки будут обращаются к общим данным. Результат доступа к совместно используемым данным зависит от алгоритма планирования. который решает, какой поток и когда запускать. Если такого алгоритма нет, то конечные данные могут быть не такими как ожидаешь.

# GC
<a id="GC"></a>

* [Как в питоне обстоят дела с памятью (управлением памятью)](#memory-management-in-python)  
* [Сколько стоит проверка элемента в нотации?](#how-much-does-it-cost-to-validate-an-element-in-notation)  
* [Если есть два объекта и они указывают друг на друга](#two-objects)  

([наверх](#sections))

## Как в питоне обстоят дела с памятью (управлением памятью)
<a id="memory-management-in-python"></a>
([наверх](#sections))

Управление памятью в Python происходит автоматически, благодаря сборщику мусора, который удаляет объекты, которые больше не используются, для освобождения памяти.

Python использует два основных механизма управления памятью: ссылочный подсчет и сборку мусора.

* Ссылочный подсчет - это механизм, который считает количество ссылок на каждый объект в памяти. Когда количество ссылок на объект становится равным нулю, объект удаляется.

* Сборка мусора - это процесс, который автоматически освобождает память, занятую объектами, которые больше не используются. Сборщик мусора ищет объекты, которые не могут быть достигнуты ни из одной переменной, и удаляет их.

В Python есть также модуль `gc`, который предоставляет функции для контроля над сборщиком мусора. Например, можно задать максимальный размер кучи (`heap`), после которого сборщик мусора будет вызываться. Также можно использовать функцию `gc.collect()`, чтобы явно вызвать сборку мусора вручную.

Python также имеет функцию `sys.getsizeof()`, которая позволяет получить размер объекта в байтах. Она может быть полезна для оптимизации использования памяти в программе.

Кроме того, в Python есть возможность использовать различные библиотеки для управления памятью, такие как `memory_profiler` и `objgraph`, которые позволяют анализировать использование памяти в программе и находить утечки памяти.

## Сколько стоит проверка элемента в нотации?
<a id="how-much-does-it-cost-to-validate-an-element-in-notation"></a>
([наверх](#sections))

Проверка элемента в Python зависит от типа объекта, в котором нужно произвести проверку, и используемого метода проверки.

В общем случае, проверка элемента в Python происходит достаточно быстро и может быть выполнена за константное время O(1), когда элемент находится в списке (list) или словаре (dictionary), и за линейное время O(n), когда элемент нужно найти в кортеже (tuple) или множестве (set).

Например, для проверки наличия элемента в списке используется оператор `in` или метод `list.count()`. Оператор `in` возвращает `True`, если элемент присутствует в списке, и `False` в противном случае. Метод `list.count()` возвращает количество вхождений элемента в список.

Для проверки наличия элемента в словаре используется метод `dict.get()` или оператор `in`. Оператор `in` проверяет наличие ключа в словаре и возвращает `True`, если ключ присутствует, и `False` в противном случае. Метод `dict.get()` возвращает значение, связанное с указанным ключом, если ключ присутствует в словаре, и `None` в противном случае.

Для проверки наличия элемента в кортеже используется оператор `in`. Оператор `in` проверяет наличие элемента в кортеже и возвращает `True`, если элемент присутствует, и `False` в противном случае. Поскольку кортежи являются неизменяемыми, поиск элемента может занять линейное время O(n), где n - размер кортежа.

Для проверки наличия элемента в множестве используется, угадайте какой оператор - `in`. Множества в Python реализованы в виде хэш-таблиц, поэтому проверка наличия элемента занимает константное время O(1), если элемент находится в множестве.

Также стоит учитывать, что при работе с большими коллекциями данных, время проверки элементов может увеличиваться, и может потребоваться оптимизация алгоритма.
## Если есть два объекта и они указывают друг на друга
<a id="two-objects"></a>
([наверх](#sections))

Если в Python есть два объекта, которые указывают друг на друга, то такая ситуация называется циклической ссылкой или циклической зависимостью.

Циклическая ссылка возникает, когда объект A содержит ссылку на объект B, а объект B содержит ссылку на объект A. Например:

```py
a = [1, 2]
b = [3, 4]
a.append(b)
b.append(a)
```

В этом случае объект `a` содержит ссылку на объект `b` через метод `append()`, а объект `b` содержит ссылку на объект `a` через тот же метод.

Когда происходит циклическая ссылка, то сборщик мусора Python не может автоматически удалить эти объекты из памяти, потому что они по-прежнему имеют ссылки друг на друга и, следовательно, остаются взаимозависимыми.

Для решения этой проблемы Python использует алгоритм под названием "сборка мусора с подсчетом ссылок". Сборщик мусора проверяет, сколько ссылок ведет к каждому объекту в памяти. Если на объект не указывает ни одна ссылка, то он автоматически удаляется из памяти.

Однако, если объекты создают циклическую ссылку, то каждый объект в цикле имеет хотя бы одну ссылку на себя, что препятствует сборке мусора. В этом случае для удаления объектов из памяти требуется использовать специальные методы, такие как `gc.collect()`, которые вызывают сборку мусора вручную и позволяют обойти проблему циклических ссылок.

Кроме того, при использовании объектов с циклическими ссылками важно следить за использованием памяти, чтобы избежать утечек памяти, когда объекты не удаляются из-за взаимной ссылки.

# Итераторы, декораторы и генераторы
<a id="Iterators-decorators-and-generators"></a>
([наверх](#sections))

* [Что такое итератор?](#what-is-iterator)  
* [Что такое генератор?](what-is-generator)
* [Что такое декоратор?](#what-is-decorator)  
* [Какие декораторы стандартной библиотеки вы знаете?](#standard-library-decorators) 
* [Что такое list comprehension, какой синтаксис создания генераторов?](list-comprehension)
* [Является ли range итератором?](is-range-an-iterator)

([наверх](#sections))

## Что такое итератор?
<a id="what-is-iterator"></a>

Итераторы — объекты, которые позволяют обходить коллекции. Коллекции не должны обязательно существовать в памяти и быть конечными.

Итерируемый — объект, в котором есть метод `__iter__`. В свою очередь, итератор — объект, в котором есть два метода: `__iter__` и `__next__`. Почти всегда `iterator` возвращает себя из метода `__iter__`, так как они выступают итераторами для самих себя, но есть исключения.

В целом стоит избегать прямого вызова `__iter__` и `__next__`. При использовании `for` или генераторов списков Python вызывает эти методы сам. Если всё-таки необходимо вызвать методы напрямую, лучше использовать встроенные функции `iter` и `next` и в параметрах передаём итератор или контейнер. Например, если `c` — итерируемый, используем`iter(c)` вместо `c.__iter__()`. Если `a` — итератор, используем `next(a)`, а не `a.__next__()`. Это похоже на использование `len`.

Раз уж речь зашла о `len`, то стоит упомянуть, что итераторы не должны иметь и часто не имеют определённой длины. Поэтому в них часто нет имплементации `__len__`. Чтобы подсчитать количество элементов в итераторе, приходится делать это вручную или использовать `sum`. 

Некоторые итерируемые `(iterable)` не являются итераторами, но используют другие объекты как итераторы. Например, объект `list` относится к итерируемым, но не является итератором. В нём реализован метод `__iter__`, но отсутствует метод `__next__`. Итераторы объектов `list` относятся к типу `listiterator`. У объектов `list` есть определённая длина, а у `listiterator` нет.

```py
>>> a = [1, 2]
>>> type(a)
<type 'list'>
>>> type(iter(a))
<type 'listiterator'>
>>> it = iter(a)
>>> next(it)
1
>>> next(it)
2
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> len(a)
2
>>> len(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object of type 'listiterator' has no len()
```

Когда итератор завершает работу, интерпретатор Python ожидает возбуждения исключения `StopIteration`. Однако,  итераторы могут работать с бесконечными множествами. В таких случаях надо позаботиться о выходе из цикла.

Пример итератора - считает с нуля до бесконечности. Это упрощённая версия `itertools.count`.

```py
class count_iterator:
    n = 0

    def __iter__(self):
        return self

    def __next__(self):
        y = self.n
        self.n += 1
        return y
```

Пример использования. В последней строке сделана попытка превратить итератор в список. Это приводит к бесконечному циклу.

```py
>>> counter = count_iterator()
>>> next(counter)
0
>>> next(counter)
1
>>> next(counter)
2
>>> next(counter)
3
>>> list(counter)  # Бесконечный цикл
```

Если у объекта нет метода `__iter__`, его можно обойти, если определить метод `__getitem__`. В этом случае встроенная функция iter возвращает итератор с типом `iterator`, который использует `__getitem__` для обхода элементов списка. Этот метод возвращает `StopIteration` или `IndexError`, когда обход завершается. Пример:

```py
class SimpleList(object):
    def __init__(self, *items):
        self.items = items

    def __getitem__(self, i):
        return self.items[i]
```

И пример использования:

```py
>>> a = SimpleList(1, 2, 3)
>>> it = iter(a)
>>> next(it)
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

Ещё один интересный пример: генерация [последовательности Хофштадтера](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%A5%D0%BE%D1%84%D1%88%D1%82%D0%B0%D0%B4%D1%82%D0%B5%D1%80%D0%B0). В приведённом ниже коде итератор используется для генерации последовательности с помощью вложенных повторений.

```
Q(n)=Q(n−Q(n−1))+Q(n−Q(n−2))
```

Например, `qsequence([1, 1])` генерирует точную последовательность Хофштадтера. Мы используем исключение `StopIteration`, чтобы показать, что последовательность не может продолжаться, так как для генерации следующего элемента должен использоваться несуществующий индекс. Если в параметрах укзать значения [1, 2], последовательность немедленно заканчивается.

```py
class qsequence:
    def __init__(self, s):
        self.s = s[:]

    def __next__(self):
        try:
            q = self.s[-self.s[-1]] + self.s[-self.s[-2]]
            self.s.append(q)
            return q
        except IndexError:
            raise StopIteration()

    def __iter__(self):
        return self

    def current_state(self):
        return self.s
```

Пример использования:

```py
>>> Q = qsequence([1, 1])
>>> next(Q)
2
>>> next(Q)
3
>>> [next(Q) for __ in range(10)]
[3, 4, 5, 5, 6, 6, 6, 8, 8, 8]
```

## Что такое генератор?
<a id="what-is-generator"></a>
([наверх](#sections))

Генераторами называют итераторы, определение которых выглядит как определение функций.  
Ещё одно определение: генераторы — функции, которые внутри используют выражение `yield`. Генераторы не могут возвращать значения, вместо этого выдают элементы по готовности. Python автоматизирует запоминание контекста генератора, то есть текущий поток управления, значение локальных переменных и так далее. Каждый вызов метода `__next__` у объекта генератора возвращает следующее значение. Метод `__iter__` также реализуется автоматически. То есть генераторы можно использовать везде, где требуются итераторы.

```py
def count_generator():
   n = 0
   while True:
     yield n
     n += 1
```

Как это применяется на практике.

```py
>>> counter = count_generator()
>>> counter
<generator object count_generator at 0x106bf1aa0>
>>> next(counter)
0
>>> next(counter)
1
>>> iter(counter)
<generator object count_generator at 0x106bf1aa0>
>>> iter(counter) is counter
True
>>> type(counter)
<type 'generator'>
```

Теперь посмотрим на реализацию последовательности Q Хофштадтера с помощью генератора. Заметьте, эта реализация значительно проще использованного выше подхода. Однако здесь уже невозможно использовать методы типа current_state. Извне невозможно получить доступ к переменным, которые хранятся в контексте генератора.

Существует словарь `gi_frame.f_locals`, но он относится к CPython, но не входит в стандарт языка Python.

Одно из возможных решений — получение одновременно списка и результата.

```py
def hofstadter_generator(s):
    a = s[:]
    while True:
        try:
            q = a[-a[-1]] + a[-a[-2]]
            a.append(q)
            yield q
        except IndexError:
            Return
```

Итерация в данном примере завершается простым `return` без параметров. Внутри происходит возбуждение исключения `StopIteration`. Следующий пример связан с [распределением Бернулли](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%91%D0%B5%D1%80%D0%BD%D1%83%D0%BB%D0%BB%D0%B8), которое реализуется с помощью двух генераторов. Речь идёт о бесконечной последовательности случайных булевых значений. При этом вероятность `True` равна `p`, а вероятность `False` определяется формулой `q=1-p`. Затем применяется экстрактор фон Неймана, который принимает процесс Бернулли с `0 < p < 1` как источник энтропии и возвращает чистый процесс Бернулли с `p = 0.5`

```py
import random

def bernoulli_process(p):
    if p > 1.0 or p < 0.0:
        raise ValueError("p should be between 0.0 and 1.0.")

    while True:
        yield random.random() < p

def von_neumann_extractor(process):
    while True:
        x, y = next(proccess), next(process)
        if x != y:
            yield x
```

C помощью генераторов удобно реализовывать дискретные динамические системы. Пример ниже показывает, как с помощью генераторов реализуется [отображение тент](https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D1%82%D0%B5%D0%BD%D1%82).

```py
>>> def tent_map(mu, x0):
...    x = x0
...    while True:
...        yield x
...        x = mu * min(x, 1.0 - x)
...
>>>
>>> t = tent_map(2.0, 0.1)
>>> for __ in range(30):
...    print(next(t))
...
0.1
0.2
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.799999999999
0.400000000001
0.800000000003
0.399999999994
0.799999999988
0.400000000023
0.800000000047
0.399999999907
0.799999999814
0.400000000373
0.800000000745
0.39999999851
0.79999999702
```
Ещё один пример касается [последовательности Коллатца](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%9A%D0%BE%D0%BB%D0%BB%D0%B0%D1%82%D1%86%D0%B0).

```py
def collatz(n):
   yield n
   while n != 1:
     n = n / 2 if n % 2 == 0 else 3 * n + 1
     yield n
```

В этом примере не нужно вручную использовать `StopIteration`. Это исключение срабатывает автоматически, когда поток управления достигает конца функции.

Пример использования генератора:

```py
>>> # Если гипотеза Коллатца верна, list(collatz(n)) с любым n 
... # всегда завершается
>>> list(collatz(7))
[7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
>>> list(collatz(13))
[13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
>>> list(collatz(17))
[17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
>>> list(collatz(19))
[19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```

### Что такое декоратор?
<a id="what-is-decorator"></a>
([наверх](#sections))

Декоратор в Python - это функция, которая принимает другую функцию в качестве аргумента, добавляет какое-то поведение к этой функции и возвращает ее. Декораторы используются для модификации поведения функций без изменения их исходного кода.

Декораторы в Python реализованы в виде обычных функций, которые обычно имеют имя, начинающееся с символа `@`, за которым следует имя декоратора. Например:

```py
@decorator_function
def some_function():
    # ...
```

Здесь `decorator_function` - это имя декоратора, который будет применен к функции `some_function()`. Обратите внимание, что перед именем функции стоит символ `@`.

Примеры использования декораторов:

Декоратор, который измеряет время выполнения функции:

```py
import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Time taken: {end_time - start_time:.6f} seconds")
        return result
    return wrapper

@timer_decorator
def some_function():
    time.sleep(2)
    return "Done"
```

Здесь `timer_decorator` - это декоратор, который добавляет функциональность для измерения времени выполнения функции. Он принимает функцию в качестве аргумента, определяет внутри себя функцию-обертку wrapper, которая вызывает переданную функцию и измеряет время ее выполнения. Функция-обертка затем возвращает результат выполнения переданной функции.

Декоратор, который кэширует результаты функции:

```py
def cache_decorator(func):
    cache = {}
    def wrapper(*args):
        if args in cache:
            return cache[args]
        result = func(*args)
        cache[args] = result
        return result
    return wrapper

@cache_decorator
def fibonacci(n):
    if n in [0, 1]:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
```

Здесь `cache_decorator` - это декоратор, который кэширует результаты выполнения функции. Он определяет функцию-обертку wrapper, которая проверяет, есть ли результат выполнения функции с заданными аргументами в кэше. Если результат уже есть в кэше, то он возвращается, иначе вызывается переданная функция, результат ее выполнения сохраняется в кэше и возвращается.

Таким образом, декораторы в Python позволяют добавлять дополнительную функциональность к существующим функциям без изменения их исходного кода. Это делает код более читаемым и удобным для использования.

## Какие декораторы стандартной библиотеки вы знаете?
<a id="standard-library-decorators"></a>
([наверх](#sections))

Стандартная библиотека Python содержит множество полезных декораторов. Ниже перечислены некоторые из них:

* `functools.lru_cache()` - декоратор для кэширования результатов функции с использованием алгоритма LRU (Least Recently Used).

* `functools.singledispatch()` - декоратор для создания полиморфной функции, которая вызывает различные реализации функции в зависимости от типа аргумента.

* `contextlib.contextmanager()` - декоратор для создания менеджера контекста, который позволяет использовать блок with для выполнения операций до и после выполнения блока кода.

* `unittest.skipIf()` и `unittest.skipUnless()` - декораторы для пропуска тестов, если заданное условие истинно или ложно соответственно.

* `asyncio.coroutine()` и `asyncio.ensure_future()` - декораторы для определения и запуска асинхронных функций в asyncio.

* `property` - декоратор для определения атрибутов класса как свойств, которые вычисляются при доступе к ним.

* `staticmethod` - декоратор для определения статических методов класса, которые не требуют доступа к экземпляру класса.

* `classmethod` - декоратор для определения методов класса, которые принимают класс в качестве первого аргумента.

* `functools.partial()` - функция-фабрика для создания новой функции, которая является частичным применением другой функции с заданными аргументами.

* `wrapt.decorator()` - библиотека, содержащая декораторы для создания оберток вокруг функций с поддержкой множества возможностей, таких как поддержка декораторов, передача аргументов и т.д.

Это лишь некоторые примеры декораторов из стандартной библиотеки Python. Большинство из них используются для создания более чистого, понятного и эффективного кода.
## Что такое list comprehension, какой синтаксис создания генераторов?
<a id="list-comprehension"></a>
([наверх](#sections))

List comprehension - это способ создания нового списка на основе существующего списка (или другой итерируемой последовательности), используя синтаксис, который позволяет применять операции и фильтры к элементам списка. Это удобный способ создания списков с минимальным объемом кода.

Пример создания списка с помощью list comprehension:

```py
numbers = [1, 2, 3, 4, 5]
squares = [x**2 for x in numbers]
print(squares)  # Output: [1, 4, 9, 16, 25]
```

Это эквивалентно следующему коду с использованием цикла for:

```py
numbers = [1, 2, 3, 4, 5]
squares = []
for x in numbers:
    squares.append(x**2)
print(squares)  # Output: [1, 4, 9, 16, 25]
```

Также существует генератор, который работает похожим образом, но вместо создания списка генерирует значения по мере необходимости. Генераторы создаются с помощью генераторного выражения, которое заключается в круглые скобки вместо квадратных скобок в случае с list comprehension.

Пример создания генератора с помощью генераторного выражения:

```py
numbers = [1, 2, 3, 4, 5]
squares = (x**2 for x in numbers)
for num in squares:
    print(num)  # Output: 1, 4, 9, 16, 25
```

Это эквивалентно следующему коду с использованием цикла for и функции-генератора:

```py
def squares(nums):
    for x in nums:
        yield x**2

numbers = [1, 2, 3, 4, 5]
squares_gen = squares(numbers)
for num in squares_gen:
    print(num)  # Output: 1, 4, 9, 16, 25
```

Генераторы обычно используются для работы с большими объемами данных, когда нет необходимости хранить все значения в памяти, и когда требуется ленивое вычисление результатов.
