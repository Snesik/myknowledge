# Разделы:

* [Общие вопросы по python](#Общие-вопросы-по-python)
* [Базы данных](#Базы-данных)
* [Статистика](#Статистика)
* [Задачи и алгоритмы машинного обучения](#Задачи-и-алгоритмы-машинного-обучения)
* [Сеть](#Сеть)
* [Источники](#Источники)
<br/>

# Общие вопросы по python
* [Разница 2 и 3 версии python](#Разница-2-и-3-версии-python)  
* [ООП](#ООП)  
* [Типы и структуры данных в python](#Типы-и-структуры-данных-в-python)  
* [GIL](#GIL)  
* [GC](#GC)  
* [Декораторы](#Декораторы)  
* [Итераторы и генераторы](#Итераторы-и-генераторы)  
* [Алгоритмы](#Алгоритмы)  
* [Хранение данных](#Хранение-данных)  

## Разница 2 и 3 версии python

В Python 2 print был оператором: ```print "Hello, world"```  
В Python 3 print - функция: ```print ("Hello, world")```

В Python 2 были две функции: range - возвращает список; xrange - возвращает итератор  
В Python 3 есть только функция range, и она возвращает итератор

В Python 2 при делении целых чисел возвращает целоче число  
В Python 3 при делении целых чисел возвращает вещественное число

**Магические методы**

* Так как в Питоне 3 различий между строкой и юникодом больше нет, ``` __unicode__```  исчез, а появился ``` __bytes__```  (который ведёт себя так же как ``` __str__```  и ``` __unicode__```  в 2.7) для новых встроенных функций построения байтовых массивов.  
* Так как деление в Питоне 3 теперь по-умолчанию «правильное деление», ``` __div__```  больше нет.  
* ``` __coerce__```  больше нет, из-за избыточности и странного поведения.  
* ``` __cmp__```  больше нет, из-за избыточности.  
* ``` __nonzero__```  было переименовано в ``` __bool__``` .  
* ``` next```  у итераторов был переименован в ``` __next__``` .

## ООП
* [SOLID](##SOLID)  
* [Что такое классы?](##Что-такое-классы?)  
* [Что такое магические методы?](##Что-такое-магические-методы?)  
* [Какие магические методы и для чего используются?](##Какие-магические-методы-и-для-чего-используются?)  
* [Что такое миксин?](##Что-такое-миксин?)  

### SOLID

S - Принцип единственной ответственности (single responsibility principle)
Для каждого класса должно быть определено единственное назначение. Не должно возникать God object, который занимается всем в программе. 

O - Принцип открытости/закрытости (open–closed principle)
«программные сущности … должны быть открыты для расширения, но закрыты для модификации». Мы должны иметь возможность добавлять функциональность. 

L - Принцип подстановки Барбары Лисков (Liskov substitution principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения 
правильности выполнения программы». У объекта есть тип, но сами классы выстраиваются в иерархию классов. Подтип типа всю старую функциональность должен выполнять. 

I - Принцип разделения интерфейса (interface segregation principle)
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс 
общего назначения». Интерфейс - способ провзаимодействовать с какой-то программной действующей функцией. 

D - Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». 

### Что такое классы?

Класс — тип, описывающий устройство объектов. Объект — это экземпляр класса.
```
class C: 
  pass
имя_объекта = имя_класса()
```
У класса может не быть тела. 

Простейший пример класса:
```
class Rectangle:
  default_color = "green" # статический атрибут
  def __init__(self, width, height): # конструктор класса
    self.width = width # динамический атрибут
    self.height = height # динамический атрибут
```
В python нет возможности сделать несколько конструкторов. 

### Что такое магические методы?

Если какой-то идентификатор начинается с двух подчёркиваний, дальше пишется что-либо, потом снова два подчёркивания, то это спец метод. 

### Какие магические методы и для чего используются?
```
class FileObject:
  def __init__(self, filepath='~', filename='sample.txt'): # Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.
    self.file = open(join(filepath, filename), 'r+') # Открыть файл filename в filepath в режиме чтения и записи
  def __del__(self):
    self.file.close()
    del self.file
``` 
Метод, который будет вызван при инициализации объекта.  
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в ``` __init__``` . ``` __new__```  используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка.
``` 
__new__(cls, [...])
``` 
Инициализатор класса. Самый базовый магический метод, ``` __init__``` . С его помощью мы можем инициализировать объект.
``` 
__init__(self, [...]) 
``` 
Деструктор объекта
``` 
__del__
``` 

Самый базовый из методов сравнения ``` __cmp__(self, other)``` . Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). ``` __cmp__```  должен вернуть отрицательное число, если ``` self < other``` , ноль, если ``` self == other``` , и положительное число в случае ``` self > other``` . Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в ``` __cmp__``` . Но ``` __cmp__```  может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперируют одним критерием.

* ``` __eq__(self, other)``` 
Определяет поведение оператора равенства, ==.

* ``` __ne__(self, other)``` 
Определяет поведение оператора неравенства, !=.

* ``` __lt__(self, other)``` 
Определяет поведение оператора меньше, <.

* ``` __gt__(self, other)``` 
Определяет поведение оператора больше, >.

* ``` __le__(self, other)``` 
Определяет поведение оператора меньше или равно, <=.

* ``` __ge__(self, other)``` 
Определяет поведение оператора больше или равно, >=.

**Унарные операторы и функции**

Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.

* ``` __pos__(self)``` 
Определяет поведение для унарного плюса ```(+some_object)```

* ``` __neg__(self)``` 
Определяет поведение для отрицания```(-some_object)```

* ``` __abs__(self)``` 
Определяет поведение для встроенной функции ```abs()```.

* ``` __invert__(self)``` 
Определяет поведение для инвертирования оператором ~. Для объяснения что он делает смотри статью в Википедии о бинарных операторах.

* ``` __round__(self, n)``` 
Определяет поведение для встроенной функции ```round()```. n это число знаков после запятой, до которого округлить.

* ``` __floor__(self)``` 
Определяет поведение для ```math.floor()```, то есть, округления до ближайшего меньшего целого.

* ``` __ceil__(self)``` 
Определяет поведение для ```math.ceil()```, то есть, округления до ближайшего большего целого.

* ``` __trunc__(self)``` 
Определяет поведение для ```math.trunc()```, то есть, обрезания до целого.

**Обычные арифметические операторы**

* ```__add__(self, other)```
Сложение.

* ```__sub__(self, other)```
Вычитание.

* ```__mul__(self, other)```
Умножение.

* ```__floordiv__(self, other)```
Целочисленное деление, оператор //.

* ```__div__(self, other)```
Деление, оператор /.

* ```__truediv__(self, other)```
Правильное деление. Заметьте, что это работает только когда используется ```from __future__ import division```.

* ```__mod__(self, other)```
Остаток от деления, оператор %.

* ```__divmod__(self, other)```
Определяет поведение для встроенной функции divmod().

* ```__pow__```
Возведение в степень, оператор **.

* ```__lshift__(self, other)```
Двоичный сдвиг влево, оператор <<.

* ```__rshift__(self, other)```
Двоичный сдвиг вправо, оператор >>.

* ```__and__(self, other)```
Двоичное И, оператор &.

* ```__or__(self, other)```
Двоичное ИЛИ, оператор |.

* ```__xor__(self, other)```
Двоичный xor, оператор ^.

**Магические методы преобразования типов**

В Питоне множество магических методов, предназначенных для определения поведения для встроенных функций преобразования типов.

* ```__int__(self)```
Преобразование типа в int.

* ```__long__(self)```
Преобразование типа в long.

* ```__float__(self)```
Преобразование типа в float.

* ```__complex__(self)```
Преобразование типа в комплексное число.

* ```__oct__(self)```
Преобразование типа в восьмеричное число.

* ```__hex__(self)```
Преобразование типа в шестнадцатеричное число.

* ```__index__(self)```
Преобразование типа к int, когда объект используется в срезах (выражения вида ```[start:stop:step]```). Если вы определяете свой числовой тип, который может использоваться как индекс списка, вы должны определить ```__index__```.

* ```__trunc__(self)```
Вызывается при ```math.trunc(self)```. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

* ```__coerce__(self, other)```
Метод для реализации арифметики с операндами разных типов. ```__coerce__``` должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.

**Представление своих классов**

Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.

* ```__str__(self)```
Определяет поведение функции ```str()```, вызванной для экземпляра вашего класса.

* ```__repr__(self)```
Определяет поведение функции ```repr()```, вызванной для экземпляра вашего класса. Главное отличие от ```str()``` в целевой аудитории. ```repr()``` больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне), а ```str()``` предназначен для чтения людьми.

* ```__unicode__(self)```
Определяет поведение функции ```unicode()```, вызванной для экземпляра вашего класса. ```unicode()``` похож на ```str()```, но возвращает строку в юникоде. Если клиент вызывает ```str()``` на экземпляре вашего класса, а вы определили только ```__unicode__()```, то это не будет работать. Постарайтесь всегда определять ```__str__()``` для случая, когда кто-то не имеет такой роскоши как юникод.

* ```__format__(self, formatstr)```
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, ```"Hello, {0:abc}!".format(a)``` приведёт к вызову ``` a.__format__("abc")```. Это может быть полезно для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.

* ```__hash__(self)```
Определяет поведение функции ```hash()```, вызванной для экземпляра вашего класса. Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно нужно определять и ```__eq__``` тоже. Руководствуйтесь следующим правилом: ```a == b``` подразумевает ```hash(a) == hash(b)```.

* ```__nonzero__(self)```
Определяет поведение функции ```bool()```, вызванной для экземпляра вашего класса. Должна вернуть ```True``` или ```False```, в зависимости от того, когда вы считаете экземпляр соответствующим ```True``` или ```False```.

* ```__dir__(self)```
Определяет поведение функции ```dir()```, вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю список атрибутов. Обычно, определение ```__dir__``` не требуется, но может быть жизненно важно для интерактивного использования вашего класса, если вы переопределили ```__getattr__``` или ```__getattribute__```.

* ```__sizeof__(self)```
Определяет поведение функции``` sys.getsizeof()```, вызванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах.

**Магия контейнеров**

Магические методы, используемые контейнерами.

* ```__len__(self)```
Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.

* ```__getitem__(self, key)```
Определяет поведение при доступе к элементу, используя синтаксис ```self[key]```. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: TypeError если неправильный тип ключа и KeyError если ключу не соответствует никакого значения.

* ```__setitem__(self, key, value)```
Определяет поведение при присваивании значения элементу, используя синтаксис ```self[nkey] = value```. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать KeyError и TypeError в соответствующих случаях.

* ```__delitem__(self, key)```
Определяет поведение при удалении элемента (то есть ```del self[key]```). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.

* ```__iter__(self)```
Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции ```iter()``` и в случае перебора элементов контейнера выражением ```for x in container:```. Итераторы сами по себе объекты и они тоже должны определять метод ```__iter__```, который возвращает ```self```.

* ```__reversed__(self)```
Вызывается чтобы определить поведения для встроенной функции ```reversed()```. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.

* ```__contains__(self, item)```
```__contains__``` предназначен для проверки принадлежности элемента с помощью in и not in. Вы спросите, почему же это не часть протокола последовательности? Потому что когда ```__contains__``` не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает True если находит нужный.

* ```__missing__(self, key)```
```__missing__``` используется при наследовании от ```dict```. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь ```d``` и я пишу ```d["george"]``` когда "george" не является ключом в словаре, вызывается ```d.__missing__("george"))```.

**Построение дескрипторов**

Дескрипторы — это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).

Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из ```__get__```, ```__set__``` или ```__delete__```. 

* ```__get__(self, instance, instance_class)```
Определяет поведение при возвращении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. owner это тип (класс) объекта.

* ```__set__(self, instance, value)```
Определяет поведение при изменении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. value это значение для установки в дескриптор.

* ```__delete__(self, instance)```
Определяет поведение для удаления значения из дескриптора. ```instance``` это объект, владеющий дескриптором.

**Как вызывать магические методы** 

| **Магический метод**                  |	**Когда он вызывается (пример)**        |	**Объяснение**                                       |
|:--------------------------------------|:----------------------------------------|:-----------------------------------------------------| 
| ```__new__(cls [,...])```             |	```instance = MyClass(arg1, arg2)```    |	```__new__``` вызывается при создании экземпляра     |
| ```__init__(self [,...])```           |	```instance = MyClass(arg1, arg2)```    |	```__init__``` вызывается при создании экземпляра    |
| ```__cmp__(self, other)```            |	```self == other, self > other, etc.```	| Вызывается для любого сравнения                      |
| ```__pos__(self)```                   |	```+self```                            	| Унарный знак плюса                                   |
| ```__neg__(self)```                   |	```-self```	                            | Унарный знак минуса                                  |
| ```__invert__(self)```                |	```~self```	                            | Побитовая инверсия                                   |
| ```__index__(self)```                 |	```x[self]```	                          | Преобразование, когда объект используется как индекс |
| ```__nonzero__(self)```               |	```bool(self), if self:```             	| Булевое значение объекта                             |
| ```__getattr__(self, name)```         |	```self.name # name не определено```	  | Пытаются получить несуществующий атрибут             |
| ```__setattr__(self, name, val)```    |	```self.name = val```	                  | Присвоение любому атрибуту                           |
| ```__delattr__(self, name)```         |	```del self.name```	                    | Удаление атрибута                                    |
| ```__getattribute__(self, name)```    |	```self.name```	                        | Получить любой атрибут                               |
| ```__getitem__(self, key)```          |	```self[key]```	                        | Получение элемента через индекс                      |
| ```__setitem__(self, key, val)```     |	```self[key] = val```                  	| Присвоение элементу через индекс                     |
| ```__delitem__(self, key)```          |	```del self[key]```	                    | Удаление элемента через индекс                       |
| ```__iter__(self)```                  |	```for x in self```	                    | Итерация                                             |
| ```__contains__(self, value)```       |	```value in self, value not in self```	| Проверка принадлежности с помощью in                 |
| ```__call__(self [,...])```           |	```self(args)```	                      | «Вызов» экземпляра                                   |
| ```__enter__(self)```                 |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__exit__(self, exc, val, trace)``` |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__getstate__(self)```              |	```pickle.dump(pkl_file, self)```	      | Сериализация                                         |
| ```__setstate__(self)```              |	```data = pickle.load(pkl_file)```	    | Сериализация                                         |

### Что такое миксин?

Это класс, который реализует несколько методов, которые ты добавляешь к разным классам для того, чтобы они унаследовали и тоже получили какие-то методы. 

## Типы и структуры данных в python

* [Какие типы и структуры данных бывают в python?](###Какие-типы-и-структуры-данных-бывают-в-python?)  
* [Что такое мутабельные и иммутабельные типы данных?](###Что-такое-мутабельные-и-иммутабельные-типы-данных?)  
* [Что может быть в качестве ключа словаря?](###Что-может-быть-в-качестве-ключа-словаря?)  
* [Что такое хеш-функция?](#Ч##то-такое-хеш-функция?)  
* [В чём особенность словаря в python?](###В-чём-особенность-словаря-в-python?)  
* [Списки, тьюплы и сеты в чём их отличие?](###Списки,-тьюплы-и-сеты-в-чём-их-отличие?)  
* [Списки, тьюплы и сеты в чём их отличие?](###Списки,-тьюплы-и-сеты-в-чём-их-отличие?)  

### Какие типы и структуры данных бывают в python?

| *Объект*                          | *Тип*                      | 
|:---------------------------------:|:--------------------------:| 
| Строка                            | str                        |
| Целое число                       | int                        |
| Число с плавающей точкой          | float                      |
| Список                            | list                       |
| Кортеж                            | tuple                      |
| Словарь                           | dict                       |
| Множество                         | set                        |
| Логический                        | bool                       |
| Функция                           | function                   |
| Класс, определяемый пользователем | type                       |
| Экземпляр класса                  | class                      |
| Встроенная функция                | builtin_function_or_method |
| type                              | type                       |

### Что такое мутабельные и иммутабельные типы данных?

Объекты в питоне бывают двух значительно отличающихся сортов: изменяемые (mutable) и неизменяемые (immutable). Неизменяемыми являются целые и действительные числа (int, float), строки (str), последовательности байтов (бинарные данные, bytes), а также кортежи, все элементы которых неизменяемы (tuple). Напротив, списки (list), словари (dict) и множества (set) являются изменяемыми.

### Что может быть в качестве ключа словаря?

Только неизменяемые типы данных. Ключами словаря могут являться только объекты, поддерживающие хеширование. Таким образом, использовать в качестве ключей списки, словари и другие изменяемые типы не получится. Если в словарь будут добавлены несколько значений с одним и тем же ключом, словарь сохранит последнее.

Не рекомендуется использоваться в качестве ключей числа с плавающей запятой, так как они хранятся в памяти в виде приближений.

### Что такое хеш-функция?

Хэш-функция - это функция, которая принимает на вход какие-либо данные (например, строки) и возвращает число по некоторому заданному алгоритму.  
Назначением хэш-функций является возможность помещения некоторого элемента (например, строки) в хэш-таблицу, на основе которых реализованы, например, словари и множества в Python. 

Одинаковые данные будут иметь одинаковое хеш-значение.  
* Даже небольшое изменение исходных данных может привести к совершенно иному хеш-значению.  
* Хеш получается из хеш-функции, в обязанности которой входит преобразование данной информации в закодированный хеш.   
* Очевидно, что количество объектов может быть намного больше, чем количество хеш-значений, и поэтому два объекта могут хешировать одно и то же. Это называется конфликтом хэша. Это означает, что если два объекта имеют одинаковый хэш-код, они не обязательно имеют одно и то же значение.  

Cрок жизни хэша зависит только от области действия программы, и он может измениться, как только программа завершится.

### В чём особенность словаря в python?

Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.  

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами:  

* Во-первых, с помощью литерала:
  ```
  d = {}
  print(d)
  {}
  d = {'dict': 1, 'dictionary': 2}
  prtin(d)
  {'dict': 1, 'dictionary': 2}
  ```
  
* Во-вторых, с помощью функции dict:
```
  d = dict(short='dict', long='dictionary')
  prtin(d)
  {'short': 'dict', 'long': 'dictionary'}
  d = dict([(1, 1), (2, 4)])
  prtin(d)
  {1: 1, 2: 4}
```

* В-третьих, с помощью метода fromkeys:
```
  d = dict.fromkeys(['a', 'b'])
  prtin(d)
  {'a': None, 'b': None}
  d = dict.fromkeys(['a', 'b'], 100)
  prtin(d)
  {'a': 100, 'b': 100}
```

* В-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.
```
  d = {a: a ** 2 for a in range(7)}
  prtin(d)
  {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

**Методы словарей**  

* ```dict.clear()``` - очищает словарь.
* ```dict.copy()``` - возвращает копию словаря.
* ```classmethod dict.fromkeys(seq[, value])``` - создает словарь с ключами из ```seq``` и значением ```value``` (по умолчанию ```None```).
* ```dict.get(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает ```default``` (по умолчанию ```None```).
* ```dict.items()``` - возвращает пары (ключ, значение).
* ```dict.keys()``` - возвращает ключи в словаре.
* ```dict.pop(key[, default])``` - удаляет ключ и возвращает значение. Если ключа нет, возвращает ```default``` (по умолчанию бросает исключение).
* ```dict.popitem()``` - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение ```KeyError```. Важно помнить, что словари неупорядочены.
* ```dict.setdefault(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением ```default``` (по умолчанию ```None```).
* ```dict.update([other])``` - обновляет словарь, добавляя пары (ключ, значение) из ```other```. Существующие ключи перезаписываются. Возвращает ```None``` (не новый словарь!).
* ```dict.values()``` - возвращает значения в словаре.

### Списки, тьюплы и сеты в чём их отличие?

_List (список)_
Базовая структура данных в python. Элементы в списке хранятся последовательно, каждому из них присвоены индексы, начиная с нуля. В отличие от массива, список может хранить объекты любого типа.

Создание списка
```
my_list = [] # Создание пустого списка с помощью литерала списка
my_list = list() # Создание пустого списка с помощью встроенной функции

my_list = [1,2,['a','b'],4,5] # Инициализация списка

my_list = list('hello world') # Создание списка из итерируемого объекта
print(my_list)
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

my_list = [x for x in range(10)] # Генератор списков в действии
print(my_list)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
Доступные методы
* ```my_list.append(x)``` - добавляет x в конец списка
* ```my_list.clear()``` - очищает 
* ```my_list.copy()``` - возвращает копию списка ```my_list```
* ```my_list.count(x)``` - возвращает кол-во элементов со значением x
* ```my_list.extend(x)``` - добавляет элементы списка x к концу списка ```my_list```
* ```my_list.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)
* ```my_list.insert(index, x)``` - вставляет x на заданную позицию
* ```my_list.pop(index)``` - возвращает элемент с указанным индексом и удаляет его, если индекс не указан - возвращается и удаляется последний элемент
* ```my_list.remove(x)``` - удаляет первый элемент со значением x
* ```my_list.reverse()``` - инвертирует порядок элементов в списке
* ```my_list.sort(key=x)``` сортирует список на основе функции x  

В каких случаях использовать?
Для хранения элементов, объединенных каким либо признаком. В случае, если изменение элементов и/или расширение списка не предполагается, следует использовать неизменяемый аналог - кортеж.

_Tuple (кортёж)_
Кортеж - это неизменяемый и более быстрый аналог списка. Он защищает хранимые данные от непреднамеренных изменений и может использоваться в качестве ключа в словарях (словарь - ассоциативный массив в python).

Создание кортежа.
```
my_tuple = () # Создание кортежа с помощью литерала
my_tuple = tuple() # Создание кортежа с помощью встроенной функции

my_tuple = (1,2,['a','b'],4,5) # Инициализация кортежа

my_tuple = tuple('hello world') # Создание кортежа из итерируемого объекта
print(my_tuple)
('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')

my_tuple = tuple(2**x for x in [0, 1, 2, 3]) # Генератор кортежей
print(my_tuple)
(1, 2, 4, 8)
```
Доступные методы
* ```my_tuple.count(x)``` - возвращает кол-во элементов со значением x
* ```my_tuple.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)  

В каких случаях использовать?
Для хранения данных вместо списка (если они не предполагают изменений).

_Set (множество)_
Множество - это набор уникальных элементов в случайном порядке (неупорядоченный список). Множества примечательны тем, что операция проверки "принадлежит ли объект множеству" происходит значительно быстрее аналогичных операций в других структурах данных.

Создание множества
```
my_something = {} # !!! Попытка создать множество при помощи литерала даст нам словарь
type(my_something)
<class 'dict'> 

my_set = set() # Создание при помощи встроенной функции

my_set = {1,2,3,4,5} # Инициализация множества

my_set = set('hello world') # Создания множества из итерируемого объекта
print(my_set)
{'r', 'o', 'e', 'h', 'd', 'w', 'l', ' '}

my_set = {x for x in range(10)} # Генератор множеств
print(my_set)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```
Доступные методы
* ```my_set.add(x)``` - добавляет x во множество
* ```my_set.difference(x)``` - возвращает множество элементов ```my_set```, которые не входят во множество ```x```
* ```my_set.difference_update(x)``` - удаляет из множества my_set все элементы, которые входят во множество ```x```
* ```my_set.discard(x)``` - удаляет элемент ```x``` из ```my_set```
* ```my_set.intersection(x)``` - возвращает элементы общие для множеств ```my_set``` и ```x```
* ```my_set.intersection_update(x)``` - удаляет из множества ```my_set``` элементы, которых нет во множестве ```x```
* ```my_set.isdisjoint(x)``` - возвращает ```true``` если ```my_set``` и ```x``` не содержат одинаковых значений
* ```my_set.issubset(x)``` - возвращает true если все элементы ```my_set``` входят во множество ```x```
* ```my_set.issuperset(x)``` - возвращает ```true``` если все элементы x входят во множество ```my_set```
* ```my_set.pop()``` - возвращает и удаляет первый (на данный момент) элемент множества
* ```my_set.remove(x)``` - удаляет ```x``` из множества
* ```my_set.symmetric_difference(x)``` - возвращает все элементы из ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.symmetric_difference_update(x)``` - обновляет исходное множество таким образом, что оно будет состоять из всех элементов ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.union(x)``` - возвращает новое множество, состоящее из всех элементов ```x``` и ```my_set```
* ```my_set.update(x)``` - добавляет в ```my_set``` все элементы ```x``` 

В каких случаях использовать?
Когда необходимо проверять принадлежит ли значение набору уникальных элементов и отсутствует необходимость поддерживать порядок в данном наборе.

### Сколько стоит проверка элемента в нотации?

## GIL

### Что такое GIL?

В Python используется глобальная блокировка интерпретатора (Global Interpreter Lock — GIL), накладывающая некоторые ограничения на потоки. А именно, нельзя использовать несколько процессоров одновременно. Блокировка, позволяет только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток.  

Во многопоточных программах отсутствие GIL может негативно сказываться на производительности процессоро-зависымых программ.

![image](https://user-images.githubusercontent.com/54559853/127723378-17c5daa9-46c0-4a24-b493-de66914bd3b1.png)  

Python подсчитывает количество ссылок для корректного управления памятью. Это означает, что созданные в Python объекты имеют переменную подсчёта ссылок, в которой хранится количество всех ссылок на этот объект. Как только эта переменная становится равной нулю, память, выделенная под этот объект, освобождается.

### Многопоточные и многопроцессорные программы в python

## GC

### Как в питоне обстоят дела с памятью (управлением памятью)

### Если есть два объекта и они указывают друг на друга

## Декораторы

**Что такое декораторы?**

**Какие декораторы стандартной библиотеки вы знаете?**

## Итераторы и генераторы

**Что такое итератор?**

**Что такое генератор?**

**Что такое list comprehension, какой синтаксис создания генераторов?**

**Является ли range итератором?**

## Алгоритмы

## Хранение данных

**Что такое json?**

**Что такое csv?**

**Что такое XML?**

<br/>

# Базы данных

## Что такое СУБД?

Чтобы правильно обрабатывать различные запросы (поиск, изменение, удаление и т.д) в базу данных, нужно специальное программное обеспечение, такое ПО получило название системы управления базами данных (СУБД).

СУБД — это общий термин, относящийся ко всем видам абсолютно разных инструментов, от компьютерных программ до встроенных библиотек. Эти приложения управляют или помогают управлять наборами данных. Так как эти данные могут быть разного формата и размера, были созданы разные виды СУБД.

СУБД основаны на моделях баз данных — определённых структурах для обработки данных. Каждая СУБД создана для работы с одной из них с учётом особенностей операций над информацией.

Хотя решений, реализующих различные модели баз данных, очень много, периодически некоторые из них становятся очень популярными и используются на протяжении многих лет. Сейчас самой популярной моделью является реляционная система управления базами данных (РСУБД).

## Какие типы СУБД в соответствии с моделями данных вы знаете?

* Реляционные, которые поддерживают установку связей между таблицами с помощью первичных и внешних ключей. Пример — MySQL.
* Flat File — базы данных с двумерными файлами, в которых содержатся записи одного типа и отсутствует связь с другими файлами, как в реляционных. Пример — Excel.
* Иерархические подразумевают наличие записей, связанных друг с другом по принципу отношений один-к-одному или один-ко-многим. А вот для отношений многие-ко-многим следует использовать реляционную модель. Пример — Adabas.
* Сетевые похожи на иерархические, но в этом случае «ребёнок» может иметь несколько «родителей» и наоборот. Примеры — IDS и IDMS.
* Объектно-ориентированные СУБД работают с базами данных, которые состоят из объектов, используемых в ООП. Объекты группируются в классы и называются экземплярами, а классы в свою очередь взаимодействуют через методы. Пример — Versant.
* Объектно-реляционные обладают преимуществами реляционной и объектно-ориентированной моделей. Пример — IBM Db2.
* Многомерная модель является разновидностью реляционной и использует многомерные структуры. Часто представляется в виде кубов данных. Пример — Oracle Essbase.
* Гибридные состоят из двух и более типов баз данных. Используются в том случае, если одного типа недостаточно для обработки всех запросов. Пример — Altibase HDВ.

## Что такое первичный ключ?

Первичный ключ или ```PRIMARY KEY``` предназначен для однозначной идентификации каждой записи в таблице и является строго уникальным (```UNIQUE```): две записи таблицы не могут иметь одинаковые значения первичного ключа. Нулевые значения (```NULL```) в ```PRIMARY KEY``` не допускаются. Если в качестве ```PRIMARY KEY``` используется несколько полей, их называют составным ключом.  
Первичный ключ, используется в качестве основного ключа и может быть использован для связи с дочерней таблицей, содержащей внешний ключ.

Пример:
```
CREATE TABLE USERS (
  id INT NOT NULL,
  name VARCHAR (20) NOT NULL,
  PRIMARY KEY (id)
);
```
Здесь в качестве первичного ключа используется поле id.

## Что такое внешний ключ?

Внешний ключ или ```FOREIGN KEY``` также является атрибутом ограничения и обеспечивает связь двух таблиц. По сути, это поле или несколько полей, которые ссылаются на ```PRIMARY KEY``` в родительской таблице.

Пример использования:
```
CREATE TABLE order (
  order_id INT NOT NULL,
  user_id INT,
  PRIMARY KEY (order_id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```
В данном случае внешний ключ, привязанный к полю ```user_id``` в таблице ```order```, ссылается на первичный ключ ```id``` в таблице ```users```, и именно по этим полям происходит связывание двух таблиц.

## Ограничения в SQL

SQL-ограничения (constraints) указываются при создании или изменении таблицы. Это правила для ограничения типа данных, которые могут храниться в таблице. Действие с данными не будет выполнено, если нарушаются установленные ограничения.

* ```UNIQUE``` — гарантирует уникальность значений в столбце;
* ```NOT NULL``` — значение не может быть ```NULL```;
* ```INDEX``` — создаёт индексы в таблице для быстрого поиска/запросов;
* ```CHECK``` — значения столбца должны соответствовать заданным условиям;
* ```DEFAULT``` — предоставляет столбцу значения по умолчанию.

## Что такое Self JOIN?

Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные таблицы. Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.

Следующий SQL-запрос объединяет клиентов из одного города:
```
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City
ORDER BY A.City;
```
## Подстановочные знаки

Это специальные символы, которые нужны для замены каких-либо знаков в запросе. Они используются вместе с оператором ```LIKE```, с помощью которого можно отфильтровать запрашиваемые данные.

% — заменить ноль или более символов;
_ — заменить один символ.
Примеры:
```
SELECT * FROM user WHERE name LIKE '%test%';
```
Данный запрос позволяет найти данные всех пользователей, имена которых содержат в себе «test».
```
SELECT * FROM user WHERE name LIKE 't_est';
```
В этом случае имена искомых пользователей начинаются на «t», после содержат какой-либо символ и «est» в конце.

## Что делают псевдонимы Aliases?

SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу. Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами. В этом случае для удобства в составлении запроса используются псевдонимы. SQL-псевдоним существует только на время запроса.

Пример:
```
SELECT very_long_column_name AS alias_name
FROM table;
```
## Разница между командами DELETE и TRUNCATE

Команда ```DELETE``` — это DML-операция, которая удаляет записи из таблицы, соответствующие заданному условию:

```DELETE FROM table_name WHERE condition;```
При этом создаются логи удаления, то есть операцию можно отменить.

А вот команда ```TRUNCATE``` — это DDL-операция, которая полностью пересоздаёт таблицу, и отменить такое удаление невозможно:

```TRUNCATE TABLE table_name;```

DML (Data Manipulation Language) - язык манипулирования данными. Язык DML позволяет осуществлять манипуляции с данными таблиц, т.е. с ее строками. Он позволяет делать выборку данных из таблиц, добавлять новые данные в таблицы, а так же обновлять и удалять существующие данные.  

DDL (Data Definition Language) - язык описания данных. Язык DDL служит для создания и модификации структуры БД, т.е. для создания/изменения/удаления таблиц и связей.

## Основные команды SQL

* ```SHOW DATABASES```  

  SQL-команда, которая отвечает за просмотр доступных баз данных.
  
* ```CREATE DATABASE```  
  
  Команда для создания новой базы данных.
  
* ```USE```  

  С помощью этой SQL-команды ```USE <database_name>``` выбирается база данных, необходимая для дальнейшей работы с ней.
  
* ```SOURCE```  

  ```SOURCE <file.sql>``` позволит выполнить сразу несколько SQL-команд, содержащихся в файле с расширением .sql.
  
* ```DROP DATABASE```  
  
  Стандартная SQL-команда для удаления целой базы данных.
  
* ```DROP TABLE```  

  Так можно удалить всю таблицу целиком.  
  
* ```DELETE```  

  SQL-команда ```DELETE FROM <table_name>``` используется для удаления данных из таблицы.
  
* ```SHOW TABLES```  

  С помощью этой команды можно увидеть все таблицы, которые доступны в базе данных.
  
* ```DESCRIBE```  
  
  С помощью ```DESCRIBE <table_name>``` можно просмотреть различные сведения (тип значений, является ключом или нет) о столбцах таблицы.
  
* ```CREATE TABLE```
  SQL-команда для создания новой таблицы:
  ```
  CREATE TABLE <table_name1> (
    <col_name1><col_type1>,
    <col_name2><col_type2>,
    <col_name3><col_type3>
    PRIMARY KEY(<col_name1>),
    FOREIGN KEY(<col_name2>) REFERENCES <table_name2>(<col_name2>)
  );
  ```
  Ограничения целостности при использовании ```CREATE TABLE```  
  Может понадобиться создать ограничения для определённых столбцов в таблице. При создании таблицы можно задать следующие ограничения:

  * ячейка таблицы не может иметь значение ```NULL```;
  * первичный ключ — ```PRIMARY KEY(col_name1, col_name2, …)```;
  * внешний ключ — ```FOREIGN KEY(col_namex1, …, col_namexn) REFERENCES table_name(col_namex1, …, col_namexn)```.  
  
  Можно задать больше одного первичного ключа. В этом случае получится составной первичный ключ.

  Пример
  Создайте таблицу «instructor»:
```
  CREATE TABLE instructor (
    ID CHAR(5),
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    salary NUMERIC(8,2),
    PRIMARY KEY (ID),
    FOREIGN KEY (dept_name) REFERENCES department(dept_name)
  );
```

* UNION  

  Он используется для объединения полученных данных из двух или более запросов, которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в   том же порядке.  

  Пример использования:
  ```
  SELECT column(s) FROM first_table
  UNION
  SELECT column(s) FROM second_table;
  ```
  
* ```INSERT```  

  Команда ```INSERT INTO <table_name>``` в SQL отвечает за добавление данных в таблицу:
  ```
  INSERT INTO <table_name> (<col_name1>, <col_name2>, <col_name3>, …)
    VALUES (<value1>, <value2>, <value3>, …); 
  ```
  При добавлении данных в каждый столбец таблицы не требуется указывать названия столбцов.
  ```
  INSERT INTO <table_name>
    VALUES (<value1>, <value2>, <value3>, …);
  ```
  
* ```UPDATE```  

  SQL-команда для обновления данных таблицы:
  ```
  UPDATE <table_name>
    SET <col_name1> = <value1>, <col_name2> = <value2>, ...
    WHERE <condition>;
  ```
  
* ```SELECT```  
  
  ```SELECT``` используется для получения данных из выбранной таблицы:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>; 
  ```
  Следующей командой можно вывести все данные из таблицы:
  ```
  SELECT * FROM <table_name>;
  ```
  
* ```SELECT DISTINCT```
 
  В столбцах таблицы могут содержаться повторяющиеся данные. ```SELECT DISTINCT``` используется для получения только неповторяющихся данных.
  ```
  SELECT DISTINCT <col_name1>, <col_name2>, …
    FROM <table_name>; 
  ```

* ```WHERE```  
  
  Можно использовать ключевое слово ```WHERE``` в ```SELECT``` для указания условий в запросе:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <condition>; 
  ```
  В запросе можно задавать следующие условия:

  сравнение текста;
  сравнение численных значений;
  логические операции AND (и), OR (или) и NOT (отрицание).
  Пример:
  ```
  SELECT * FROM table WHERE author='Достоевский';
  SELECT * FROM table WHERE price>3000;
  SELECT * FROM table WHERE amount=10; 
  ```
  
* ```GROUP BY```  
  
  Оператор ```GROUP BY``` часто используется с агрегатными функциями, такими как ```COUNT```, ```MAX```, ```MIN```, ```SUM``` и ```AVG```, для группировки выходных значений.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    GROUP BY <col_namex>; 
  ```
  Пример
  Выведем количество курсов для каждого факультета:
  ```
  SELECT COUNT(course_id), dept_name
    FROM course
    GROUP BY dept_name; 
  ```
  
* ```HAVING```  
  
  Ключевое слово ```HAVING``` было добавлено в SQL по той причине, что ```WHERE``` не может использоваться для работы с агрегатными функциями.
  ```
  SELECT <col_name1>, <col_name2>, ...
    FROM <table_name>
    GROUP BY <column_namex>
    HAVING <condition> 
  ```
  Пример
  Выведем список факультетов, у которых более одного курса:
  ```
  SELECT COUNT(course_id), dept_name
    FROM course
    GROUP BY dept_name
    HAVING COUNT(course_id)>1; 
  ```
  
* ```ORDER BY```  
  
  ```ORDER BY``` используется для сортировки результатов запроса по убыванию или возрастанию. ```ORDER BY``` отсортирует по возрастанию, если не будет указан способ сортировки ```ASC``` или ```DESC```.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    ORDER BY <col_name1>, <col_name2>, … ASC|DESC;
  ```
  Пример
  Выведем список курсов по возрастанию и убыванию количества кредитов:
  ```
  SELECT * FROM course ORDER BY credits;
  SELECT * FROM course ORDER BY credits DESC;
  ```
  
* ```BETWEEN```  

  ```BETWEEN``` используется для выбора значений данных из определённого промежутка. Могут быть использованы числовые и текстовые значения, а также даты.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namex> BETWEEN <value1> AND <value2>;
  ```
  Пример
  Выведем список инструкторов, чья зарплата больше 50 000, но меньше 100 000:
  ```
  SELECT * FROM instructor
    WHERE salary BETWEEN 50000 AND 100000; 
  ```

* ```LIKE```  

  Оператор ```LIKE``` используется в ```WHERE```, чтобы задать шаблон поиска похожего значения.

  Есть два свободных оператора, которые используются в ```LIKE```:

  % (ни одного, один или несколько символов);
  _ (один символ).
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namex> LIKE <pattern>; 
  ```
  Пример
  Выведем список курсов, в имени которых содержится «to», и список курсов, название которых начинается с «CS-»:
  ```
  SELECT * FROM course WHERE title LIKE ‘%to%’;
  SELECT * FROM course WHERE course_id LIKE 'CS-___';
  ```

* ```IN```  
  
  С помощью ```IN``` можно указать несколько значений для оператора ```WHERE```:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namen> IN (<value1>, <value2>, …);
  ```
  Пример
  Выведем список студентов с направлений Comp. Sci., Physics и Elec. Eng.:
  ```
  SELECT * FROM student
    WHERE dept_name IN (‘Comp. Sci.’, ‘Physics’, ‘Elec. Eng.’);
  ```
  
* ```JOIN```  

  ```JOIN``` используется для связи двух или более таблиц с помощью общих атрибутов внутри них.
  Чтобы объединить две таблицы в одну, следует использовать оператор ```JOIN```. Соединение таблиц может быть внутренним (```INNER```) или внешним (```OUTER```), причём внешнее соединение может быть левым (```LEFT```), правым (```RIGHT```) или полным (```FULL```).

  * ```INNER JOIN``` — получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.
  * ```FULL OUTER JOIN``` — объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
  * ```LEFT JOIN``` — возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.
  * ```RIGHT JOIN``` — работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.
  ```
  SELECT <col_name1>, <col_name2>, …
  FROM <table_name1>
  JOIN <table_name2>
  ON <table_name1.col_namex> = <table2.col_namex>;
  ```
  Следующий запрос выбирает все заказы с информацией о клиенте:
  ```
  SELECT Orders.OrderID, Customers.CustomerName
  FROM Orders
  INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
  ```
  
* ```VIEW```  
  
  ```VIEW``` — это виртуальная таблица SQL, созданная в результате выполнения выражения. Она содержит строки и столбцы и очень похожа на обычную SQL-таблицу. VIEW всегда показывает самую свежую информацию из базы данных.

  Создание
  ```
  CREATE VIEW <view_name> AS
    SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <condition>;
  ```
  Удаление
  ```
  DROP VIEW <view_name>;
  ```

## Математические функции в SQL

|**Функция**|	**Описание**	|**Пример**|
|:------------------------------|:--------------------------|:--------------------------|
| ```CEILING(x)``` |	возвращает наименьшее целое число, большее или равное x(округляет до целого числа в большую сторону)|```	CEILING(4.2)=5 CEILING(-5.8)=-5```|
| ```ROUND(x, k)``` |	округляет значение x до k знаков после запятой, если k не указано – x округляется до целого	|```ROUND(4.361)=4 ROUND(5.86592,1)=5.9```|
| ```FLOOR(x)``` |	возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)	|```FLOOR(4.2)=4 FLOOR(-5.8)=-6```|
| ```POWER(x, y)``` |	возведение x в степень y	|```POWER(3,4)=81.0```|
| ```SQRT(x)``` |	квадратный корень из x	|```SQRT(4)=2.0 SQRT(2)=1.41...```|
| ```DEGREES(x)``` |	конвертирует значение x из радиан в градусы	|```DEGREES(3) = 171.8...```|
| ```RADIANS(x)``` |	конвертирует значение x из градусов в радианы	|```RADIANS(180)=3.14...```|
| ```ABS(x)``` |	модуль числа x	|```ABS(-1) = 1 ABS(1) = 1```|
| ```PI()``` |	pi = 3.1415926...	 ||
| ```COUNT(col_name)``` | возвращает количество строк||
| ```SUM(col_name)``` | возвращает сумму значений в данном столбце||
| ```AVG(col_name)``` | возвращает среднее значение данного столбца||
| ```MIN(col_name)``` | возвращает наименьшее значение данного столбца||
| ```MAX(col_name)``` | возвращает наибольшее значение данного столбца||

**Оконные функции в SQL**

<br/>

# Статистика

**Что такое доверительные интервалы?**

**Что такое статистическая значимость?**

<br/>

# Задачи и алгоритмы машинного обучения

## Задачи машинного обучения

### Что такое обучение с учителем?

В данном случае в тренировочном датасете для кажого объекта у нас есть метка или лэйбл. В тестовом - этого лейбла нет и нам нужно его предсказать. 
Бывает два подтипа решения задач с учителем:

* Регрессия

В задачах регрессии меткой является вещественное число.  

Например, если мы предсказываем стоимость квартиры, то это будет задача регрессии.

* Классификация

В данном случае мы предсказываем не вещественное число, а конечно подмножество классов.  
Если таких классов два, то это задача бинарной классификации.
Если больше двух, то это многоклассовая классификация.  

Например, если мы предсказываем есть на фотографии машина или нет, то это задача бинарной классификации, потому-что у нас в данном случае два класса (либо машина есть, либо её нет)

### Что такое обучение без учителя?

В данном случае у нас нет лейблов для объектов, и мы не пытаемся их предсказать.  
Бывает несколько подтипов решения задач без учителя:

* Кластеризация

В данном случае попытаемся выявить некоторые паттерны в данных и объединить их в кластеры. Так, чтобы в одном кластере были похожие объекты, а в разных кластерах они были разные.  

Например, мы хотим разбить фильмы по жанрам и мы не знаем какие у нас жанры есть, мы хотим понять чем они отличаются друг от друга и на какое количество кластеров их хорошо разбить.

* Задача понижения размерности  

В данном случае мы хотим вектора большой размерности ужать до меньшей, при этом сохранить как можно больше информации

* Визуализация

Уменьшаем размерность до состояния, когда её можно визуализировать

### Что такое классификация?

Классификация — один из разделов машинного обучения, посвященный решению следующей задачи. Имеется множество объектов (ситуаций), разделённых некоторым образом на классы. Задано конечное множество объектов, для которых известно, к каким классам они относятся. Это множество называется обучающей выборкой. Классовая принадлежность остальных объектов не известна. Требуется построить алгоритм, способный классифицировать произвольный объект из исходного множества.  

Классифицировать объект — значит, указать номер (или наименование класса), к которому относится данный объект.  

Классификация объекта — номер или наименование класса, выдаваемый алгоритмом классификации в результате его применения к данному конкретному объекту.  

В математической статистике задачи классификации называются также задачами дискриминантного анализа.

В машинном обучении задача классификации относится к разделу обучения с учителем. Существует также обучение без учителя, когда разделение объектов обучающей выборки на классы не задаётся, и требуется классифицировать объекты только на основе их сходства друг с другом. В этом случае принято говорить о задачах кластеризации или таксономии, и классы называть, соответственно, кластерами или таксонами.

**Типология задач классификации**  
_Типы входных данных_
* Признаковое описание — наиболее распространённый случай. Каждый объект описывается набором своих характеристик, называемых признаками. Признаки могут быть числовыми или нечисловыми.  
* Матрица расстояний между объектами. Каждый объект описывается расстояниями до всех остальных объектов обучающей выборки. С этим типом входных данных работают немногие методы, в частности, метод ближайших соседей, метод парзеновского окна, метод потенциальных функций.  
* Временной ряд или сигнал представляет собой последовательность измерений во времени. Каждое измерение может представляться числом, вектором, а в общем случае — признаковым описанием исследуемого объекта в данный момент времени.  
* Изображение или видеоряд.  
* Встречаются и более сложные случаи, когда входные данные представляются в виде графов, текстов, результатов запросов к базе данных, и т. д. Как правило, они приводятся к первому или второму случаю путём предварительной обработки данных и извлечения признаков.  
Классификацию сигналов и изображений называют также распознаванием образов.

_Типы классов_
* Двухклассовая классификация. Наиболее простой в техническом отношении случай, который служит основой для решения более сложных задач.  
* Многоклассовая классификация. Когда число классов достигает многих тысяч (например, при распознавании иероглифов или слитной речи), задача классификации становится существенно более трудной.  
* Непересекающиеся классы.  
* Пересекающиеся классы. Объект может относиться одновременно к нескольким классам.  
* Нечёткие классы. Требуется определять степень принадлежности объекта каждому из классов, обычно это действительное число от 0 до 1.  

### Что такое кластеризация?

### Что такое понижение размерности?

## Алгоритмы машинного обучения

### Линейная регрессия

Алгоритм для задачи регрессии. Он предсказывает вещественное число, позволяет описывать линейную или биномиальную зависимость.  
Обучение происходит с помощью минимизации функции потерь, может быть две функции потерь.

Средняя квадратичная ошибка:  

<img src="https://render.githubusercontent.com/render/math?math=MSE = \Sigma_{i=1}^{n}(y_i - y_i^p)^2">

Средняя абсолютная ошибка:  

<img src="https://render.githubusercontent.com/render/math?math=MAE = \Sigma_{i=1}^{n} \left| y_i - y_i^p \right |">

Обучение происходит с помощью градиентного спуска, также возможно аналитическое решение этой задачи с помощью нахождения обратной матрицы. Но в реальноси оно не применятся, так как требует значительных вычислительных ресурсов, а также не для всех матриц можно найти обратную.

### Логистическая регрессия

Это алгоритм для задачи классификации. Отличается от линейной регресси тем, что тут есть функция активации. 

Для задач бинарной классификации используется сигмоида.  
Для задач многоклассовой классификации используется функция Softmax:  

<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ab3ef6ba51afd36c1d2baf06540022053b2dca73">

Функции потерь тоэе отличаются:  
Для задач бинарной классификации - это LogLoss:  

<img src="https://alexanderdyakonov.files.wordpress.com/2018/03/log_loss_23.png">  

Для задач многоклассовой классификации - это categorical cross entropy

## Обучение с помощью градиентного спуска

Сначала инициализируются веса модели. 

## Алгоритмы кластеризации такие как k-means и c-means, dbscan

## Иерархическая кластеризация

## Алгоритмы понижения размерности такие как PCA, t-SNE

## Алгоритмы для нейронных сетей

## Полносвязная нейронная сеть

## Свёрточная нейронная сеть

## Рекуррентная нейронная сеть

## Для каких задач подходит тот или иной алгоритм?

### Что такое градиент и для чего он нужен?

### Что такое функция активации?

<br/>

# Сеть

**Что происходит в тот момент, когда вы вводите в адресной строке браузера URL сайта и нажимаете ввод?**

**http** 

# Источники

* [Документация python](https://docs.python.org/3/library/)
* ["Как устроен Python. Гид для разработчиков, программистов и интересующихся" Мэтт Харрисон](https://t.me/pythonbooks/389)  
* [Магические методы Rafe Kettler](https://rszalski.github.io/magicmethods/)  
* [Техническая документация по SQL Server](https://docs.microsoft.com/ru-ru/sql/sql-server/?view=sql-server-ver15)  
* [SQL и NoSQL: разбираемся в основных моделях баз данных](https://tproger.ru/translations/sql-nosql-database-models/)  
* [Основные команды SQL, которые должен знать каждый программист](https://tproger.ru/translations/sql-recap/)  
* [Профессиональный информационно-аналитический ресурс, посвященный машинному обучению, распознаванию образов и интеллектуальному анализу данных](https://www.machinelearning.ru/)
* [Inside the Python GIL](http://www.dabeaz.com/python/GIL.pdf)
