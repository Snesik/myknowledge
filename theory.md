# Разделы:

1. [Общие вопросы по python](#general-python-questions)
   * [Разница 2 и 3 версии python](#Difference-2-and-3-python-version)  
   * [ООП](#oop)  
      - [SOLID](#SOLID)  
      - [Что такое классы?](#classes)  
      - [Что такое магические методы?](#magic-methods)  
      - [Что такое миксин?](#mixin) 
   * [Типы и структуры данных в python](#Types-and-data-structures-in-python)  
      - [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
      - [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
      - [Что может быть в качестве ключа словаря?](#dictionary-key)  
      - [Что такое хеш-функция?](#python-hash)  
      - [В чём особенность словаря в python?](#dictionary-in-python)  
      - [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets) 
   * [GIL](#GIL) 
      - [Что такое GIL?](#what-is-GIL)  
      - [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
      - [Разница между потоками и процессами](#difference-between-threads-and-processes)  
      - [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
      - [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  
   * [GC](#GC)  
   * [Декораторы](#Decorators)  
   * [Итераторы и генераторы](#Iterators-and-generators)  
   * [Алгоритмы](#Algorithms)  
   * [Хранение данных](#Data-storage)  
3. [Базы данных](#Database)
4. [Статистика](#statistics)
5. [Задачи и алгоритмы машинного обучения](#Machine-learning-tasks-and-algorithms)
6. [Сеть](#network)
7. [Big Data](#Big-Data)
8. [Источники](#sources)
<br/>

<a id="data-marts"></a>
# Общие вопросы по python
<a id="general-python-questions"></a>
  * [Разница 2 и 3 версии python](#Difference-2-and-3-python-version)  
  * [ООП](#oop)  
  * [Типы и структуры данных в python](#Types-and-data-structures-in-python)  
  * [GIL](#GIL)  
  * [GC](#GC)  
  * [Декораторы](#Decorators)  
  * [Итераторы и генераторы](#Algorithms)  
  * [Алгоритмы](#Algorithms)  
  * [Хранение данных](#Data-storage)  

## Разница 2 и 3 версии python
<a id="Difference-2-and-3-python-version"></a>

В Python 2 print был оператором: ```print "Hello, world"```  
В Python 3 print - функция: ```print ("Hello, world")```

В Python 2 были две функции: range - возвращает список; xrange - возвращает итератор  
В Python 3 есть только функция range, и она возвращает итератор

В Python 2 при делении целых чисел возвращает целоче число  
В Python 3 при делении целых чисел возвращает вещественное число

**Магические методы**

* Так как в Питоне 3 различий между строкой и юникодом больше нет, ``` __unicode__```  исчез, а появился ``` __bytes__```  (который ведёт себя так же как ``` __str__```  и ``` __unicode__```  в 2.7) для новых встроенных функций построения байтовых массивов.  
* Так как деление в Питоне 3 теперь по-умолчанию «правильное деление», ``` __div__```  больше нет.  
* ``` __coerce__```  больше нет, из-за избыточности и странного поведения.  
* ``` __cmp__```  больше нет, из-за избыточности.  
* ``` __nonzero__```  было переименовано в ``` __bool__``` .  
* ``` next```  у итераторов был переименован в ``` __next__``` .

## ООП
<a id="oop"></a>
* [SOLID](#SOLID)  
* [Что такое классы?](#classes)  
* [Магические методы](#magic-methods)  
* [Что такое миксин?](#mixin)  

### SOLID
<a id="SOLID"></a>

S - Принцип единственной ответственности (single responsibility principle)
Для каждого класса должно быть определено единственное назначение. Не должно возникать God object, который занимается всем в программе. 

O - Принцип открытости/закрытости (open–closed principle)
«программные сущности … должны быть открыты для расширения, но закрыты для модификации». Мы должны иметь возможность добавлять функциональность. 

L - Принцип подстановки Барбары Лисков (Liskov substitution principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения 
правильности выполнения программы». У объекта есть тип, но сами классы выстраиваются в иерархию классов. Подтип типа всю старую функциональность должен выполнять. 

I - Принцип разделения интерфейса (interface segregation principle)
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс 
общего назначения». Интерфейс - способ провзаимодействовать с какой-то программной действующей функцией. 

D - Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». 

### Что такое классы?
<a id="classes"></a>

Класс — тип, описывающий устройство объектов. Объект — это экземпляр класса.
```
class C: 
  pass
имя_объекта = имя_класса()
```
У класса может не быть тела. 

Простейший пример класса:
```
class Rectangle:
  default_color = "green" # статический атрибут
  def __init__(self, width, height): # конструктор класса
    self.width = width # динамический атрибут
    self.height = height # динамический атрибут
```
В python нет возможности сделать несколько конструкторов. 

### Магические методы
<a id="magic-methods"></a>

Если какой-то идентификатор начинается с двух подчёркиваний, дальше пишется что-либо, потом снова два подчёркивания, то это спец метод. 

**Какие магические методы и для чего используются?**
```
class FileObject:
  def __init__(self, filepath='~', filename='sample.txt'): # Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.
    self.file = open(join(filepath, filename), 'r+') # Открыть файл filename в filepath в режиме чтения и записи
  def __del__(self):
    self.file.close()
    del self.file
``` 
Метод, который будет вызван при инициализации объекта.  
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в ``` __init__``` . ``` __new__```  используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка.
``` 
__new__(cls, [...])
``` 
Инициализатор класса. Самый базовый магический метод, ``` __init__``` . С его помощью мы можем инициализировать объект.
``` 
__init__(self, [...]) 
``` 
Деструктор объекта
``` 
__del__
``` 

Самый базовый из методов сравнения ``` __cmp__(self, other)``` . Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). ``` __cmp__```  должен вернуть отрицательное число, если ``` self < other``` , ноль, если ``` self == other``` , и положительное число в случае ``` self > other``` . Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в ``` __cmp__``` . Но ``` __cmp__```  может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперируют одним критерием.

* ``` __eq__(self, other)``` 
Определяет поведение оператора равенства, ==.

* ``` __ne__(self, other)``` 
Определяет поведение оператора неравенства, !=.

* ``` __lt__(self, other)``` 
Определяет поведение оператора меньше, <.

* ``` __gt__(self, other)``` 
Определяет поведение оператора больше, >.

* ``` __le__(self, other)``` 
Определяет поведение оператора меньше или равно, <=.

* ``` __ge__(self, other)``` 
Определяет поведение оператора больше или равно, >=.

**Унарные операторы и функции**

Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.

* ``` __pos__(self)``` 
Определяет поведение для унарного плюса ```(+some_object)```

* ``` __neg__(self)``` 
Определяет поведение для отрицания```(-some_object)```

* ``` __abs__(self)``` 
Определяет поведение для встроенной функции ```abs()```.

* ``` __invert__(self)``` 
Определяет поведение для инвертирования оператором ~. Для объяснения что он делает смотри статью в Википедии о бинарных операторах.

* ``` __round__(self, n)``` 
Определяет поведение для встроенной функции ```round()```. n это число знаков после запятой, до которого округлить.

* ``` __floor__(self)``` 
Определяет поведение для ```math.floor()```, то есть, округления до ближайшего меньшего целого.

* ``` __ceil__(self)``` 
Определяет поведение для ```math.ceil()```, то есть, округления до ближайшего большего целого.

* ``` __trunc__(self)``` 
Определяет поведение для ```math.trunc()```, то есть, обрезания до целого.

**Обычные арифметические операторы**

* ```__add__(self, other)```
Сложение.

* ```__sub__(self, other)```
Вычитание.

* ```__mul__(self, other)```
Умножение.

* ```__floordiv__(self, other)```
Целочисленное деление, оператор //.

* ```__div__(self, other)```
Деление, оператор /.

* ```__truediv__(self, other)```
Правильное деление. Заметьте, что это работает только когда используется ```from __future__ import division```.

* ```__mod__(self, other)```
Остаток от деления, оператор %.

* ```__divmod__(self, other)```
Определяет поведение для встроенной функции divmod().

* ```__pow__```
Возведение в степень, оператор **.

* ```__lshift__(self, other)```
Двоичный сдвиг влево, оператор <<.

* ```__rshift__(self, other)```
Двоичный сдвиг вправо, оператор >>.

* ```__and__(self, other)```
Двоичное И, оператор &.

* ```__or__(self, other)```
Двоичное ИЛИ, оператор |.

* ```__xor__(self, other)```
Двоичный xor, оператор ^.

**Магические методы преобразования типов**

В Питоне множество магических методов, предназначенных для определения поведения для встроенных функций преобразования типов.

* ```__int__(self)```
Преобразование типа в int.

* ```__long__(self)```
Преобразование типа в long.

* ```__float__(self)```
Преобразование типа в float.

* ```__complex__(self)```
Преобразование типа в комплексное число.

* ```__oct__(self)```
Преобразование типа в восьмеричное число.

* ```__hex__(self)```
Преобразование типа в шестнадцатеричное число.

* ```__index__(self)```
Преобразование типа к int, когда объект используется в срезах (выражения вида ```[start:stop:step]```). Если вы определяете свой числовой тип, который может использоваться как индекс списка, вы должны определить ```__index__```.

* ```__trunc__(self)```
Вызывается при ```math.trunc(self)```. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

* ```__coerce__(self, other)```
Метод для реализации арифметики с операндами разных типов. ```__coerce__``` должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.

**Представление своих классов**

Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.

* ```__str__(self)```
Определяет поведение функции ```str()```, вызванной для экземпляра вашего класса.

* ```__repr__(self)```
Определяет поведение функции ```repr()```, вызванной для экземпляра вашего класса. Главное отличие от ```str()``` в целевой аудитории. ```repr()``` больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне), а ```str()``` предназначен для чтения людьми.

* ```__unicode__(self)```
Определяет поведение функции ```unicode()```, вызванной для экземпляра вашего класса. ```unicode()``` похож на ```str()```, но возвращает строку в юникоде. Если клиент вызывает ```str()``` на экземпляре вашего класса, а вы определили только ```__unicode__()```, то это не будет работать. Постарайтесь всегда определять ```__str__()``` для случая, когда кто-то не имеет такой роскоши как юникод.

* ```__format__(self, formatstr)```
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, ```"Hello, {0:abc}!".format(a)``` приведёт к вызову ``` a.__format__("abc")```. Это может быть полезно для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.

* ```__hash__(self)```
Определяет поведение функции ```hash()```, вызванной для экземпляра вашего класса. Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно нужно определять и ```__eq__``` тоже. Руководствуйтесь следующим правилом: ```a == b``` подразумевает ```hash(a) == hash(b)```.

* ```__nonzero__(self)```
Определяет поведение функции ```bool()```, вызванной для экземпляра вашего класса. Должна вернуть ```True``` или ```False```, в зависимости от того, когда вы считаете экземпляр соответствующим ```True``` или ```False```.

* ```__dir__(self)```
Определяет поведение функции ```dir()```, вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю список атрибутов. Обычно, определение ```__dir__``` не требуется, но может быть жизненно важно для интерактивного использования вашего класса, если вы переопределили ```__getattr__``` или ```__getattribute__```.

* ```__sizeof__(self)```
Определяет поведение функции``` sys.getsizeof()```, вызванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах.

**Магия контейнеров**

Магические методы, используемые контейнерами.

* ```__len__(self)```
Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.

* ```__getitem__(self, key)```
Определяет поведение при доступе к элементу, используя синтаксис ```self[key]```. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: TypeError если неправильный тип ключа и KeyError если ключу не соответствует никакого значения.

* ```__setitem__(self, key, value)```
Определяет поведение при присваивании значения элементу, используя синтаксис ```self[nkey] = value```. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать KeyError и TypeError в соответствующих случаях.

* ```__delitem__(self, key)```
Определяет поведение при удалении элемента (то есть ```del self[key]```). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.

* ```__iter__(self)```
Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции ```iter()``` и в случае перебора элементов контейнера выражением ```for x in container:```. Итераторы сами по себе объекты и они тоже должны определять метод ```__iter__```, который возвращает ```self```.

* ```__reversed__(self)```
Вызывается чтобы определить поведения для встроенной функции ```reversed()```. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.

* ```__contains__(self, item)```
```__contains__``` предназначен для проверки принадлежности элемента с помощью in и not in. Вы спросите, почему же это не часть протокола последовательности? Потому что когда ```__contains__``` не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает True если находит нужный.

* ```__missing__(self, key)```
```__missing__``` используется при наследовании от ```dict```. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь ```d``` и я пишу ```d["george"]``` когда "george" не является ключом в словаре, вызывается ```d.__missing__("george"))```.

**Построение дескрипторов**

Дескрипторы — это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).

Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из ```__get__```, ```__set__``` или ```__delete__```. 

* ```__get__(self, instance, instance_class)```
Определяет поведение при возвращении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. owner это тип (класс) объекта.

* ```__set__(self, instance, value)```
Определяет поведение при изменении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. value это значение для установки в дескриптор.

* ```__delete__(self, instance)```
Определяет поведение для удаления значения из дескриптора. ```instance``` это объект, владеющий дескриптором.

**Как вызывать магические методы** 

| **Магический метод**                  |	**Когда он вызывается (пример)**        |	**Объяснение**                                       |
|:--------------------------------------|:----------------------------------------|:-----------------------------------------------------| 
| ```__new__(cls [,...])```             |	```instance = MyClass(arg1, arg2)```    |	```__new__``` вызывается при создании экземпляра     |
| ```__init__(self [,...])```           |	```instance = MyClass(arg1, arg2)```    |	```__init__``` вызывается при создании экземпляра    |
| ```__cmp__(self, other)```            |	```self == other, self > other, etc.```	| Вызывается для любого сравнения                      |
| ```__pos__(self)```                   |	```+self```                            	| Унарный знак плюса                                   |
| ```__neg__(self)```                   |	```-self```	                            | Унарный знак минуса                                  |
| ```__invert__(self)```                |	```~self```	                            | Побитовая инверсия                                   |
| ```__index__(self)```                 |	```x[self]```	                          | Преобразование, когда объект используется как индекс |
| ```__nonzero__(self)```               |	```bool(self), if self:```             	| Булевое значение объекта                             |
| ```__getattr__(self, name)```         |	```self.name # name не определено```	  | Пытаются получить несуществующий атрибут             |
| ```__setattr__(self, name, val)```    |	```self.name = val```	                  | Присвоение любому атрибуту                           |
| ```__delattr__(self, name)```         |	```del self.name```	                    | Удаление атрибута                                    |
| ```__getattribute__(self, name)```    |	```self.name```	                        | Получить любой атрибут                               |
| ```__getitem__(self, key)```          |	```self[key]```	                        | Получение элемента через индекс                      |
| ```__setitem__(self, key, val)```     |	```self[key] = val```                  	| Присвоение элементу через индекс                     |
| ```__delitem__(self, key)```          |	```del self[key]```	                    | Удаление элемента через индекс                       |
| ```__iter__(self)```                  |	```for x in self```	                    | Итерация                                             |
| ```__contains__(self, value)```       |	```value in self, value not in self```	| Проверка принадлежности с помощью in                 |
| ```__call__(self [,...])```           |	```self(args)```	                      | «Вызов» экземпляра                                   |
| ```__enter__(self)```                 |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__exit__(self, exc, val, trace)``` |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__getstate__(self)```              |	```pickle.dump(pkl_file, self)```	      | Сериализация                                         |
| ```__setstate__(self)```              |	```data = pickle.load(pkl_file)```	    | Сериализация                                         |

### Что такое миксин?
<a id="mixin"></a>

Это класс, который реализует несколько методов, которые ты добавляешь к разным классам для того, чтобы они унаследовали и тоже получили какие-то методы. 

## Типы и структуры данных в python
<a id="Types-and-data-structures-in-python"></a>

* [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
* [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
* [Что может быть в качестве ключа словаря?](#dictionary-key)  
* [Что такое хеш-функция?](#python-hash)  
* [В чём особенность словаря в python?](#dictionary-in-python)  
* [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets)  

### Какие типы и структуры данных бывают в python?
<a id="Types-and-data-structures"></a>

| *Объект*                          | *Тип*                      | 
|:---------------------------------:|:--------------------------:| 
| Строка                            | str                        |
| Целое число                       | int                        |
| Число с плавающей точкой          | float                      |
| Список                            | list                       |
| Кортеж                            | tuple                      |
| Словарь                           | dict                       |
| Множество                         | set                        |
| Логический                        | bool                       |
| Функция                           | function                   |
| Класс, определяемый пользователем | type                       |
| Экземпляр класса                  | class                      |
| Встроенная функция                | builtin_function_or_method |
| type                              | type                       |

### Что такое мутабельные и иммутабельные типы данных?
<a id="mutable-and-immutable-data-types"></a>

Объекты в питоне бывают двух значительно отличающихся сортов: изменяемые (mutable) и неизменяемые (immutable). Неизменяемыми являются целые и действительные числа (int, float), строки (str), последовательности байтов (бинарные данные, bytes), а также кортежи, все элементы которых неизменяемы (tuple). Напротив, списки (list), словари (dict) и множества (set) являются изменяемыми.

### Что может быть в качестве ключа словаря?
<a id="dictionary-key"></a>

Только неизменяемые типы данных. Ключами словаря могут являться только объекты, поддерживающие хеширование. Таким образом, использовать в качестве ключей списки, словари и другие изменяемые типы не получится. Если в словарь будут добавлены несколько значений с одним и тем же ключом, словарь сохранит последнее.

Не рекомендуется использоваться в качестве ключей числа с плавающей запятой, так как они хранятся в памяти в виде приближений.

### Что такое хеш-функция?
<a id="python-hash"></a>

Хэш-функция - это функция, которая принимает на вход какие-либо данные (например, строки) и возвращает число по некоторому заданному алгоритму.  
Назначением хэш-функций является возможность помещения некоторого элемента (например, строки) в хэш-таблицу, на основе которых реализованы, например, словари и множества в Python. 

Одинаковые данные будут иметь одинаковое хеш-значение.  
* Даже небольшое изменение исходных данных может привести к совершенно иному хеш-значению.  
* Хеш получается из хеш-функции, в обязанности которой входит преобразование данной информации в закодированный хеш.   
* Очевидно, что количество объектов может быть намного больше, чем количество хеш-значений, и поэтому два объекта могут хешировать одно и то же. Это называется конфликтом хэша. Это означает, что если два объекта имеют одинаковый хэш-код, они не обязательно имеют одно и то же значение.  

Cрок жизни хэша зависит только от области действия программы, и он может измениться, как только программа завершится.

### В чём особенность словаря в python?
<a id="dictionary-in-python"></a>

Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.  

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами:  

* Во-первых, с помощью литерала:
  ```
  d = {}
  print(d)
  {}
  d = {'dict': 1, 'dictionary': 2}
  prtin(d)
  {'dict': 1, 'dictionary': 2}
  ```
  
* Во-вторых, с помощью функции dict:
```
  d = dict(short='dict', long='dictionary')
  prtin(d)
  {'short': 'dict', 'long': 'dictionary'}
  d = dict([(1, 1), (2, 4)])
  prtin(d)
  {1: 1, 2: 4}
```

* В-третьих, с помощью метода fromkeys:
```
  d = dict.fromkeys(['a', 'b'])
  prtin(d)
  {'a': None, 'b': None}
  d = dict.fromkeys(['a', 'b'], 100)
  prtin(d)
  {'a': 100, 'b': 100}
```

* В-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.
```
  d = {a: a ** 2 for a in range(7)}
  prtin(d)
  {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

**Методы словарей**  

* ```dict.clear()``` - очищает словарь.
* ```dict.copy()``` - возвращает копию словаря.
* ```classmethod dict.fromkeys(seq[, value])``` - создает словарь с ключами из ```seq``` и значением ```value``` (по умолчанию ```None```).
* ```dict.get(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает ```default``` (по умолчанию ```None```).
* ```dict.items()``` - возвращает пары (ключ, значение).
* ```dict.keys()``` - возвращает ключи в словаре.
* ```dict.pop(key[, default])``` - удаляет ключ и возвращает значение. Если ключа нет, возвращает ```default``` (по умолчанию бросает исключение).
* ```dict.popitem()``` - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение ```KeyError```. Важно помнить, что словари неупорядочены.
* ```dict.setdefault(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением ```default``` (по умолчанию ```None```).
* ```dict.update([other])``` - обновляет словарь, добавляя пары (ключ, значение) из ```other```. Существующие ключи перезаписываются. Возвращает ```None``` (не новый словарь!).
* ```dict.values()``` - возвращает значения в словаре.

### Списки, кортежи и множества в чём их отличие?
<a id="lists-tuples-and-sets"></a>

_List (список)_
Базовая структура данных в python. Элементы в списке хранятся последовательно, каждому из них присвоены индексы, начиная с нуля. В отличие от массива, список может хранить объекты любого типа.

Создание списка
```
my_list = [] # Создание пустого списка с помощью литерала списка
my_list = list() # Создание пустого списка с помощью встроенной функции

my_list = [1,2,['a','b'],4,5] # Инициализация списка

my_list = list('hello world') # Создание списка из итерируемого объекта
print(my_list)
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

my_list = [x for x in range(10)] # Генератор списков в действии
print(my_list)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
Доступные методы
* ```my_list.append(x)``` - добавляет x в конец списка
* ```my_list.clear()``` - очищает 
* ```my_list.copy()``` - возвращает копию списка ```my_list```
* ```my_list.count(x)``` - возвращает кол-во элементов со значением x
* ```my_list.extend(x)``` - добавляет элементы списка x к концу списка ```my_list```
* ```my_list.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)
* ```my_list.insert(index, x)``` - вставляет x на заданную позицию
* ```my_list.pop(index)``` - возвращает элемент с указанным индексом и удаляет его, если индекс не указан - возвращается и удаляется последний элемент
* ```my_list.remove(x)``` - удаляет первый элемент со значением x
* ```my_list.reverse()``` - инвертирует порядок элементов в списке
* ```my_list.sort(key=x)``` сортирует список на основе функции x  

В каких случаях использовать?
Для хранения элементов, объединенных каким либо признаком. В случае, если изменение элементов и/или расширение списка не предполагается, следует использовать неизменяемый аналог - кортеж.

_Tuple (кортёж)_
Кортеж - это неизменяемый и более быстрый аналог списка. Он защищает хранимые данные от непреднамеренных изменений и может использоваться в качестве ключа в словарях (словарь - ассоциативный массив в python).

Создание кортежа.
```
my_tuple = () # Создание кортежа с помощью литерала
my_tuple = tuple() # Создание кортежа с помощью встроенной функции

my_tuple = (1,2,['a','b'],4,5) # Инициализация кортежа

my_tuple = tuple('hello world') # Создание кортежа из итерируемого объекта
print(my_tuple)
('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')

my_tuple = tuple(2**x for x in [0, 1, 2, 3]) # Генератор кортежей
print(my_tuple)
(1, 2, 4, 8)
```
Доступные методы
* ```my_tuple.count(x)``` - возвращает кол-во элементов со значением x
* ```my_tuple.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)  

В каких случаях использовать?
Для хранения данных вместо списка (если они не предполагают изменений).

_Set (множество)_
Множество - это набор уникальных элементов в случайном порядке (неупорядоченный список). Множества примечательны тем, что операция проверки "принадлежит ли объект множеству" происходит значительно быстрее аналогичных операций в других структурах данных.

Создание множества
```
my_something = {} # !!! Попытка создать множество при помощи литерала даст нам словарь
type(my_something)
<class 'dict'> 

my_set = set() # Создание при помощи встроенной функции

my_set = {1,2,3,4,5} # Инициализация множества

my_set = set('hello world') # Создания множества из итерируемого объекта
print(my_set)
{'r', 'o', 'e', 'h', 'd', 'w', 'l', ' '}

my_set = {x for x in range(10)} # Генератор множеств
print(my_set)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```
Доступные методы
* ```my_set.add(x)``` - добавляет x во множество
* ```my_set.difference(x)``` - возвращает множество элементов ```my_set```, которые не входят во множество ```x```
* ```my_set.difference_update(x)``` - удаляет из множества my_set все элементы, которые входят во множество ```x```
* ```my_set.discard(x)``` - удаляет элемент ```x``` из ```my_set```
* ```my_set.intersection(x)``` - возвращает элементы общие для множеств ```my_set``` и ```x```
* ```my_set.intersection_update(x)``` - удаляет из множества ```my_set``` элементы, которых нет во множестве ```x```
* ```my_set.isdisjoint(x)``` - возвращает ```true``` если ```my_set``` и ```x``` не содержат одинаковых значений
* ```my_set.issubset(x)``` - возвращает true если все элементы ```my_set``` входят во множество ```x```
* ```my_set.issuperset(x)``` - возвращает ```true``` если все элементы x входят во множество ```my_set```
* ```my_set.pop()``` - возвращает и удаляет первый (на данный момент) элемент множества
* ```my_set.remove(x)``` - удаляет ```x``` из множества
* ```my_set.symmetric_difference(x)``` - возвращает все элементы из ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.symmetric_difference_update(x)``` - обновляет исходное множество таким образом, что оно будет состоять из всех элементов ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.union(x)``` - возвращает новое множество, состоящее из всех элементов ```x``` и ```my_set```
* ```my_set.update(x)``` - добавляет в ```my_set``` все элементы ```x``` 

В каких случаях использовать?
Когда необходимо проверять принадлежит ли значение набору уникальных элементов и отсутствует необходимость поддерживать порядок в данном наборе.

## GIL
<a id="GIL"></a>

* [Что такое GIL?](#what-is-GIL)  
* [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
* [Разница между потоками и процессами](#difference-between-threads-and-processes)  
* [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
* [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  

### Что такое GIL?
<a id="what-is-GIL"></a>

В Python используется глобальная блокировка интерпретатора (Global Interpreter Lock — GIL), накладывающая некоторые ограничения на потоки. А именно, нельзя использовать несколько процессоров одновременно. Блокировка, позволяет только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток. Из этого следует, что с потоками невозможно использовать несколько ядер процессора.

GIL был введен в Python потому, что управление памятью CPython не является потокобезопасным. Имея такую блокировку Python может быть уверен, что никогда не будет условий гонки. (об условиях гонки в следующем разделе)

Во многопоточных программах отсутствие GIL может негативно сказываться на производительности процессоро-зависымых программ.

![image](https://user-images.githubusercontent.com/54559853/127723378-17c5daa9-46c0-4a24-b493-de66914bd3b1.png)  

Python подсчитывает количество ссылок для корректного управления памятью. Это означает, что созданные в Python объекты имеют переменную подсчёта ссылок, в которой хранится количество всех ссылок на этот объект. Как только эта переменная становится равной нулю, память, выделенная под этот объект, освобождается.

### Многопоточные и многопроцессорные программы в python
<a id="multithreaded-and-multiprocessing-programs-in-python"></a>

Параллелизм дает возможность работать над несколькими вычислениями одновременно в одной программе. Такого поведения в Python можно добиться несколькими способами:  
* Используя многопоточность ```threading```, позволяя нескольким потокам работать по очереди.  
* Используя несколько ядер процессора ```multiprocessing```. Делать сразу несколько вычислений, используя несколько ядер процессора. Это и называется параллелизмом.  
* Используя асинхронный ввод-вывод с модулем ```asyncio```. Запуская какую то задачу, продолжать делать другие вычисления, вместо ожидания ответа от сетевого подключения или от операций чтения/записи.  

### Разница между потоками и процессами
<a id="difference-between-threads-and-processes"></a>

Поток ```threading``` - это независимая последовательность выполнения каких то вычислений. Поток ```thread``` делит выделенную память ядру процессора, а так же его процессорное время со всеми другими потоками, которые создаются программой в рамках одного ядра процессора. Программы на языке Python имеют, по умолчанию, один основной поток. Можно создать их больше и позволить Python переключаться между ними. Это переключение происходит очень быстро и кажется, что они работают параллельно.

Понятие процесс в ```multiprocessing``` - представляет собой так же независимую последовательность выполнения вычислений. В отличие от потоков threading, процесс имеет собственное ядро и следовательно выделенную ему память, которое не используется совместно с другими процессами. Процесс может клонировать себя, создавая два или более экземпляра в одном ядре процессора.

Асинхронный ввод-вывод не является ни потоковым (```threading```), ни многопроцессорным (```multiprocessing```). По сути, это однопоточная, однопроцессная парадигма и не относится к параллельным вычислениям.

### Что такое условия гонки и потокобезопасность?
<a id="what-are-race-conditions-and-thread-safety"></a>

* Состояние гонки возникает, когда несколько потоков могут одновременно получать доступ к общей структуре данных или местоположению в памяти и изменять их, в следствии чего могут произойти непредсказуемые вещи.
  
  Если два пользователя одновременно редактируют один и тот же документ онлайн и второй пользователь сохранит данные в базу, то перезапишет работу первого пользователя. Чтобы избежать условий гонки, необходимо заставить второго пользователя ждать, пока первый закончит работу с документом и только после этого разрешить второму пользователю открыть и начать редактировать документ.

* Потокобезопасность работает путем создания копии локального хранилища в каждом потоке, чтобы данные не сталкивались с другим потоком.

### Алгоритм планирования доступа потоков к общим данным
<a id="algorithm-for-scheduling-access-of-streams-to-shared-data"></a>

Потоки используют одну и ту же выделенную память. Когда несколько потоков работают одновременно, то нельзя угадать порядок, в котором потоки будут обращаются к общим данным. Результат доступа к совместно используемым данным зависит от алгоритма планирования. который решает, какой поток и когда запускать. Если такого алгоритма нет, то конечные данные могут быть не такими как ожидаешь.

## GC
<a id="GC"></a>

* [Как в питоне обстоят дела с памятью (управлением памятью)](#Types-and-data-structures)  
* [Сколько стоит проверка элемента в нотации?](#mutable-and-immutable-data-types)  
* [Если есть два объекта и они указывают друг на друга](#dictionary-key)  

### Как в питоне обстоят дела с памятью (управлением памятью)

### Сколько стоит проверка элемента в нотации?

### Если есть два объекта и они указывают друг на друга

## Декораторы
<a id="Decorators"></a>

**Что такое декораторы?**

**Какие декораторы стандартной библиотеки вы знаете?**

## Итераторы и генераторы
<a id="Iterators-and-generators"></a>

**Что такое итератор?**

**Что такое генератор?**

**Что такое list comprehension, какой синтаксис создания генераторов?**

**Является ли range итератором?**

## Алгоритмы
<a id="Algorithms"></a>

## Хранение данных
<a id="Data-storage"></a>

**Что такое json?**

**Что такое csv?**

**Что такое XML?**

<br/>

# Базы данных
<a id="Database"></a>

## Что такое СУБД?

Чтобы правильно обрабатывать различные запросы (поиск, изменение, удаление и т.д) в базу данных, нужно специальное программное обеспечение, такое ПО получило название системы управления базами данных (СУБД).

СУБД — это общий термин, относящийся ко всем видам абсолютно разных инструментов, от компьютерных программ до встроенных библиотек. Эти приложения управляют или помогают управлять наборами данных. Так как эти данные могут быть разного формата и размера, были созданы разные виды СУБД.

СУБД основаны на моделях баз данных — определённых структурах для обработки данных. Каждая СУБД создана для работы с одной из них с учётом особенностей операций над информацией.

Хотя решений, реализующих различные модели баз данных, очень много, периодически некоторые из них становятся очень популярными и используются на протяжении многих лет. Сейчас самой популярной моделью является реляционная система управления базами данных (РСУБД).

## Какие типы СУБД в соответствии с моделями данных вы знаете?

* Реляционные, которые поддерживают установку связей между таблицами с помощью первичных и внешних ключей. Пример — MySQL.
* Flat File — базы данных с двумерными файлами, в которых содержатся записи одного типа и отсутствует связь с другими файлами, как в реляционных. Пример — Excel.
* Иерархические подразумевают наличие записей, связанных друг с другом по принципу отношений один-к-одному или один-ко-многим. А вот для отношений многие-ко-многим следует использовать реляционную модель. Пример — Adabas.
* Сетевые похожи на иерархические, но в этом случае «ребёнок» может иметь несколько «родителей» и наоборот. Примеры — IDS и IDMS.
* Объектно-ориентированные СУБД работают с базами данных, которые состоят из объектов, используемых в ООП. Объекты группируются в классы и называются экземплярами, а классы в свою очередь взаимодействуют через методы. Пример — Versant.
* Объектно-реляционные обладают преимуществами реляционной и объектно-ориентированной моделей. Пример — IBM Db2.
* Многомерная модель является разновидностью реляционной и использует многомерные структуры. Часто представляется в виде кубов данных. Пример — Oracle Essbase.
* Гибридные состоят из двух и более типов баз данных. Используются в том случае, если одного типа недостаточно для обработки всех запросов. Пример — Altibase HDВ.

## Что такое первичный ключ?

Первичный ключ или ```PRIMARY KEY``` предназначен для однозначной идентификации каждой записи в таблице и является строго уникальным (```UNIQUE```): две записи таблицы не могут иметь одинаковые значения первичного ключа. Нулевые значения (```NULL```) в ```PRIMARY KEY``` не допускаются. Если в качестве ```PRIMARY KEY``` используется несколько полей, их называют составным ключом.  
Первичный ключ, используется в качестве основного ключа и может быть использован для связи с дочерней таблицей, содержащей внешний ключ.

Пример:
```
CREATE TABLE USERS (
  id INT NOT NULL,
  name VARCHAR (20) NOT NULL,
  PRIMARY KEY (id)
);
```
Здесь в качестве первичного ключа используется поле id.

## Что такое внешний ключ?

Внешний ключ или ```FOREIGN KEY``` также является атрибутом ограничения и обеспечивает связь двух таблиц. По сути, это поле или несколько полей, которые ссылаются на ```PRIMARY KEY``` в родительской таблице.

Пример использования:
```
CREATE TABLE order (
  order_id INT NOT NULL,
  user_id INT,
  PRIMARY KEY (order_id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```
В данном случае внешний ключ, привязанный к полю ```user_id``` в таблице ```order```, ссылается на первичный ключ ```id``` в таблице ```users```, и именно по этим полям происходит связывание двух таблиц.

## Ограничения в SQL

SQL-ограничения (constraints) указываются при создании или изменении таблицы. Это правила для ограничения типа данных, которые могут храниться в таблице. Действие с данными не будет выполнено, если нарушаются установленные ограничения.

* ```UNIQUE``` — гарантирует уникальность значений в столбце;
* ```NOT NULL``` — значение не может быть ```NULL```;
* ```INDEX``` — создаёт индексы в таблице для быстрого поиска/запросов;
* ```CHECK``` — значения столбца должны соответствовать заданным условиям;
* ```DEFAULT``` — предоставляет столбцу значения по умолчанию.

## Что такое Self JOIN?

Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные таблицы. Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.

Следующий SQL-запрос объединяет клиентов из одного города:
```
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City
ORDER BY A.City;
```
## Подстановочные знаки

Это специальные символы, которые нужны для замены каких-либо знаков в запросе. Они используются вместе с оператором ```LIKE```, с помощью которого можно отфильтровать запрашиваемые данные.

% — заменить ноль или более символов;
_ — заменить один символ.
Примеры:
```
SELECT * FROM user WHERE name LIKE '%test%';
```
Данный запрос позволяет найти данные всех пользователей, имена которых содержат в себе «test».
```
SELECT * FROM user WHERE name LIKE 't_est';
```
В этом случае имена искомых пользователей начинаются на «t», после содержат какой-либо символ и «est» в конце.

## Что делают псевдонимы Aliases?

SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу. Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами. В этом случае для удобства в составлении запроса используются псевдонимы. SQL-псевдоним существует только на время запроса.

Пример:
```
SELECT very_long_column_name AS alias_name
FROM table;
```
## Разница между командами DELETE и TRUNCATE

Команда ```DELETE``` — это DML-операция, которая удаляет записи из таблицы, соответствующие заданному условию:

```DELETE FROM table_name WHERE condition;```
При этом создаются логи удаления, то есть операцию можно отменить.

А вот команда ```TRUNCATE``` — это DDL-операция, которая полностью пересоздаёт таблицу, и отменить такое удаление невозможно:

```TRUNCATE TABLE table_name;```

DML (Data Manipulation Language) - язык манипулирования данными. Язык DML позволяет осуществлять манипуляции с данными таблиц, т.е. с ее строками. Он позволяет делать выборку данных из таблиц, добавлять новые данные в таблицы, а так же обновлять и удалять существующие данные.  

DDL (Data Definition Language) - язык описания данных. Язык DDL служит для создания и модификации структуры БД, т.е. для создания/изменения/удаления таблиц и связей.

## Основные команды SQL

* ```SHOW DATABASES```  

  SQL-команда, которая отвечает за просмотр доступных баз данных.
  
* ```CREATE DATABASE```  
  
  Команда для создания новой базы данных.
  
* ```USE```  

  С помощью этой SQL-команды ```USE <database_name>``` выбирается база данных, необходимая для дальнейшей работы с ней.
  
* ```SOURCE```  

  ```SOURCE <file.sql>``` позволит выполнить сразу несколько SQL-команд, содержащихся в файле с расширением .sql.
  
* ```DROP DATABASE```  
  
  Стандартная SQL-команда для удаления целой базы данных.
  
* ```DROP TABLE```  

  Так можно удалить всю таблицу целиком.  
  
* ```DELETE```  

  SQL-команда ```DELETE FROM <table_name>``` используется для удаления данных из таблицы.
  
* ```SHOW TABLES```  

  С помощью этой команды можно увидеть все таблицы, которые доступны в базе данных.
  
* ```DESCRIBE```  
  
  С помощью ```DESCRIBE <table_name>``` можно просмотреть различные сведения (тип значений, является ключом или нет) о столбцах таблицы.
  
* ```CREATE TABLE```
  SQL-команда для создания новой таблицы:
  ```
  CREATE TABLE <table_name1> (
    <col_name1><col_type1>,
    <col_name2><col_type2>,
    <col_name3><col_type3>
    PRIMARY KEY(<col_name1>),
    FOREIGN KEY(<col_name2>) REFERENCES <table_name2>(<col_name2>)
  );
  ```
  Ограничения целостности при использовании ```CREATE TABLE```  
  Может понадобиться создать ограничения для определённых столбцов в таблице. При создании таблицы можно задать следующие ограничения:

  * ячейка таблицы не может иметь значение ```NULL```;
  * первичный ключ — ```PRIMARY KEY(col_name1, col_name2, …)```;
  * внешний ключ — ```FOREIGN KEY(col_namex1, …, col_namexn) REFERENCES table_name(col_namex1, …, col_namexn)```.  
  
  Можно задать больше одного первичного ключа. В этом случае получится составной первичный ключ.

  Пример
  Создайте таблицу «instructor»:
```
  CREATE TABLE instructor (
    ID CHAR(5),
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    salary NUMERIC(8,2),
    PRIMARY KEY (ID),
    FOREIGN KEY (dept_name) REFERENCES department(dept_name)
  );
```

* UNION  

  Он используется для объединения полученных данных из двух или более запросов, которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в   том же порядке.  

  Пример использования:
  ```
  SELECT column(s) FROM first_table
  UNION
  SELECT column(s) FROM second_table;
  ```
  
* ```INSERT```  

  Команда ```INSERT INTO <table_name>``` в SQL отвечает за добавление данных в таблицу:
  ```
  INSERT INTO <table_name> (<col_name1>, <col_name2>, <col_name3>, …)
    VALUES (<value1>, <value2>, <value3>, …); 
  ```
  При добавлении данных в каждый столбец таблицы не требуется указывать названия столбцов.
  ```
  INSERT INTO <table_name>
    VALUES (<value1>, <value2>, <value3>, …);
  ```
  
* ```UPDATE```  

  SQL-команда для обновления данных таблицы:
  ```
  UPDATE <table_name>
    SET <col_name1> = <value1>, <col_name2> = <value2>, ...
    WHERE <condition>;
  ```
  
* ```SELECT```  
  
  ```SELECT``` используется для получения данных из выбранной таблицы:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>; 
  ```
  Следующей командой можно вывести все данные из таблицы:
  ```
  SELECT * FROM <table_name>;
  ```
  
* ```SELECT DISTINCT```
 
  В столбцах таблицы могут содержаться повторяющиеся данные. ```SELECT DISTINCT``` используется для получения только неповторяющихся данных.
  ```
  SELECT DISTINCT <col_name1>, <col_name2>, …
    FROM <table_name>; 
  ```

* ```WHERE```  
  
  Можно использовать ключевое слово ```WHERE``` в ```SELECT``` для указания условий в запросе:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <condition>; 
  ```
  В запросе можно задавать следующие условия:

  сравнение текста;
  сравнение численных значений;
  логические операции AND (и), OR (или) и NOT (отрицание).
  Пример:
  ```
  SELECT * FROM table WHERE author='Достоевский';
  SELECT * FROM table WHERE price>3000;
  SELECT * FROM table WHERE amount=10; 
  ```
  
* ```GROUP BY```  
  
  Оператор ```GROUP BY``` часто используется с агрегатными функциями, такими как ```COUNT```, ```MAX```, ```MIN```, ```SUM``` и ```AVG```, для группировки выходных значений.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    GROUP BY <col_namex>; 
  ```
  Пример
  Выведем количество курсов для каждого факультета:
  ```
  SELECT COUNT(course_id), dept_name
    FROM course
    GROUP BY dept_name; 
  ```
  
* ```HAVING```  
  
  Ключевое слово ```HAVING``` было добавлено в SQL по той причине, что ```WHERE``` не может использоваться для работы с агрегатными функциями.
  ```
  SELECT <col_name1>, <col_name2>, ...
    FROM <table_name>
    GROUP BY <column_namex>
    HAVING <condition> 
  ```
  Пример
  Выведем список факультетов, у которых более одного курса:
  ```
  SELECT COUNT(course_id), dept_name
    FROM course
    GROUP BY dept_name
    HAVING COUNT(course_id)>1; 
  ```
  
* ```ORDER BY```  
  
  ```ORDER BY``` используется для сортировки результатов запроса по убыванию или возрастанию. ```ORDER BY``` отсортирует по возрастанию, если не будет указан способ сортировки ```ASC``` или ```DESC```.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    ORDER BY <col_name1>, <col_name2>, … ASC|DESC;
  ```
  Пример
  Выведем список курсов по возрастанию и убыванию количества кредитов:
  ```
  SELECT * FROM course ORDER BY credits;
  SELECT * FROM course ORDER BY credits DESC;
  ```
  
* ```BETWEEN```  

  ```BETWEEN``` используется для выбора значений данных из определённого промежутка. Могут быть использованы числовые и текстовые значения, а также даты.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namex> BETWEEN <value1> AND <value2>;
  ```
  Пример
  Выведем список инструкторов, чья зарплата больше 50 000, но меньше 100 000:
  ```
  SELECT * FROM instructor
    WHERE salary BETWEEN 50000 AND 100000; 
  ```

* ```LIKE```  

  Оператор ```LIKE``` используется в ```WHERE```, чтобы задать шаблон поиска похожего значения.

  Есть два свободных оператора, которые используются в ```LIKE```:

  % (ни одного, один или несколько символов);
  _ (один символ).
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namex> LIKE <pattern>; 
  ```
  Пример
  Выведем список курсов, в имени которых содержится «to», и список курсов, название которых начинается с «CS-»:
  ```
  SELECT * FROM course WHERE title LIKE ‘%to%’;
  SELECT * FROM course WHERE course_id LIKE 'CS-___';
  ```

* ```IN```  
  
  С помощью ```IN``` можно указать несколько значений для оператора ```WHERE```:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namen> IN (<value1>, <value2>, …);
  ```
  Пример
  Выведем список студентов с направлений Comp. Sci., Physics и Elec. Eng.:
  ```
  SELECT * FROM student
    WHERE dept_name IN (‘Comp. Sci.’, ‘Physics’, ‘Elec. Eng.’);
  ```
  
* ```JOIN```  

  ```JOIN``` используется для связи двух или более таблиц с помощью общих атрибутов внутри них.
  Чтобы объединить две таблицы в одну, следует использовать оператор ```JOIN```. Соединение таблиц может быть внутренним (```INNER```) или внешним (```OUTER```), причём внешнее соединение может быть левым (```LEFT```), правым (```RIGHT```) или полным (```FULL```).

  * ```INNER JOIN``` — получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.
  * ```FULL OUTER JOIN``` — объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
  * ```LEFT JOIN``` — возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.
  * ```RIGHT JOIN``` — работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.
  ```
  SELECT <col_name1>, <col_name2>, …
  FROM <table_name1>
  JOIN <table_name2>
  ON <table_name1.col_namex> = <table2.col_namex>;
  ```
  Следующий запрос выбирает все заказы с информацией о клиенте:
  ```
  SELECT Orders.OrderID, Customers.CustomerName
  FROM Orders
  INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
  ```
  
* ```VIEW```  
  
  ```VIEW``` — это виртуальная таблица SQL, созданная в результате выполнения выражения. Она содержит строки и столбцы и очень похожа на обычную SQL-таблицу. VIEW всегда показывает самую свежую информацию из базы данных.

  Создание
  ```
  CREATE VIEW <view_name> AS
    SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <condition>;
  ```
  Удаление
  ```
  DROP VIEW <view_name>;
  ```

## Математические функции в SQL

|**Функция**|	**Описание**	|**Пример**|
|:------------------------------|:--------------------------|:--------------------------|
| ```CEILING(x)``` |	возвращает наименьшее целое число, большее или равное x(округляет до целого числа в большую сторону)|```	CEILING(4.2)=5 CEILING(-5.8)=-5```|
| ```ROUND(x, k)``` |	округляет значение x до k знаков после запятой, если k не указано – x округляется до целого	|```ROUND(4.361)=4 ROUND(5.86592,1)=5.9```|
| ```FLOOR(x)``` |	возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)	|```FLOOR(4.2)=4 FLOOR(-5.8)=-6```|
| ```POWER(x, y)``` |	возведение x в степень y	|```POWER(3,4)=81.0```|
| ```SQRT(x)``` |	квадратный корень из x	|```SQRT(4)=2.0 SQRT(2)=1.41...```|
| ```DEGREES(x)``` |	конвертирует значение x из радиан в градусы	|```DEGREES(3) = 171.8...```|
| ```RADIANS(x)``` |	конвертирует значение x из градусов в радианы	|```RADIANS(180)=3.14...```|
| ```ABS(x)``` |	модуль числа x	|```ABS(-1) = 1 ABS(1) = 1```|
| ```PI()``` |	pi = 3.1415926...	 ||
| ```COUNT(col_name)``` | возвращает количество строк||
| ```SUM(col_name)``` | возвращает сумму значений в данном столбце||
| ```AVG(col_name)``` | возвращает среднее значение данного столбца||
| ```MIN(col_name)``` | возвращает наименьшее значение данного столбца||
| ```MAX(col_name)``` | возвращает наибольшее значение данного столбца||

**Оконные функции в SQL**

<br/>

# Статистика
<a id="statistics"></a>

**Что такое доверительные интервалы?**

**Что такое статистическая значимость?**

<br/>

# Задачи и алгоритмы машинного обучения
<a id="Machine-learning-tasks-and-algorithms"></a>

## Задачи машинного обучения

### Что такое обучение с учителем?

В данном случае в тренировочном датасете для кажого объекта у нас есть метка или лэйбл. В тестовом - этого лейбла нет и нам нужно его предсказать. 
Бывает два подтипа решения задач с учителем:

* Регрессия

В задачах регрессии меткой является вещественное число.  

Например, если мы предсказываем стоимость квартиры, то это будет задача регрессии.

* Классификация

В данном случае мы предсказываем не вещественное число, а конечно подмножество классов.  
Если таких классов два, то это задача бинарной классификации.
Если больше двух, то это многоклассовая классификация.  

Например, если мы предсказываем есть на фотографии машина или нет, то это задача бинарной классификации, потому-что у нас в данном случае два класса (либо машина есть, либо её нет)

### Что такое обучение без учителя?

В данном случае у нас нет лейблов для объектов, и мы не пытаемся их предсказать.  
Бывает несколько подтипов решения задач без учителя:

* Кластеризация

В данном случае попытаемся выявить некоторые паттерны в данных и объединить их в кластеры. Так, чтобы в одном кластере были похожие объекты, а в разных кластерах они были разные.  

Например, мы хотим разбить фильмы по жанрам и мы не знаем какие у нас жанры есть, мы хотим понять чем они отличаются друг от друга и на какое количество кластеров их хорошо разбить.

* Задача понижения размерности  

В данном случае мы хотим вектора большой размерности ужать до меньшей, при этом сохранить как можно больше информации

* Визуализация

Уменьшаем размерность до состояния, когда её можно визуализировать

### Что такое классификация?

Классификация — один из разделов машинного обучения, посвященный решению следующей задачи. Имеется множество объектов (ситуаций), разделённых некоторым образом на классы. Задано конечное множество объектов, для которых известно, к каким классам они относятся. Это множество называется обучающей выборкой. Классовая принадлежность остальных объектов не известна. Требуется построить алгоритм, способный классифицировать произвольный объект из исходного множества.  

Классифицировать объект — значит, указать номер (или наименование класса), к которому относится данный объект.  

Классификация объекта — номер или наименование класса, выдаваемый алгоритмом классификации в результате его применения к данному конкретному объекту.  

В математической статистике задачи классификации называются также задачами дискриминантного анализа.

В машинном обучении задача классификации относится к разделу обучения с учителем. Существует также обучение без учителя, когда разделение объектов обучающей выборки на классы не задаётся, и требуется классифицировать объекты только на основе их сходства друг с другом. В этом случае принято говорить о задачах кластеризации или таксономии, и классы называть, соответственно, кластерами или таксонами.

**Типология задач классификации**  
_Типы входных данных_
* Признаковое описание — наиболее распространённый случай. Каждый объект описывается набором своих характеристик, называемых признаками. Признаки могут быть числовыми или нечисловыми.  
* Матрица расстояний между объектами. Каждый объект описывается расстояниями до всех остальных объектов обучающей выборки. С этим типом входных данных работают немногие методы, в частности, метод ближайших соседей, метод парзеновского окна, метод потенциальных функций.  
* Временной ряд или сигнал представляет собой последовательность измерений во времени. Каждое измерение может представляться числом, вектором, а в общем случае — признаковым описанием исследуемого объекта в данный момент времени.  
* Изображение или видеоряд.  
* Встречаются и более сложные случаи, когда входные данные представляются в виде графов, текстов, результатов запросов к базе данных, и т. д. Как правило, они приводятся к первому или второму случаю путём предварительной обработки данных и извлечения признаков.  
Классификацию сигналов и изображений называют также распознаванием образов.

_Типы классов_
* Двухклассовая классификация. Наиболее простой в техническом отношении случай, который служит основой для решения более сложных задач.  
* Многоклассовая классификация. Когда число классов достигает многих тысяч (например, при распознавании иероглифов или слитной речи), задача классификации становится существенно более трудной.  
* Непересекающиеся классы.  
* Пересекающиеся классы. Объект может относиться одновременно к нескольким классам.  
* Нечёткие классы. Требуется определять степень принадлежности объекта каждому из классов, обычно это действительное число от 0 до 1.  

### Что такое кластеризация?

### Что такое понижение размерности?

## Алгоритмы машинного обучения

### Линейная регрессия

Алгоритм для задачи регрессии. Он предсказывает вещественное число, позволяет описывать линейную или биномиальную зависимость.  
Обучение происходит с помощью минимизации функции потерь, может быть две функции потерь.

Средняя квадратичная ошибка:  

<img src="https://render.githubusercontent.com/render/math?math=MSE = \Sigma_{i=1}^{n}(y_i - y_i^p)^2">

Средняя абсолютная ошибка:  

<img src="https://render.githubusercontent.com/render/math?math=MAE = \Sigma_{i=1}^{n} \left| y_i - y_i^p \right |">

Обучение происходит с помощью градиентного спуска, также возможно аналитическое решение этой задачи с помощью нахождения обратной матрицы. Но в реальноси оно не применятся, так как требует значительных вычислительных ресурсов, а также не для всех матриц можно найти обратную.

### Логистическая регрессия

Это алгоритм для задачи классификации. Отличается от линейной регресси тем, что тут есть функция активации. 

Для задач бинарной классификации используется сигмоида.  
Для задач многоклассовой классификации используется функция Softmax:  

<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ab3ef6ba51afd36c1d2baf06540022053b2dca73">

Функции потерь тоэе отличаются:  
Для задач бинарной классификации - это LogLoss:  

<img src="https://alexanderdyakonov.files.wordpress.com/2018/03/log_loss_23.png">  

Для задач многоклассовой классификации - это categorical cross entropy

## Обучение с помощью градиентного спуска

Сначала инициализируются веса модели. 

## Алгоритмы кластеризации такие как k-means и c-means, dbscan

## Иерархическая кластеризация

## Алгоритмы понижения размерности такие как PCA, t-SNE

## Алгоритмы для нейронных сетей

## Полносвязная нейронная сеть

## Свёрточная нейронная сеть

## Рекуррентная нейронная сеть

## Для каких задач подходит тот или иной алгоритм?

### Что такое градиент и для чего он нужен?

### Что такое функция активации?

<br/>

# Сеть
<a id="network"></a>

## Что происходит в тот момент, когда вы вводите в адресной строке браузера URL сайта и нажимаете ввод?

## http

# Big Data
<a id="big-data"></a>

* [Что такое DWH](#dwh)  
* [Data Lake](#data-lake)
* [Витрины данных](#data-marts)
* [ETL и ETL-запросы](#ETL)
* [Что такое Hadoop?](#hadoop)

## Что такое DWH
<a id="dwh"></a>

DWH — Data warehouse — Корпоративное хранилище данных (КХД) — склад всех нужных и важных для принятия решений данных компании.  

Потребность в КХД сформировалась примерно в 90-х годах прошлого века, когда в секторе enterprise стали активно использоваться разные информационные системы для учета множества бизнес-показателей. Каждое такое приложение успешно решало задачу автоматизации локального производственного процесса, например, выполнение бухгалтерских расчетов, проведение транзакций, HR-аналитика и т.д.  

При этом схемы представления (модели) справочных и транзакционных данных в одной системе могут кардинально отличаться от другой, что влечет расхождение информации. Частично этот вопрос Data Governance мы затрагивали в контексте управления НСИ. Кроме того, большое разнообразие моделей данных затрудняет получение консолидированной отчетности, когда нужна целостная картина из всех прикладных систем. Поэтому возникли корпоративные хранилища данных (Data Warehouse, DWH) – предметно-ориентированные базы данных для консолидированной подготовки отчётов, интегрированного бизнес-анализа и оптимального принятия управленческих решений на основе полной информационной картины.

__Архитектура КХД__

Вышеприведенное определение DWH показывает, что это средство хранения данных является реляционным. Однако, не стоит считать КХД просто большой базой данных с множеством взаимосвязанных таблиц. В отличие от традиционной SQL-СУБД, Data Warehouse имеет сложную многоуровневую (слоеную) архитектуру, которая называется LSA – Layered Scalable Architecture. По сути, LSA реализует логическое деление структур с данными на несколько функциональных уровней. Данные копируются с уровня на уровень и трансформируются при этом, чтобы в итоге предстать в виде согласованной информации, пригодной для анализа.

Классически LSA реализуется в виде следующих уровней:

1. Операционный слой первичных данных(Primary Data Layer или стейджинг)  
Здесь выполняется загрузка информации из систем-источников в исходном качестве и сохранением полной истории изменений. Здесь происходит абстрагирование следующих слоев хранилища от физического устройства источников данных, способов их сбора и методов выделения изменений.
2. Ядро хранилища (Core Data Layer)  
Центральный компонент, который выполняет консолидацию данныхиз разных источников, приводя их к единым структурам и ключам. Именно здесь происходит основная работа с качеством данных и общие трансформации, чтобы абстрагировать потребителей от особенностей логического устройства источников данных и необходимости их взаимного сопоставления. Так решается задача обеспечения целостности и качества данных.
3. Аналитические витрины (Data Mart Layer)  
Тут данные преобразуются к структурам, удобным для анализа и использования в BI-дэшбордах или других системах-потребителях. Когда витрины берут данные из ядра, они называются регулярными. Если же для быстрого решения локальных задач не нужна консолидация данных, витрина может брать первичные данные из операционного слоя и называется соответственно операционной. Также бывают вторичные витрины, которые используются для представления результатов сложных расчетов и нетипичных трансформаций. Таким образом, витрины обеспечивают разные представления единых данных под конкретную бизнес-специфику.
4. Сервисный слой (Service Layer)  
Обеспечивает управление всеми вышеописанными уровнями. Он не содержит бизнес-данных, но оперирует метаданными и другими структурами для работы с качеством данных, позволяя выполнять сквозной аудит данных (data lineage), использовать общие подходы к выделению дельты изменений и управления загрузкой. Также здесь доступны средства мониторинга и диагностики ошибок, что ускоряет решение проблем.


__LSA – слоеная архитектура DWH: как устроено хранилище данных__  
![LSA – слоеная архитектура DWH: как устроено хранилище данных](https://www.bigdataschool.ru/wp-content/uploads/2020/04/%D0%B4%D0%B2%D1%85_1.png)

Все слои, кроме сервисного, состоят из области постоянного хранения данных и модуля загрузки и трансформации. Области хранения содержат технические (буферные) таблицы для трансформации данных и целевые таблицы, к которым обращается потребитель. Для обеспечения процессов загрузки и аудита ETL-процессов данные в целевых таблицах стейджинга, ядра и витринах маркируются техническими полями (мета-атрибутами). Еще выделяют слой виртуальных провайдеров данных и пользовательских отчетов для виртуального объединения (без хранения) данных из различных объектов. Каждый уровень может быть реализован с помощью разных технологий хранения и преобразования данных или универсальных продуктов, например, SAP NetWeaver Business Warehouse (SAP BW).

__В чём разница между обычной базой данных и DWH__

1. Типы хранимых данных.   
Обычные СУБД хранят данные строго для определенных подсистем. База данных склада хранит складские запасы и ничего более. База данных кадровиков хранит данные по персоналу, но не товары или сделки. DWH, как правило, хранит информацию разных подразделений — там найдутся данные и по товарам, и по персоналу, и по сделкам.
2. Объемы данных.  
Обычная БД, которая ведется в рамках стандартной деятельности компании, содержит только актуальную информацию, нужную в данный момент для функционирования определенной системы. В DWH пишутся не столько копии актуальных состояний, сколько исторические данные и агрегированные значения. Например, состояние запасов разных категорий товаров на конец смены за последние пять лет. Иногда в DWH пишутся и более крупные пачки данных, если они имеют критическое значение для бизнеса — допустим, полные данные по продажам и сделкам. То есть, по сути, это копия СУБД отдела продаж.
3. Место в рабочих процессах.  
Информация обычно сразу попадает в рабочие базы данных, а уже оттуда некоторые записи переползают в DWH. Склад данных, по сути, отражает состояние других БД и процессов в компании уже после того, как вносятся изменения в рабочих базах.

DWH — это система данных, отдельная от оперативной системы обработки данных. В корпоративных хранилищах в удобном для анализа виде хранятся архивные данные из разных, иногда очень разнородных источников. Эти данные предварительно обрабатываются и загружаются в хранилище в ходе процессов извлечения, преобразования и загрузки, называемых ETL. Решения ETL и DWH — это (упрощенно) одна система для работы с корпоративной информацией и ее хранения.

__Что дают DWH-решения для BI и принятия решений в компании__

Понятное дело, что просто так тратить деньги и время на консервирование кучи разных записей, которые и так можно накопать в других базах данных, никто не станет. Ответ заключается в том, что DWH необходима для того, чтобы делать BI — business intelligence.  

Что такое BI с DWH? Бизнес-аналитика (BI) — это процесс анализа данных и получения информации, помогающей компаниям принимать решения.  

Допустим, у вас в онлайн-магазине упала выручка. Менеджеры зовут на помощь бизнес-аналитика и просят его разобраться. Тот идет в DWH, вынимает оттуда данные по продажам, выручке, количеству пользователей, расходам — и собирает отчет, который в подробностях и с цифрами говорит о причинах падения финансовых показателей. Менеджеры внимательно смотрят на эту информацию и принимают решения по реорганизации ассортимента товаров и маркетинговых политик.
Если бы такого аналитического отчета не было — управленцам пришлось бы искать проблему наугад.

Логичный вопрос: казалось бы, зачем держать для этого всего DWH? Аналитики вполне могут ходить в базы данных разных систем и просто выдергивать оттуда то, что им надо.

Ответ: так, конечно, тоже можно делать. Но — не нужно. И вот почему:

1. Доступ к нужным данным.   
Если компания большая, на получение данных из разных источников нужно собирать разрешения и доступы. У каждого подразделения в такой ситуации, как правило, свои базы данных со своими паролями, которые надо будет запрашивать отдельно. В DWH все нужное уже будет под рукой в готовом виде. Можно просто пойти и дернуть там необходимую статистику.
2. Сохранность нужных данных.   
Данные в DWH не теряются и хранятся в виде, удобном для принятия решений: есть исторические записи, есть агрегированные значения. В операционной базе данных такой информации может и не быть. Например, админы уж точно не будут хранить на складском сервере архив запасов за 10 лет — БД склада в таком случае была бы слишком тяжелой. А вот хранить агрегированные запасы со склада в DWH — это нормально.
3. Устойчивость работы бизнес-систем.   
DWH оптимизируется для работы аналитиков, а эти ребята могут запрашивать очень большие объемы информации. Если они будут делать это с помощью DWH — ничего страшного, даже если их запрос будет обрабатываться очень долго. А если запросить слишком много записей с боевой базы данных сервера — он может уйти в отказ до конца выполнения запроса от аналитики и создать проблемы для других систем. DWH исключает риск того, что аналитики что-то повесят или сломают.   

__Почему бизнес-аналитика невозможна без DWH__

DWH и бизнес-аналитики переводят управление компаниями из искусства в науку. Имея под рукой результаты измерений по сотням показателей, можно выдвигать гипотезы и ставить эксперименты. Правильные решения легко подтверждаются объективными цифрами, которые достают аналитики из DWH.

Оптимальные управленческие решения — это не всегда максимизация прибыли. Это еще и выращивание новых производственных мощностей, минимизация негативного влияния на экологию, достойное качество жизни сотрудников, лояльность клиентов и стабильность бизнеса в долгосрочной перспективе. Все эти, казалось бы, сложные и эфемерные показатели можно анализировать с помощью BI и данных из DWH.

Без DWH и аналитиков управление бизнесом превращается в слепую езду по льду — возможно, при определенной сноровке вы попадете куда надо, но шансов улететь в сугроб или в столб все же куда больше.  

## Data Lake
<a id="data-lake"></a>

В 2010-х годах, с наступлением эпохи Big Data, фокус внимания от традиционных DWH сместился озерам данных (Data Lake). Однако, считать озеро данных новым поколением КХД не совсем корректно по следующим причинам:

1. Разное целевое назначение  
DWH используется менеджерами, аналитиками и другими конечными бизнес-пользователями, тогда как озеро данных – в основном Data Scientist’ами. Напомним, в Data Lake хранится неструктурированная, т.н. сырая информация: видеозаписи с беспилотников и камер наружного наблюдения, транспортная телеметрия, графические изображения, логи пользовательского поведения, метрики сайтов и информационных систем, а также прочие данные с разными форматами хранения (схемами представления). Они пока непригодны для ежедневной аналитики в BI-системах, но могут использоваться Data Scientist’ами для быстрой отработки новых бизнес-гипотез с помощью алгоритмов машинного обучения;
2. Разные подходы к проектированию   
Дизайн DWH основан на реляционной логике работы с данными – третья нормальная форма для нормализованных хранилищ, схемы звезды или снежинки для хранилищ с измерениями. При проектировании озера данных архитектор Big Data и Data Engineer большее внимание уделяют ETL-процессам с учетом многообразия источников и приемников разноформатной информации. А вопрос ее непосредственного хранения решается достаточно просто – требуется лишь масштабируемая, отказоустойчивая и относительно дешевая файловая система, например, HDFS или Amazon S3;
3. Цена  
обычно Data Lake строится на базе бюджетных серверов с Apache Hadoop, без дорогостоящих лицензий и мощного оборудования, в отличие от больших затрат на проектирование и покупку специализированных платформ класса Data Warehouse, таких как SAP, Oracle, Teradata и пр.

Таким образом, озеро данных существенно отличается от КХД. Тем не менее, архитектурный подход LSA может использоваться и при построении Data Lake. Например, именно такая слоенная структура была принята за основу озера данных в Тинькоф-банке:

* на уровне RAW хранятся сырые данные различных форматов (tsv, csv, xml, syslog, json и т.д.);
* на операционном уровне (ODD, Operational Data Definition) сырые данные преобразуются в приближенный к реляционному формат;
* на уровне детализации (DDS, Detail Data Store) собирается консолидированная модель детальных данных;
* уровень MART выполняет роль прикладных витрин данных для бизнес-пользователей и моделей машинного обучения.  

В данном примере для структурированных запросов к большим данным используется Apache Hive – популярное средство класса SQL-on-Hadoop. Само файловое хранилище организовано в кластере Hadoop на основе коммерческого дистрибутива от Cloudera (CDH). Традиционное DWH банка реализовано на массивно-параллельной СУБД Greenplum. От себя добавим, что альтернативой Apache Hive могла выступить Cloudera Impala, которая также, как Greenplum, Arenadata DB и Teradata, основана на массивно-параллельной архитектуре. Впрочем, выбор Hive обоснован, если требовалась высокая отказоустойчивость и большая пропускная способность. Подробнее о сходствах и различиях Apache Hive и Cloudera Impala мы рассказывали здесь. Возвращаясь к кейсу Тинькофф-банка, отметим, что BI-инструменты считывают данные из озера и классического DWH, обогащая типичные OLAP-отчеты информацией из хранилища Big Data. Это используется для анализа интересов, прогнозирования поведения, а также выявления текущих и будущих потребностей, которые возникают у посетителей сайта банка.

## Витрины данных
<a id="data-marts"></a>

## ETL и ETL-запросы
<a id="ETL"></a>

__ETL__

В переводе ETL (Extract, Transform, Load) — извлечение, преобразование и загрузка. То есть процесс, с помощью которого данные из нескольких систем объединяют в единое хранилище данных.

Представьте ритейлера с розничными и интернет-магазинами. Ему нужно анализировать тенденции продаж и онлайн, и офлайн. Но бэкэнд-системы для них, скорее всего, будут отдельными. Они могут иметь разные поля или форматы полей для сбора данных, использовать системы, которые не могут «общаться» друг с другом.

И вот тогда наступает момент для ETL.

ETL-система извлекает данные из обеих систем, преобразует их в соответствии с требованиями к формату хранилища данных, а затем загружает в это хранилище.

Схема всегда выглядит так: сначала извлечение данных из одного или нескольких источников, потом их подготовка к интеграции, после этого идет загрузка, и извлеченные данные попадают в общую базу.

__ETL на практике__  

Современные инструменты ETL собирают, преобразуют и хранят данные из миллионов транзакций в самых разных источниках данных и потоках. Эта возможность предоставляет множество новых возможностей: анализ исторических записей для оптимизации процесса продаж, корректировка цен и запасов в реальном времени, использование машинного обучения и искусственного интеллекта для создания прогнозных моделей, разработка новых потоков доходов, переход в облако и многое другое.

**Облачная миграция** Процесс переноса данных и приложений в облако называют облачной миграцией. Она помогает сэкономить деньги, сделать приложения более масштабируемыми и защитить данные. ETL в таком случае используют для перемещения данных в облако.

**Хранилище данных** Хранилище данных — база данных, куда передают данные из различных источников, чтобы их можно было совместно анализировать в коммерческих целях. Здесь ETL используют для перемещения данных в хранилище данных.

**Машинное обучение** Машинное обучение — метод анализа данных, который автоматизирует построение аналитических моделей. ETL может использоваться для перемещения данных в одно хранилище для машинного обучения.

**Интеграция маркетинговых данных** Маркетинговая интеграция включает в себя перемещение всех маркетинговых данных — о клиентах, продажах, из социальных сетей и веб-аналитики — в одно место, чтобы вы могли проанализировать их. ETL используют для объединения маркетинговых данных.

**Интеграция данных IoT** То есть данных, собранных различными датчиками, в том числе встроенными в оборудование. ETL помогает перенести данные от разных IoT в одно место, чтобы вы могли сделать их подробный анализ.

**Репликация базы данных** — данные из исходных баз данных копируют в облачное хранилище. Это может быть одноразовая операция или постоянный процесс, когда ваши данные обновляются в облаке сразу же после обновления в исходной базе. ETL можно использовать для осуществления процесса репликации данных.

**Бизнес-аналитика** Бизнес-аналитика — процесс анализа данных, позволяющий руководителям, менеджерам и другим заинтересованным сторонам принимать обоснованные бизнес-решения. ETL можно использовать для переноса нужных данных в одно место, чтобы их можно было использовать.

__Популярные ETL-системы__  

**Cloud Big Data** — PaaS-сервис для анализа больших данных (big data) на базе Apache Hadoop, Apache Spark, ClickHouse. Легко масштабируется, позволяет заменить дорогую и неэффективную локальную инфраструктуру обработки данных на мощную облачную инфраструктуру. Помогает обрабатывать структурированные и неструктурированные данные из разных источников, в том числе в режиме реального времени. Развернуть кластер интеграции и обработки данных в облаках можно за несколько минут, управление осуществляется через веб-интерфейс, командную строку или API.

**IBM InfoSphere** — инструмент ETL, часть пакета решений IBM Information Platforms и IBM InfoSphere. Доступен в различных версиях (Server Edition, Enterprise Edition и MVS Edition). Помогает в очистке, мониторинге, преобразовании и доставке данных, среди преимуществ: масштабируемость, возможность интеграции почти всех типов данных в режиме реального времени.

**PowerCenter** — набор продуктов ETL, включающий клиентские инструменты PowerCenter, сервер и репозиторий. Данные хранятся в хранилище, где к ним получают доступ клиентские инструменты и сервер. Инструмент обеспечивает поддержку всего жизненного цикла интеграции данных: от запуска первого проекта до успешного развертывания критически важных корпоративных приложений.

**iWay Software** предоставляет возможность интеграции приложений и данных для удобного использования в режиме реального времени. Клиенты используют их для управления структурированной и неструктурированной информацией. В комплект входят: iWay DataMigrator, iWay Service Manager и iWay Universal Adapter Framework.

**Microsoft SQL Server** — платформа управления реляционными базами данных и создания высокопроизводительных решений интеграции данных, включающая пакеты ETL для хранилищ данных.

**OpenText** — платформа интеграции, позволяющая извлекать, улучшать, преобразовывать, интегрировать и переносить данные и контент из одного или нескольких хранилищ в любое новое место назначения. Позволяет работать со структурированными и неструктурированными данными, локальными и облачными хранилищами.

**Oracle GoldenGate** — комплексный программный пакет для интеграции и репликации данных в режиме реального времени в разнородных IT-средах. Обладает упрощенной настройкой и управлением, поддерживает облачные среды.

**Pervasive Data Integrator** — программное решение для интеграции между корпоративными данными, сторонними приложениями и пользовательским программным обеспечением. Data Integrator поддерживает сценарии интеграции в реальном времени.

**Pitney Bowes** предлагает большой набор инструментов и решений, нацеленных на интеграцию данных. Например, Sagent Data Flow — гибкий механизм интеграции, который собирает данные из разнородных источников и предоставляет полный набор инструментов преобразования данных для повышения их коммерческой ценности.

**SAP Business Objects** — централизованная платформа для интеграции данных, качества данных, профилирования данных, обработки данных и отчетности. Предлагает бизнес-аналитику в реальном времени, приложения для визуализации и аналитики, интеграцию с офисными приложениями.

**Sybase** включает Sybase ETL Development и Sybase ETL Server. Sybase ETL Development — инструмент с графическим интерфейсом для создания и проектирования проектов и заданий по преобразованию данных. Sybase ETL Server — масштабируемый механизм, который подключается к источникам данных, извлекает и загружает данные в хранилища.

__Open source ETL-средства__

Большинство инструментов ETL с открытым исходным кодом помогают в управлении пакетной обработкой данных и автоматизации потоковой передачи информации из одной системы данных в другую. Эти рабочие процессы важны при создании хранилища данных для машинного обучения.  

Некоторые из бесплатных и открытых инструментов ETL принадлежат поставщикам, которые в итоге хотят продать корпоративный продукт, другие обслуживаются и управляются сообществом разработчиков, стремящихся демократизировать процесс.  

Open source ETL-инструменты интеграции данных:  

**Apache Airflow** — платформа с удобным веб-интерфейсом, где можно создавать, планировать и отслеживать рабочие процессы. Позволяет пользователям объединять задачи, которые нужно выполнить в строго определенной последовательности по заданному расписанию. Пользовательский интерфейс поддерживает визуализацию рабочих процессов, что помогает отслеживать прогресс и видеть возникающие проблемы.  

**Apache Kafka** — распределенная потоковая платформа, которая позволяет пользователям публиковать и подписываться на потоки записей, хранить потоки записей и обрабатывать их по мере появления. Kafka используют для создания конвейеров данных в реальном времени. Он работает как кластер на одном или нескольких серверах, отказоустойчив и масштабируем.  

**Apache NiFi** — распределенная система для быстрой параллельной загрузки и обработки данных с большим числом плагинов для источников и преобразований, широкими возможностями работы с данными. Пользовательский веб-интерфейс NiFi позволяет переключаться между дизайном, управлением, обратной связью и мониторингом.  

**CloverETL** (теперь CloverDX) был одним из первых инструментов ETL с открытым исходным кодом. Инфраструктура интеграции данных, основанная на Java, разработана для преобразования, отображения и манипулирования данными в различных форматах. CloverETL может использоваться автономно или встраиваться и подключаться к другим инструментам: RDBMS, JMS, SOAP, LDAP, S3, HTTP, FTP, ZIP и TAR. Хотя продукт больше не предлагается поставщиком, его можно безопасно загрузить с помощью SourceForge. CloverDX по-прежнему поддерживает CloverETL в соответствии со стандартным соглашением о поддержке.  

**Jaspersoft ETL** — один из продуктов с открытым исходным кодом TIBCO Community Edition, позволяет пользователям извлекать данные из различных источников, преобразовывать их на основе определенных бизнес-правил и загружать в централизованное хранилище данных для отчетности и аналитики. Механизм интеграции данных инструмента основан на Talend. Community Edition прост в развертывании, позволяет создавать витрины данных для отчетности и аналитики.  

**Apatar** — кроссплатформенный инструмент интеграции данных с открытым исходным кодом, который обеспечивает подключение к различным базам данных, приложениям, протоколам, файлам. Позволяет разработчикам, администраторам баз данных и бизнес-пользователям интегрировать информацию разного формата из различных источников данных. У инструмента интуитивно понятный пользовательский интерфейс, который не требует кодирования для настройки заданий интеграции данных. Инструмент поставляется с предварительно созданным набором инструментов интеграции и позволяет пользователям повторно использовать ранее созданные схемы сопоставления.

## Что такое Hadoop?
<a id="hadoop"></a>

Hadoop - инструмент для обработки Big Data. Hadoop - это проект Apache, является системой для распределённых вычислений. При этом эта система является масштабируемой и отказоустойчивой. 

__История Hadoop__  
Начинался как проект в Apache Nutch  
В 2004 году Google публикует статьи про GFS и MapReduce  
На основе этих статей формируется распределённая файловая система  

__Системные принципы Hadoop__  
* Горизонтальное (Scale-out) масштабирование вместо вертикального (Scale-Up)
* Отправление кода к данным
* Умение обрабатывать падения нод и отказы оборудования
* Инкапсуляция сложности работы распределённых и многопоточных приложений

__Масштабирование__  
* Вертикальное  
  - Добавить дополнительные ресурсы к существующему железу (CPU, RAM)  
  - Если нельзя улучшить железо, то надо покупать более мощное новое  
  - Закон Мура не успевает за ростом объёма данных  
* Горизонтальное 
  - Добавить больше машин к существующему кластеру
  - Приложение поддерживает добавлние/удаление серверов
  - Просто масштабировать "вниз"

# Источники
<a id="sources"></a>

* [Документация python](https://docs.python.org/3/library/)
* ["Как устроен Python. Гид для разработчиков, программистов и интересующихся" Мэтт Харрисон](https://t.me/pythonbooks/389)  
* [Магические методы Rafe Kettler](https://rszalski.github.io/magicmethods/)  
* [Техническая документация по SQL Server](https://docs.microsoft.com/ru-ru/sql/sql-server/?view=sql-server-ver15)  
* [SQL и NoSQL: разбираемся в основных моделях баз данных](https://tproger.ru/translations/sql-nosql-database-models/)  
* [Основные команды SQL, которые должен знать каждый программист](https://tproger.ru/translations/sql-recap/)  
* [Профессиональный информационно-аналитический ресурс, посвященный машинному обучению, распознаванию образов и интеллектуальному анализу данных](https://www.machinelearning.ru/)
* [Inside the Python GIL](http://www.dabeaz.com/python/GIL.pdf)
* [Журнал Mail.ru Cloud Solutions об IT-бизнесе, технологиях и цифровой трансформации](https://mcs.mail.ru/blog/)
* [Школа больших данных](https://www.bigdataschool.ru/)
* [Блог компании Тинькофф](https://habr.com/ru/company/tinkoff/profile/)
