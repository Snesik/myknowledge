# Разделы:
<a id="sections"></a>

1. [Общие вопросы по python](#general-python-questions)
   * [Разница 2 и 3 версии python](#Difference-2-and-3-python-version)  
   * [ООП](#oop)  
      - [SOLID](#SOLID)  
      - [Что такое классы?](#classes)  
      - [Что такое магические методы?](#magic-methods)  
      - [Что такое миксин?](#mixin) 
   * [Типы и структуры данных в python](#Types-and-data-structures-in-python)  
      - [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
      - [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
      - [Что может быть в качестве ключа словаря?](#dictionary-key)  
      - [Что такое хеш-функция?](#python-hash)  
      - [В чём особенность словаря в python?](#dictionary-in-python)  
      - [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets) 
   * [GIL](#GIL) 
      - [Что такое GIL?](#what-is-GIL)  
      - [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
      - [Разница между потоками и процессами](#difference-between-threads-and-processes)  
      - [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
      - [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  
   * [GC](#GC)  
      - [Как в питоне обстоят дела с памятью (управлением памятью)](#memory-management-in-python)  
      - [Сколько стоит проверка элемента в нотации?](#how-much-does-it-cost-to-validate-an-element-in-notation)  
      - [Если есть два объекта и они указывают друг на друга](#two-objects) 
   * [Итераторы, декораторы и генераторы](#Iterators-decorators-and-generators)  
      - [Что такое итератор?](#what-is-iterator)  
      - [СЧто такое декоратор?](#what-is-decorator)  
      - [Какие декораторы стандартной библиотеки вы знаете?](#standard-library-decorators) 
      - [Что такое генератор?](what-is-generator)
      - [Что такое list comprehension, какой синтаксис создания генераторов?](list-comprehension)
      - [Является ли range итератором?](is-range-an-iterator)
   * [Алгоритмы](#Algorithms)  
   * [Хранение данных](#Data-storage)  
3. [Базы данных](#Database)
4. [Статистика](#statistics)
5. [Задачи и алгоритмы машинного обучения](#Machine-learning-tasks-and-algorithms)
6. [Сеть](#network)
   * [Что такое веб-сервисы?](#web-services)
   * [REST](#rest)  
   * [http](#http)
   * [JSON](#json)   
   * [XML](#xml)
   * [Очереди сообщений](#message-queues)
   * [Что происходит в тот момент, когда вы вводите в адресной строке браузера URL сайта и нажимаете ввод?](#www)

7. [Big Data](#Big-Data)
   * [Что такое DWH](#dwh)  
   * [Data Lake](#data-lake)
   * [Витрины данных](#data-marts)
   * [ETL и ETL-запросы](#ETL)
   * [Что такое Hadoop?](#hadoop)
   * [Архитектура HDFS](#HDFS-architecture)
8. [Бизнес](#business)
9. [Источники](#sources)
<br/>

<a id="data-marts"></a>
# Общие вопросы по python
<a id="general-python-questions"></a>
  * [Разница 2 и 3 версии python](#Difference-2-and-3-python-version)  
  * [ООП](#oop)  
  * [Типы и структуры данных в python](#Types-and-data-structures-in-python)  
  * [GIL](#GIL)  
  * [GC](#GC)  
  * [Декораторы](#Decorators)  
  * [Итераторы и генераторы](#Algorithms)  
  * [Алгоритмы](#Algorithms)  
  * [Хранение данных](#Data-storage)  

([наверх](#sections))

## Разница 2 и 3 версии python
<a id="Difference-2-and-3-python-version"></a>

В Python 2 print был оператором: ```print "Hello, world"```  
В Python 3 print - функция: ```print ("Hello, world")```

В Python 2 были две функции: range - возвращает список; xrange - возвращает итератор  
В Python 3 есть только функция range, и она возвращает итератор

В Python 2 при делении целых чисел возвращает целоче число  
В Python 3 при делении целых чисел возвращает вещественное число

**Магические методы**

* Так как в Питоне 3 различий между строкой и юникодом больше нет, ``` __unicode__```  исчез, а появился ``` __bytes__```  (который ведёт себя так же как ``` __str__```  и ``` __unicode__```  в 2.7) для новых встроенных функций построения байтовых массивов.  
* Так как деление в Питоне 3 теперь по-умолчанию «правильное деление», ``` __div__```  больше нет.  
* ``` __coerce__```  больше нет, из-за избыточности и странного поведения.  
* ``` __cmp__```  больше нет, из-за избыточности.  
* ``` __nonzero__```  было переименовано в ``` __bool__``` .  
* ``` next```  у итераторов был переименован в ``` __next__``` .

## ООП
<a id="oop"></a>
* [SOLID](#SOLID)  
* [Что такое классы?](#classes)  
* [Магические методы](#magic-methods)  
* [Что такое миксин?](#mixin)  

([наверх](#sections))

### SOLID
<a id="SOLID"></a>

S - Принцип единственной ответственности (single responsibility principle)
Для каждого класса должно быть определено единственное назначение. Не должно возникать God object, который занимается всем в программе. 

O - Принцип открытости/закрытости (open–closed principle)
«программные сущности … должны быть открыты для расширения, но закрыты для модификации». Мы должны иметь возможность добавлять функциональность. 

L - Принцип подстановки Барбары Лисков (Liskov substitution principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения 
правильности выполнения программы». У объекта есть тип, но сами классы выстраиваются в иерархию классов. Подтип типа всю старую функциональность должен выполнять. 

I - Принцип разделения интерфейса (interface segregation principle)
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс 
общего назначения». Интерфейс - способ провзаимодействовать с какой-то программной действующей функцией. 

D - Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». 

### Что такое классы?
<a id="classes"></a>
([наверх](#sections))

Класс — тип, описывающий устройство объектов. Объект — это экземпляр класса.
```
class C: 
  pass
имя_объекта = имя_класса()
```
У класса может не быть тела. 

Простейший пример класса:
```
class Rectangle:
  default_color = "green" # статический атрибут
  def __init__(self, width, height): # конструктор класса
    self.width = width # динамический атрибут
    self.height = height # динамический атрибут
```
В python нет возможности сделать несколько конструкторов. 

### Магические методы
<a id="magic-methods"></a>
([наверх](#sections))

Если какой-то идентификатор начинается с двух подчёркиваний, дальше пишется что-либо, потом снова два подчёркивания, то это спец метод. 

**Какие магические методы и для чего используются?**
```
class FileObject:
  def __init__(self, filepath='~', filename='sample.txt'): # Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.
    self.file = open(join(filepath, filename), 'r+') # Открыть файл filename в filepath в режиме чтения и записи
  def __del__(self):
    self.file.close()
    del self.file
``` 
Метод, который будет вызван при инициализации объекта.  
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в ``` __init__``` . ``` __new__```  используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка.
``` 
__new__(cls, [...])
``` 
Инициализатор класса. Самый базовый магический метод, ``` __init__``` . С его помощью мы можем инициализировать объект.
``` 
__init__(self, [...]) 
``` 
Деструктор объекта
``` 
__del__
``` 

Самый базовый из методов сравнения ``` __cmp__(self, other)``` . Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). ``` __cmp__```  должен вернуть отрицательное число, если ``` self < other``` , ноль, если ``` self == other``` , и положительное число в случае ``` self > other``` . Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в ``` __cmp__``` . Но ``` __cmp__```  может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперируют одним критерием.

* ``` __eq__(self, other)``` 
Определяет поведение оператора равенства, ==.

* ``` __ne__(self, other)``` 
Определяет поведение оператора неравенства, !=.

* ``` __lt__(self, other)``` 
Определяет поведение оператора меньше, <.

* ``` __gt__(self, other)``` 
Определяет поведение оператора больше, >.

* ``` __le__(self, other)``` 
Определяет поведение оператора меньше или равно, <=.

* ``` __ge__(self, other)``` 
Определяет поведение оператора больше или равно, >=.

**Унарные операторы и функции**

Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.

* ``` __pos__(self)``` 
Определяет поведение для унарного плюса ```(+some_object)```

* ``` __neg__(self)``` 
Определяет поведение для отрицания```(-some_object)```

* ``` __abs__(self)``` 
Определяет поведение для встроенной функции ```abs()```.

* ``` __invert__(self)``` 
Определяет поведение для инвертирования оператором ~. Для объяснения что он делает смотри статью в Википедии о бинарных операторах.

* ``` __round__(self, n)``` 
Определяет поведение для встроенной функции ```round()```. n это число знаков после запятой, до которого округлить.

* ``` __floor__(self)``` 
Определяет поведение для ```math.floor()```, то есть, округления до ближайшего меньшего целого.

* ``` __ceil__(self)``` 
Определяет поведение для ```math.ceil()```, то есть, округления до ближайшего большего целого.

* ``` __trunc__(self)``` 
Определяет поведение для ```math.trunc()```, то есть, обрезания до целого.

**Обычные арифметические операторы**

* ```__add__(self, other)```
Сложение.

* ```__sub__(self, other)```
Вычитание.

* ```__mul__(self, other)```
Умножение.

* ```__floordiv__(self, other)```
Целочисленное деление, оператор //.

* ```__div__(self, other)```
Деление, оператор /.

* ```__truediv__(self, other)```
Правильное деление. Заметьте, что это работает только когда используется ```from __future__ import division```.

* ```__mod__(self, other)```
Остаток от деления, оператор %.

* ```__divmod__(self, other)```
Определяет поведение для встроенной функции divmod().

* ```__pow__```
Возведение в степень, оператор **.

* ```__lshift__(self, other)```
Двоичный сдвиг влево, оператор <<.

* ```__rshift__(self, other)```
Двоичный сдвиг вправо, оператор >>.

* ```__and__(self, other)```
Двоичное И, оператор &.

* ```__or__(self, other)```
Двоичное ИЛИ, оператор |.

* ```__xor__(self, other)```
Двоичный xor, оператор ^.

**Магические методы преобразования типов**

В Питоне множество магических методов, предназначенных для определения поведения для встроенных функций преобразования типов.

* ```__int__(self)```
Преобразование типа в int.

* ```__long__(self)```
Преобразование типа в long.

* ```__float__(self)```
Преобразование типа в float.

* ```__complex__(self)```
Преобразование типа в комплексное число.

* ```__oct__(self)```
Преобразование типа в восьмеричное число.

* ```__hex__(self)```
Преобразование типа в шестнадцатеричное число.

* ```__index__(self)```
Преобразование типа к int, когда объект используется в срезах (выражения вида ```[start:stop:step]```). Если вы определяете свой числовой тип, который может использоваться как индекс списка, вы должны определить ```__index__```.

* ```__trunc__(self)```
Вызывается при ```math.trunc(self)```. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

* ```__coerce__(self, other)```
Метод для реализации арифметики с операндами разных типов. ```__coerce__``` должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.

**Представление своих классов**

Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.

* ```__str__(self)```
Определяет поведение функции ```str()```, вызванной для экземпляра вашего класса.

* ```__repr__(self)```
Определяет поведение функции ```repr()```, вызванной для экземпляра вашего класса. Главное отличие от ```str()``` в целевой аудитории. ```repr()``` больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне), а ```str()``` предназначен для чтения людьми.

* ```__unicode__(self)```
Определяет поведение функции ```unicode()```, вызванной для экземпляра вашего класса. ```unicode()``` похож на ```str()```, но возвращает строку в юникоде. Если клиент вызывает ```str()``` на экземпляре вашего класса, а вы определили только ```__unicode__()```, то это не будет работать. Постарайтесь всегда определять ```__str__()``` для случая, когда кто-то не имеет такой роскоши как юникод.

* ```__format__(self, formatstr)```
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, ```"Hello, {0:abc}!".format(a)``` приведёт к вызову ``` a.__format__("abc")```. Это может быть полезно для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.

* ```__hash__(self)```
Определяет поведение функции ```hash()```, вызванной для экземпляра вашего класса. Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно нужно определять и ```__eq__``` тоже. Руководствуйтесь следующим правилом: ```a == b``` подразумевает ```hash(a) == hash(b)```.

* ```__nonzero__(self)```
Определяет поведение функции ```bool()```, вызванной для экземпляра вашего класса. Должна вернуть ```True``` или ```False```, в зависимости от того, когда вы считаете экземпляр соответствующим ```True``` или ```False```.

* ```__dir__(self)```
Определяет поведение функции ```dir()```, вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю список атрибутов. Обычно, определение ```__dir__``` не требуется, но может быть жизненно важно для интерактивного использования вашего класса, если вы переопределили ```__getattr__``` или ```__getattribute__```.

* ```__sizeof__(self)```
Определяет поведение функции``` sys.getsizeof()```, вызванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах.

**Магия контейнеров**

Магические методы, используемые контейнерами.

* ```__len__(self)```
Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.

* ```__getitem__(self, key)```
Определяет поведение при доступе к элементу, используя синтаксис ```self[key]```. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: TypeError если неправильный тип ключа и KeyError если ключу не соответствует никакого значения.

* ```__setitem__(self, key, value)```
Определяет поведение при присваивании значения элементу, используя синтаксис ```self[nkey] = value```. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать KeyError и TypeError в соответствующих случаях.

* ```__delitem__(self, key)```
Определяет поведение при удалении элемента (то есть ```del self[key]```). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.

* ```__iter__(self)```
Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции ```iter()``` и в случае перебора элементов контейнера выражением ```for x in container:```. Итераторы сами по себе объекты и они тоже должны определять метод ```__iter__```, который возвращает ```self```.

* ```__reversed__(self)```
Вызывается чтобы определить поведения для встроенной функции ```reversed()```. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.

* ```__contains__(self, item)```
```__contains__``` предназначен для проверки принадлежности элемента с помощью in и not in. Вы спросите, почему же это не часть протокола последовательности? Потому что когда ```__contains__``` не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает True если находит нужный.

* ```__missing__(self, key)```
```__missing__``` используется при наследовании от ```dict```. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь ```d``` и я пишу ```d["george"]``` когда "george" не является ключом в словаре, вызывается ```d.__missing__("george"))```.

**Построение дескрипторов**

Дескрипторы — это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).

Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из ```__get__```, ```__set__``` или ```__delete__```. 

* ```__get__(self, instance, instance_class)```
Определяет поведение при возвращении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. owner это тип (класс) объекта.

* ```__set__(self, instance, value)```
Определяет поведение при изменении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. value это значение для установки в дескриптор.

* ```__delete__(self, instance)```
Определяет поведение для удаления значения из дескриптора. ```instance``` это объект, владеющий дескриптором.

**Как вызывать магические методы** 

| **Магический метод**                  |	**Когда он вызывается (пример)**        |	**Объяснение**                                       |
|:--------------------------------------|:----------------------------------------|:-----------------------------------------------------| 
| ```__new__(cls [,...])```             |	```instance = MyClass(arg1, arg2)```    |	```__new__``` вызывается при создании экземпляра     |
| ```__init__(self [,...])```           |	```instance = MyClass(arg1, arg2)```    |	```__init__``` вызывается при создании экземпляра    |
| ```__cmp__(self, other)```            |	```self == other, self > other, etc.```	| Вызывается для любого сравнения                      |
| ```__pos__(self)```                   |	```+self```                            	| Унарный знак плюса                                   |
| ```__neg__(self)```                   |	```-self```	                            | Унарный знак минуса                                  |
| ```__invert__(self)```                |	```~self```	                            | Побитовая инверсия                                   |
| ```__index__(self)```                 |	```x[self]```	                          | Преобразование, когда объект используется как индекс |
| ```__nonzero__(self)```               |	```bool(self), if self:```             	| Булевое значение объекта                             |
| ```__getattr__(self, name)```         |	```self.name # name не определено```	  | Пытаются получить несуществующий атрибут             |
| ```__setattr__(self, name, val)```    |	```self.name = val```	                  | Присвоение любому атрибуту                           |
| ```__delattr__(self, name)```         |	```del self.name```	                    | Удаление атрибута                                    |
| ```__getattribute__(self, name)```    |	```self.name```	                        | Получить любой атрибут                               |
| ```__getitem__(self, key)```          |	```self[key]```	                        | Получение элемента через индекс                      |
| ```__setitem__(self, key, val)```     |	```self[key] = val```                  	| Присвоение элементу через индекс                     |
| ```__delitem__(self, key)```          |	```del self[key]```	                    | Удаление элемента через индекс                       |
| ```__iter__(self)```                  |	```for x in self```	                    | Итерация                                             |
| ```__contains__(self, value)```       |	```value in self, value not in self```	| Проверка принадлежности с помощью in                 |
| ```__call__(self [,...])```           |	```self(args)```	                      | «Вызов» экземпляра                                   |
| ```__enter__(self)```                 |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__exit__(self, exc, val, trace)``` |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__getstate__(self)```              |	```pickle.dump(pkl_file, self)```	      | Сериализация                                         |
| ```__setstate__(self)```              |	```data = pickle.load(pkl_file)```	    | Сериализация                                         |

### Что такое миксин?
<a id="mixin"></a>
([наверх](#sections))

Это класс, который реализует несколько методов, которые ты добавляешь к разным классам для того, чтобы они унаследовали и тоже получили какие-то методы. 

## Типы и структуры данных в python
<a id="Types-and-data-structures-in-python"></a>

* [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
* [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
* [Что может быть в качестве ключа словаря?](#dictionary-key)  
* [Что такое хеш-функция?](#python-hash)  
* [В чём особенность словаря в python?](#dictionary-in-python)  
* [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets)  

([наверх](#sections))

### Какие типы и структуры данных бывают в python?
<a id="Types-and-data-structures"></a>

| *Объект*                          | *Тип*                      | 
|:---------------------------------:|:--------------------------:| 
| Строка                            | str                        |
| Целое число                       | int                        |
| Число с плавающей точкой          | float                      |
| Список                            | list                       |
| Кортеж                            | tuple                      |
| Словарь                           | dict                       |
| Множество                         | set                        |
| Логический                        | bool                       |
| Функция                           | function                   |
| Класс, определяемый пользователем | type                       |
| Экземпляр класса                  | class                      |
| Встроенная функция                | builtin_function_or_method |
| type                              | type                       |

### Что такое мутабельные и иммутабельные типы данных?
<a id="mutable-and-immutable-data-types"></a>
([наверх](#sections))

Объекты в питоне бывают двух значительно отличающихся сортов: изменяемые (mutable) и неизменяемые (immutable). Неизменяемыми являются целые и действительные числа (int, float), строки (str), последовательности байтов (бинарные данные, bytes), а также кортежи, все элементы которых неизменяемы (tuple). Напротив, списки (list), словари (dict) и множества (set) являются изменяемыми.

### Что может быть в качестве ключа словаря?
<a id="dictionary-key"></a>
([наверх](#sections))

Только неизменяемые типы данных. Ключами словаря могут являться только объекты, поддерживающие хеширование. Таким образом, использовать в качестве ключей списки, словари и другие изменяемые типы не получится. Если в словарь будут добавлены несколько значений с одним и тем же ключом, словарь сохранит последнее.

Не рекомендуется использоваться в качестве ключей числа с плавающей запятой, так как они хранятся в памяти в виде приближений.

### Что такое хеш-функция?
<a id="python-hash"></a>
([наверх](#sections))

Хэш-функция - это функция, которая принимает на вход какие-либо данные (например, строки) и возвращает число по некоторому заданному алгоритму.  
Назначением хэш-функций является возможность помещения некоторого элемента (например, строки) в хэш-таблицу, на основе которых реализованы, например, словари и множества в Python. 

Одинаковые данные будут иметь одинаковое хеш-значение.  
* Даже небольшое изменение исходных данных может привести к совершенно иному хеш-значению.  
* Хеш получается из хеш-функции, в обязанности которой входит преобразование данной информации в закодированный хеш.   
* Очевидно, что количество объектов может быть намного больше, чем количество хеш-значений, и поэтому два объекта могут хешировать одно и то же. Это называется конфликтом хэша. Это означает, что если два объекта имеют одинаковый хэш-код, они не обязательно имеют одно и то же значение.  

Cрок жизни хэша зависит только от области действия программы, и он может измениться, как только программа завершится.

### В чём особенность словаря в python?
<a id="dictionary-in-python"></a>
([наверх](#sections))

Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.  

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами:  

* Во-первых, с помощью литерала:
  ```
  d = {}
  print(d)
  {}
  d = {'dict': 1, 'dictionary': 2}
  prtin(d)
  {'dict': 1, 'dictionary': 2}
  ```
  
* Во-вторых, с помощью функции dict:
```
  d = dict(short='dict', long='dictionary')
  prtin(d)
  {'short': 'dict', 'long': 'dictionary'}
  d = dict([(1, 1), (2, 4)])
  prtin(d)
  {1: 1, 2: 4}
```

* В-третьих, с помощью метода fromkeys:
```
  d = dict.fromkeys(['a', 'b'])
  prtin(d)
  {'a': None, 'b': None}
  d = dict.fromkeys(['a', 'b'], 100)
  prtin(d)
  {'a': 100, 'b': 100}
```

* В-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.
```
  d = {a: a ** 2 for a in range(7)}
  prtin(d)
  {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

**Методы словарей**  

* ```dict.clear()``` - очищает словарь.
* ```dict.copy()``` - возвращает копию словаря.
* ```classmethod dict.fromkeys(seq[, value])``` - создает словарь с ключами из ```seq``` и значением ```value``` (по умолчанию ```None```).
* ```dict.get(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает ```default``` (по умолчанию ```None```).
* ```dict.items()``` - возвращает пары (ключ, значение).
* ```dict.keys()``` - возвращает ключи в словаре.
* ```dict.pop(key[, default])``` - удаляет ключ и возвращает значение. Если ключа нет, возвращает ```default``` (по умолчанию бросает исключение).
* ```dict.popitem()``` - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение ```KeyError```. Важно помнить, что словари неупорядочены.
* ```dict.setdefault(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением ```default``` (по умолчанию ```None```).
* ```dict.update([other])``` - обновляет словарь, добавляя пары (ключ, значение) из ```other```. Существующие ключи перезаписываются. Возвращает ```None``` (не новый словарь!).
* ```dict.values()``` - возвращает значения в словаре.

### Списки, кортежи и множества в чём их отличие?
<a id="lists-tuples-and-sets"></a>
([наверх](#sections))

_List (список)_
Базовая структура данных в python. Элементы в списке хранятся последовательно, каждому из них присвоены индексы, начиная с нуля. В отличие от массива, список может хранить объекты любого типа.

Создание списка
```
my_list = [] # Создание пустого списка с помощью литерала списка
my_list = list() # Создание пустого списка с помощью встроенной функции

my_list = [1,2,['a','b'],4,5] # Инициализация списка

my_list = list('hello world') # Создание списка из итерируемого объекта
print(my_list)
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

my_list = [x for x in range(10)] # Генератор списков в действии
print(my_list)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
Доступные методы
* ```my_list.append(x)``` - добавляет x в конец списка
* ```my_list.clear()``` - очищает 
* ```my_list.copy()``` - возвращает копию списка ```my_list```
* ```my_list.count(x)``` - возвращает кол-во элементов со значением x
* ```my_list.extend(x)``` - добавляет элементы списка x к концу списка ```my_list```
* ```my_list.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)
* ```my_list.insert(index, x)``` - вставляет x на заданную позицию
* ```my_list.pop(index)``` - возвращает элемент с указанным индексом и удаляет его, если индекс не указан - возвращается и удаляется последний элемент
* ```my_list.remove(x)``` - удаляет первый элемент со значением x
* ```my_list.reverse()``` - инвертирует порядок элементов в списке
* ```my_list.sort(key=x)``` сортирует список на основе функции x  

В каких случаях использовать?
Для хранения элементов, объединенных каким либо признаком. В случае, если изменение элементов и/или расширение списка не предполагается, следует использовать неизменяемый аналог - кортеж.

_Tuple (кортёж)_
Кортеж - это неизменяемый и более быстрый аналог списка. Он защищает хранимые данные от непреднамеренных изменений и может использоваться в качестве ключа в словарях (словарь - ассоциативный массив в python).

Создание кортежа.
```
my_tuple = () # Создание кортежа с помощью литерала
my_tuple = tuple() # Создание кортежа с помощью встроенной функции

my_tuple = (1,2,['a','b'],4,5) # Инициализация кортежа

my_tuple = tuple('hello world') # Создание кортежа из итерируемого объекта
print(my_tuple)
('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')

my_tuple = tuple(2**x for x in [0, 1, 2, 3]) # Генератор кортежей
print(my_tuple)
(1, 2, 4, 8)
```
Доступные методы
* ```my_tuple.count(x)``` - возвращает кол-во элементов со значением x
* ```my_tuple.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)  

В каких случаях использовать?
Для хранения данных вместо списка (если они не предполагают изменений).

_Set (множество)_
Множество - это набор уникальных элементов в случайном порядке (неупорядоченный список). Множества примечательны тем, что операция проверки "принадлежит ли объект множеству" происходит значительно быстрее аналогичных операций в других структурах данных.

Создание множества
```
my_something = {} # !!! Попытка создать множество при помощи литерала даст нам словарь
type(my_something)
<class 'dict'> 

my_set = set() # Создание при помощи встроенной функции

my_set = {1,2,3,4,5} # Инициализация множества

my_set = set('hello world') # Создания множества из итерируемого объекта
print(my_set)
{'r', 'o', 'e', 'h', 'd', 'w', 'l', ' '}

my_set = {x for x in range(10)} # Генератор множеств
print(my_set)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```
Доступные методы
* ```my_set.add(x)``` - добавляет x во множество
* ```my_set.difference(x)``` - возвращает множество элементов ```my_set```, которые не входят во множество ```x```
* ```my_set.difference_update(x)``` - удаляет из множества my_set все элементы, которые входят во множество ```x```
* ```my_set.discard(x)``` - удаляет элемент ```x``` из ```my_set```
* ```my_set.intersection(x)``` - возвращает элементы общие для множеств ```my_set``` и ```x```
* ```my_set.intersection_update(x)``` - удаляет из множества ```my_set``` элементы, которых нет во множестве ```x```
* ```my_set.isdisjoint(x)``` - возвращает ```true``` если ```my_set``` и ```x``` не содержат одинаковых значений
* ```my_set.issubset(x)``` - возвращает true если все элементы ```my_set``` входят во множество ```x```
* ```my_set.issuperset(x)``` - возвращает ```true``` если все элементы x входят во множество ```my_set```
* ```my_set.pop()``` - возвращает и удаляет первый (на данный момент) элемент множества
* ```my_set.remove(x)``` - удаляет ```x``` из множества
* ```my_set.symmetric_difference(x)``` - возвращает все элементы из ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.symmetric_difference_update(x)``` - обновляет исходное множество таким образом, что оно будет состоять из всех элементов ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.union(x)``` - возвращает новое множество, состоящее из всех элементов ```x``` и ```my_set```
* ```my_set.update(x)``` - добавляет в ```my_set``` все элементы ```x``` 

В каких случаях использовать?
Когда необходимо проверять принадлежит ли значение набору уникальных элементов и отсутствует необходимость поддерживать порядок в данном наборе.

## GIL
<a id="GIL"></a>

* [Что такое GIL?](#what-is-GIL)  
* [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
* [Разница между потоками и процессами](#difference-between-threads-and-processes)  
* [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
* [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  

([наверх](#sections))

### Что такое GIL?
<a id="what-is-GIL"></a>

В Python используется глобальная блокировка интерпретатора (Global Interpreter Lock — GIL), накладывающая некоторые ограничения на потоки. А именно, нельзя использовать несколько процессоров одновременно. Блокировка, позволяет только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток. Из этого следует, что с потоками невозможно использовать несколько ядер процессора.

GIL был введен в Python потому, что управление памятью CPython не является потокобезопасным. Имея такую блокировку Python может быть уверен, что никогда не будет условий гонки. (об условиях гонки в следующем разделе)

Во многопоточных программах отсутствие GIL может негативно сказываться на производительности процессоро-зависымых программ.

![image](https://user-images.githubusercontent.com/54559853/127723378-17c5daa9-46c0-4a24-b493-de66914bd3b1.png)  

Python подсчитывает количество ссылок для корректного управления памятью. Это означает, что созданные в Python объекты имеют переменную подсчёта ссылок, в которой хранится количество всех ссылок на этот объект. Как только эта переменная становится равной нулю, память, выделенная под этот объект, освобождается.

### Многопоточные и многопроцессорные программы в python
<a id="multithreaded-and-multiprocessing-programs-in-python"></a>
([наверх](#sections))

Параллелизм дает возможность работать над несколькими вычислениями одновременно в одной программе. Такого поведения в Python можно добиться несколькими способами:  
* Используя многопоточность ```threading```, позволяя нескольким потокам работать по очереди.  
* Используя несколько ядер процессора ```multiprocessing```. Делать сразу несколько вычислений, используя несколько ядер процессора. Это и называется параллелизмом.  
* Используя асинхронный ввод-вывод с модулем ```asyncio```. Запуская какую то задачу, продолжать делать другие вычисления, вместо ожидания ответа от сетевого подключения или от операций чтения/записи.  

### Разница между потоками и процессами
<a id="difference-between-threads-and-processes"></a>
([наверх](#sections))

Поток ```threading``` - это независимая последовательность выполнения каких то вычислений. Поток ```thread``` делит выделенную память ядру процессора, а так же его процессорное время со всеми другими потоками, которые создаются программой в рамках одного ядра процессора. Программы на языке Python имеют, по умолчанию, один основной поток. Можно создать их больше и позволить Python переключаться между ними. Это переключение происходит очень быстро и кажется, что они работают параллельно.

Понятие процесс в ```multiprocessing``` - представляет собой так же независимую последовательность выполнения вычислений. В отличие от потоков threading, процесс имеет собственное ядро и следовательно выделенную ему память, которое не используется совместно с другими процессами. Процесс может клонировать себя, создавая два или более экземпляра в одном ядре процессора.

Асинхронный ввод-вывод не является ни потоковым (```threading```), ни многопроцессорным (```multiprocessing```). По сути, это однопоточная, однопроцессная парадигма и не относится к параллельным вычислениям.

### Что такое условия гонки и потокобезопасность?
<a id="what-are-race-conditions-and-thread-safety"></a>
([наверх](#sections))

* Состояние гонки возникает, когда несколько потоков могут одновременно получать доступ к общей структуре данных или местоположению в памяти и изменять их, в следствии чего могут произойти непредсказуемые вещи.
  
  Если два пользователя одновременно редактируют один и тот же документ онлайн и второй пользователь сохранит данные в базу, то перезапишет работу первого пользователя. Чтобы избежать условий гонки, необходимо заставить второго пользователя ждать, пока первый закончит работу с документом и только после этого разрешить второму пользователю открыть и начать редактировать документ.

* Потокобезопасность работает путем создания копии локального хранилища в каждом потоке, чтобы данные не сталкивались с другим потоком.

### Алгоритм планирования доступа потоков к общим данным
<a id="algorithm-for-scheduling-access-of-streams-to-shared-data"></a>
([наверх](#sections))

Потоки используют одну и ту же выделенную память. Когда несколько потоков работают одновременно, то нельзя угадать порядок, в котором потоки будут обращаются к общим данным. Результат доступа к совместно используемым данным зависит от алгоритма планирования. который решает, какой поток и когда запускать. Если такого алгоритма нет, то конечные данные могут быть не такими как ожидаешь.

## GC
<a id="GC"></a>

* [Как в питоне обстоят дела с памятью (управлением памятью)](#memory-management-in-python)  
* [Сколько стоит проверка элемента в нотации?](#how-much-does-it-cost-to-validate-an-element-in-notation)  
* [Если есть два объекта и они указывают друг на друга](#two-objects)  

([наверх](#sections))

### Как в питоне обстоят дела с памятью (управлением памятью)
<a id="memory-management-in-python"></a>

### Сколько стоит проверка элемента в нотации?
<a id="how-much-does-it-cost-to-validate-an-element-in-notation"></a>
([наверх](#sections))

### Если есть два объекта и они указывают друг на друга
<a id="two-objects"></a>
([наверх](#sections))

## Итераторы, декораторы и генераторы
<a id="Iterators-decorators-and-generators"></a>
([наверх](#sections))

* [Что такое итератор?](#what-is-iterator)  
* [СЧто такое декоратор?](#what-is-decorator)  
* [Какие декораторы стандартной библиотеки вы знаете?](#standard-library-decorators) 
* [Что такое генератор?](what-is-generator)
* [Что такое list comprehension, какой синтаксис создания генераторов?](list-comprehension)
* [Является ли range итератором?](is-range-an-iterator)

([наверх](#sections))

### Что такое итератор?
<a id="what-is-iterator"></a>

### Что такое декоратор?
<a id="what-is-decorator"></a>
([наверх](#sections))

### Какие декораторы стандартной библиотеки вы знаете?
<a id="standard-library-decorators"></a>
([наверх](#sections))

### Что такое генератор?
<a id="what-is-generator"></a>
([наверх](#sections))

### Что такое list comprehension, какой синтаксис создания генераторов?
<a id="list-comprehension"></a>
([наверх](#sections))

### Является ли range итератором?
<a id="is-range-an-iterator"></a>
([наверх](#sections))

## Алгоритмы
<a id="Algorithms"></a>

## Хранение данных
<a id="Data-storage"></a>

**Что такое json?**

**Что такое csv?**

**Что такое XML?**

<br/>

# Базы данных
<a id="Database"></a>

## Что такое СУБД?

Чтобы правильно обрабатывать различные запросы (поиск, изменение, удаление и т.д) в базу данных, нужно специальное программное обеспечение, такое ПО получило название системы управления базами данных (СУБД).

СУБД — это общий термин, относящийся ко всем видам абсолютно разных инструментов, от компьютерных программ до встроенных библиотек. Эти приложения управляют или помогают управлять наборами данных. Так как эти данные могут быть разного формата и размера, были созданы разные виды СУБД.

СУБД основаны на моделях баз данных — определённых структурах для обработки данных. Каждая СУБД создана для работы с одной из них с учётом особенностей операций над информацией.

Хотя решений, реализующих различные модели баз данных, очень много, периодически некоторые из них становятся очень популярными и используются на протяжении многих лет. Сейчас самой популярной моделью является реляционная система управления базами данных (РСУБД).

## Какие типы СУБД в соответствии с моделями данных вы знаете?

* Реляционные, которые поддерживают установку связей между таблицами с помощью первичных и внешних ключей. Пример — MySQL.
* Flat File — базы данных с двумерными файлами, в которых содержатся записи одного типа и отсутствует связь с другими файлами, как в реляционных. Пример — Excel.
* Иерархические подразумевают наличие записей, связанных друг с другом по принципу отношений один-к-одному или один-ко-многим. А вот для отношений многие-ко-многим следует использовать реляционную модель. Пример — Adabas.
* Сетевые похожи на иерархические, но в этом случае «ребёнок» может иметь несколько «родителей» и наоборот. Примеры — IDS и IDMS.
* Объектно-ориентированные СУБД работают с базами данных, которые состоят из объектов, используемых в ООП. Объекты группируются в классы и называются экземплярами, а классы в свою очередь взаимодействуют через методы. Пример — Versant.
* Объектно-реляционные обладают преимуществами реляционной и объектно-ориентированной моделей. Пример — IBM Db2.
* Многомерная модель является разновидностью реляционной и использует многомерные структуры. Часто представляется в виде кубов данных. Пример — Oracle Essbase.
* Гибридные состоят из двух и более типов баз данных. Используются в том случае, если одного типа недостаточно для обработки всех запросов. Пример — Altibase HDВ.

## Что такое первичный ключ?

Первичный ключ или ```PRIMARY KEY``` предназначен для однозначной идентификации каждой записи в таблице и является строго уникальным (```UNIQUE```): две записи таблицы не могут иметь одинаковые значения первичного ключа. Нулевые значения (```NULL```) в ```PRIMARY KEY``` не допускаются. Если в качестве ```PRIMARY KEY``` используется несколько полей, их называют составным ключом.  
Первичный ключ, используется в качестве основного ключа и может быть использован для связи с дочерней таблицей, содержащей внешний ключ.

Пример:
```
CREATE TABLE USERS (
  id INT NOT NULL,
  name VARCHAR (20) NOT NULL,
  PRIMARY KEY (id)
);
```
Здесь в качестве первичного ключа используется поле id.

## Что такое внешний ключ?

Внешний ключ или ```FOREIGN KEY``` также является атрибутом ограничения и обеспечивает связь двух таблиц. По сути, это поле или несколько полей, которые ссылаются на ```PRIMARY KEY``` в родительской таблице.

Пример использования:
```
CREATE TABLE order (
  order_id INT NOT NULL,
  user_id INT,
  PRIMARY KEY (order_id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```
В данном случае внешний ключ, привязанный к полю ```user_id``` в таблице ```order```, ссылается на первичный ключ ```id``` в таблице ```users```, и именно по этим полям происходит связывание двух таблиц.

## Ограничения в SQL

SQL-ограничения (constraints) указываются при создании или изменении таблицы. Это правила для ограничения типа данных, которые могут храниться в таблице. Действие с данными не будет выполнено, если нарушаются установленные ограничения.

* ```UNIQUE``` — гарантирует уникальность значений в столбце;
* ```NOT NULL``` — значение не может быть ```NULL```;
* ```INDEX``` — создаёт индексы в таблице для быстрого поиска/запросов;
* ```CHECK``` — значения столбца должны соответствовать заданным условиям;
* ```DEFAULT``` — предоставляет столбцу значения по умолчанию.

## Что такое Self JOIN?

Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные таблицы. Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.

Следующий SQL-запрос объединяет клиентов из одного города:
```
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City
ORDER BY A.City;
```
## Подстановочные знаки

Это специальные символы, которые нужны для замены каких-либо знаков в запросе. Они используются вместе с оператором ```LIKE```, с помощью которого можно отфильтровать запрашиваемые данные.

% — заменить ноль или более символов;
_ — заменить один символ.
Примеры:
```
SELECT * FROM user WHERE name LIKE '%test%';
```
Данный запрос позволяет найти данные всех пользователей, имена которых содержат в себе «test».
```
SELECT * FROM user WHERE name LIKE 't_est';
```
В этом случае имена искомых пользователей начинаются на «t», после содержат какой-либо символ и «est» в конце.

## Что делают псевдонимы Aliases?

SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу. Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами. В этом случае для удобства в составлении запроса используются псевдонимы. SQL-псевдоним существует только на время запроса.

Пример:
```
SELECT very_long_column_name AS alias_name
FROM table;
```
## Разница между командами DELETE и TRUNCATE

Команда ```DELETE``` — это DML-операция, которая удаляет записи из таблицы, соответствующие заданному условию:

```DELETE FROM table_name WHERE condition;```
При этом создаются логи удаления, то есть операцию можно отменить.

А вот команда ```TRUNCATE``` — это DDL-операция, которая полностью пересоздаёт таблицу, и отменить такое удаление невозможно:

```TRUNCATE TABLE table_name;```

DML (Data Manipulation Language) - язык манипулирования данными. Язык DML позволяет осуществлять манипуляции с данными таблиц, т.е. с ее строками. Он позволяет делать выборку данных из таблиц, добавлять новые данные в таблицы, а так же обновлять и удалять существующие данные.  

DDL (Data Definition Language) - язык описания данных. Язык DDL служит для создания и модификации структуры БД, т.е. для создания/изменения/удаления таблиц и связей.

## Основные команды SQL

* ```SHOW DATABASES```  

  SQL-команда, которая отвечает за просмотр доступных баз данных.
  
* ```CREATE DATABASE```  
  
  Команда для создания новой базы данных.
  
* ```USE```  

  С помощью этой SQL-команды ```USE <database_name>``` выбирается база данных, необходимая для дальнейшей работы с ней.
  
* ```SOURCE```  

  ```SOURCE <file.sql>``` позволит выполнить сразу несколько SQL-команд, содержащихся в файле с расширением .sql.
  
* ```DROP DATABASE```  
  
  Стандартная SQL-команда для удаления целой базы данных.
  
* ```DROP TABLE```  

  Так можно удалить всю таблицу целиком.  
  
* ```DELETE```  

  SQL-команда ```DELETE FROM <table_name>``` используется для удаления данных из таблицы.
  
* ```SHOW TABLES```  

  С помощью этой команды можно увидеть все таблицы, которые доступны в базе данных.
  
* ```DESCRIBE```  
  
  С помощью ```DESCRIBE <table_name>``` можно просмотреть различные сведения (тип значений, является ключом или нет) о столбцах таблицы.
  
* ```CREATE TABLE```
  SQL-команда для создания новой таблицы:
  ```
  CREATE TABLE <table_name1> (
    <col_name1><col_type1>,
    <col_name2><col_type2>,
    <col_name3><col_type3>
    PRIMARY KEY(<col_name1>),
    FOREIGN KEY(<col_name2>) REFERENCES <table_name2>(<col_name2>)
  );
  ```
  Ограничения целостности при использовании ```CREATE TABLE```  
  Может понадобиться создать ограничения для определённых столбцов в таблице. При создании таблицы можно задать следующие ограничения:

  * ячейка таблицы не может иметь значение ```NULL```;
  * первичный ключ — ```PRIMARY KEY(col_name1, col_name2, …)```;
  * внешний ключ — ```FOREIGN KEY(col_namex1, …, col_namexn) REFERENCES table_name(col_namex1, …, col_namexn)```.  
  
  Можно задать больше одного первичного ключа. В этом случае получится составной первичный ключ.

  Пример
  Создайте таблицу «instructor»:
```
  CREATE TABLE instructor (
    ID CHAR(5),
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    salary NUMERIC(8,2),
    PRIMARY KEY (ID),
    FOREIGN KEY (dept_name) REFERENCES department(dept_name)
  );
```

* UNION  

  Он используется для объединения полученных данных из двух или более запросов, которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в   том же порядке.  

  Пример использования:
  ```
  SELECT column(s) FROM first_table
  UNION
  SELECT column(s) FROM second_table;
  ```
  
* ```INSERT```  

  Команда ```INSERT INTO <table_name>``` в SQL отвечает за добавление данных в таблицу:
  ```
  INSERT INTO <table_name> (<col_name1>, <col_name2>, <col_name3>, …)
    VALUES (<value1>, <value2>, <value3>, …); 
  ```
  При добавлении данных в каждый столбец таблицы не требуется указывать названия столбцов.
  ```
  INSERT INTO <table_name>
    VALUES (<value1>, <value2>, <value3>, …);
  ```
  
* ```UPDATE```  

  SQL-команда для обновления данных таблицы:
  ```
  UPDATE <table_name>
    SET <col_name1> = <value1>, <col_name2> = <value2>, ...
    WHERE <condition>;
  ```
  
* ```SELECT```  
  
  ```SELECT``` используется для получения данных из выбранной таблицы:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>; 
  ```
  Следующей командой можно вывести все данные из таблицы:
  ```
  SELECT * FROM <table_name>;
  ```
  
* ```SELECT DISTINCT```
 
  В столбцах таблицы могут содержаться повторяющиеся данные. ```SELECT DISTINCT``` используется для получения только неповторяющихся данных.
  ```
  SELECT DISTINCT <col_name1>, <col_name2>, …
    FROM <table_name>; 
  ```

* ```WHERE```  
  
  Можно использовать ключевое слово ```WHERE``` в ```SELECT``` для указания условий в запросе:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <condition>; 
  ```
  В запросе можно задавать следующие условия:

  сравнение текста;
  сравнение численных значений;
  логические операции AND (и), OR (или) и NOT (отрицание).
  Пример:
  ```
  SELECT * FROM table WHERE author='Достоевский';
  SELECT * FROM table WHERE price>3000;
  SELECT * FROM table WHERE amount=10; 
  ```
  
* ```GROUP BY```  
  
  Оператор ```GROUP BY``` часто используется с агрегатными функциями, такими как ```COUNT```, ```MAX```, ```MIN```, ```SUM``` и ```AVG```, для группировки выходных значений.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    GROUP BY <col_namex>; 
  ```
  Пример
  Выведем количество курсов для каждого факультета:
  ```
  SELECT COUNT(course_id), dept_name
    FROM course
    GROUP BY dept_name; 
  ```
  
* ```HAVING```  
  
  Ключевое слово ```HAVING``` было добавлено в SQL по той причине, что ```WHERE``` не может использоваться для работы с агрегатными функциями.
  ```
  SELECT <col_name1>, <col_name2>, ...
    FROM <table_name>
    GROUP BY <column_namex>
    HAVING <condition> 
  ```
  Пример
  Выведем список факультетов, у которых более одного курса:
  ```
  SELECT COUNT(course_id), dept_name
    FROM course
    GROUP BY dept_name
    HAVING COUNT(course_id)>1; 
  ```
  
* ```ORDER BY```  
  
  ```ORDER BY``` используется для сортировки результатов запроса по убыванию или возрастанию. ```ORDER BY``` отсортирует по возрастанию, если не будет указан способ сортировки ```ASC``` или ```DESC```.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    ORDER BY <col_name1>, <col_name2>, … ASC|DESC;
  ```
  Пример
  Выведем список курсов по возрастанию и убыванию количества кредитов:
  ```
  SELECT * FROM course ORDER BY credits;
  SELECT * FROM course ORDER BY credits DESC;
  ```
  
* ```BETWEEN```  

  ```BETWEEN``` используется для выбора значений данных из определённого промежутка. Могут быть использованы числовые и текстовые значения, а также даты.
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namex> BETWEEN <value1> AND <value2>;
  ```
  Пример
  Выведем список инструкторов, чья зарплата больше 50 000, но меньше 100 000:
  ```
  SELECT * FROM instructor
    WHERE salary BETWEEN 50000 AND 100000; 
  ```

* ```LIKE```  

  Оператор ```LIKE``` используется в ```WHERE```, чтобы задать шаблон поиска похожего значения.

  Есть два свободных оператора, которые используются в ```LIKE```:

  % (ни одного, один или несколько символов);
  _ (один символ).
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namex> LIKE <pattern>; 
  ```
  Пример
  Выведем список курсов, в имени которых содержится «to», и список курсов, название которых начинается с «CS-»:
  ```
  SELECT * FROM course WHERE title LIKE ‘%to%’;
  SELECT * FROM course WHERE course_id LIKE 'CS-___';
  ```

* ```IN```  
  
  С помощью ```IN``` можно указать несколько значений для оператора ```WHERE```:
  ```
  SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <col_namen> IN (<value1>, <value2>, …);
  ```
  Пример
  Выведем список студентов с направлений Comp. Sci., Physics и Elec. Eng.:
  ```
  SELECT * FROM student
    WHERE dept_name IN (‘Comp. Sci.’, ‘Physics’, ‘Elec. Eng.’);
  ```
  
* ```JOIN```  

  ```JOIN``` используется для связи двух или более таблиц с помощью общих атрибутов внутри них.
  Чтобы объединить две таблицы в одну, следует использовать оператор ```JOIN```. Соединение таблиц может быть внутренним (```INNER```) или внешним (```OUTER```), причём внешнее соединение может быть левым (```LEFT```), правым (```RIGHT```) или полным (```FULL```).

  * ```INNER JOIN``` — получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.
  * ```FULL OUTER JOIN``` — объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
  * ```LEFT JOIN``` — возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.
  * ```RIGHT JOIN``` — работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.
  ```
  SELECT <col_name1>, <col_name2>, …
  FROM <table_name1>
  JOIN <table_name2>
  ON <table_name1.col_namex> = <table2.col_namex>;
  ```
  Следующий запрос выбирает все заказы с информацией о клиенте:
  ```
  SELECT Orders.OrderID, Customers.CustomerName
  FROM Orders
  INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
  ```
  
* ```VIEW```  
  
  ```VIEW``` — это виртуальная таблица SQL, созданная в результате выполнения выражения. Она содержит строки и столбцы и очень похожа на обычную SQL-таблицу. VIEW всегда показывает самую свежую информацию из базы данных.

  Создание
  ```
  CREATE VIEW <view_name> AS
    SELECT <col_name1>, <col_name2>, …
    FROM <table_name>
    WHERE <condition>;
  ```
  Удаление
  ```
  DROP VIEW <view_name>;
  ```

## Математические функции в SQL

|**Функция**|	**Описание**	|**Пример**|
|:------------------------------|:--------------------------|:--------------------------|
| ```CEILING(x)``` |	возвращает наименьшее целое число, большее или равное x(округляет до целого числа в большую сторону)|```	CEILING(4.2)=5 CEILING(-5.8)=-5```|
| ```ROUND(x, k)``` |	округляет значение x до k знаков после запятой, если k не указано – x округляется до целого	|```ROUND(4.361)=4 ROUND(5.86592,1)=5.9```|
| ```FLOOR(x)``` |	возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)	|```FLOOR(4.2)=4 FLOOR(-5.8)=-6```|
| ```POWER(x, y)``` |	возведение x в степень y	|```POWER(3,4)=81.0```|
| ```SQRT(x)``` |	квадратный корень из x	|```SQRT(4)=2.0 SQRT(2)=1.41...```|
| ```DEGREES(x)``` |	конвертирует значение x из радиан в градусы	|```DEGREES(3) = 171.8...```|
| ```RADIANS(x)``` |	конвертирует значение x из градусов в радианы	|```RADIANS(180)=3.14...```|
| ```ABS(x)``` |	модуль числа x	|```ABS(-1) = 1 ABS(1) = 1```|
| ```PI()``` |	pi = 3.1415926...	 ||
| ```COUNT(col_name)``` | возвращает количество строк||
| ```SUM(col_name)``` | возвращает сумму значений в данном столбце||
| ```AVG(col_name)``` | возвращает среднее значение данного столбца||
| ```MIN(col_name)``` | возвращает наименьшее значение данного столбца||
| ```MAX(col_name)``` | возвращает наибольшее значение данного столбца||

**Оконные функции в SQL**

<br/>

# Статистика
<a id="statistics"></a>
([наверх](#sections))

**Что такое доверительные интервалы?**

**Что такое статистическая значимость?**

<br/>

# Задачи и алгоритмы машинного обучения
<a id="Machine-learning-tasks-and-algorithms"></a>
([наверх](#sections))

## Задачи машинного обучения

### Что такое обучение с учителем?

В данном случае в тренировочном датасете для кажого объекта у нас есть метка или лэйбл. В тестовом - этого лейбла нет и нам нужно его предсказать. 
Бывает два подтипа решения задач с учителем:

* Регрессия

В задачах регрессии меткой является вещественное число.  

Например, если мы предсказываем стоимость квартиры, то это будет задача регрессии.

* Классификация

В данном случае мы предсказываем не вещественное число, а конечно подмножество классов.  
Если таких классов два, то это задача бинарной классификации.
Если больше двух, то это многоклассовая классификация.  

Например, если мы предсказываем есть на фотографии машина или нет, то это задача бинарной классификации, потому-что у нас в данном случае два класса (либо машина есть, либо её нет)

### Что такое обучение без учителя?

В данном случае у нас нет лейблов для объектов, и мы не пытаемся их предсказать.  
Бывает несколько подтипов решения задач без учителя:

* Кластеризация

В данном случае попытаемся выявить некоторые паттерны в данных и объединить их в кластеры. Так, чтобы в одном кластере были похожие объекты, а в разных кластерах они были разные.  

Например, мы хотим разбить фильмы по жанрам и мы не знаем какие у нас жанры есть, мы хотим понять чем они отличаются друг от друга и на какое количество кластеров их хорошо разбить.

* Задача понижения размерности  

В данном случае мы хотим вектора большой размерности ужать до меньшей, при этом сохранить как можно больше информации

* Визуализация

Уменьшаем размерность до состояния, когда её можно визуализировать

### Что такое классификация?

Классификация — один из разделов машинного обучения, посвященный решению следующей задачи. Имеется множество объектов (ситуаций), разделённых некоторым образом на классы. Задано конечное множество объектов, для которых известно, к каким классам они относятся. Это множество называется обучающей выборкой. Классовая принадлежность остальных объектов не известна. Требуется построить алгоритм, способный классифицировать произвольный объект из исходного множества.  

Классифицировать объект — значит, указать номер (или наименование класса), к которому относится данный объект.  

Классификация объекта — номер или наименование класса, выдаваемый алгоритмом классификации в результате его применения к данному конкретному объекту.  

В математической статистике задачи классификации называются также задачами дискриминантного анализа.

В машинном обучении задача классификации относится к разделу обучения с учителем. Существует также обучение без учителя, когда разделение объектов обучающей выборки на классы не задаётся, и требуется классифицировать объекты только на основе их сходства друг с другом. В этом случае принято говорить о задачах кластеризации или таксономии, и классы называть, соответственно, кластерами или таксонами.

**Типология задач классификации**  
_Типы входных данных_
* Признаковое описание — наиболее распространённый случай. Каждый объект описывается набором своих характеристик, называемых признаками. Признаки могут быть числовыми или нечисловыми.  
* Матрица расстояний между объектами. Каждый объект описывается расстояниями до всех остальных объектов обучающей выборки. С этим типом входных данных работают немногие методы, в частности, метод ближайших соседей, метод парзеновского окна, метод потенциальных функций.  
* Временной ряд или сигнал представляет собой последовательность измерений во времени. Каждое измерение может представляться числом, вектором, а в общем случае — признаковым описанием исследуемого объекта в данный момент времени.  
* Изображение или видеоряд.  
* Встречаются и более сложные случаи, когда входные данные представляются в виде графов, текстов, результатов запросов к базе данных, и т. д. Как правило, они приводятся к первому или второму случаю путём предварительной обработки данных и извлечения признаков.  
Классификацию сигналов и изображений называют также распознаванием образов.

_Типы классов_
* Двухклассовая классификация. Наиболее простой в техническом отношении случай, который служит основой для решения более сложных задач.  
* Многоклассовая классификация. Когда число классов достигает многих тысяч (например, при распознавании иероглифов или слитной речи), задача классификации становится существенно более трудной.  
* Непересекающиеся классы.  
* Пересекающиеся классы. Объект может относиться одновременно к нескольким классам.  
* Нечёткие классы. Требуется определять степень принадлежности объекта каждому из классов, обычно это действительное число от 0 до 1.  

### Что такое кластеризация?

### Что такое понижение размерности?

## Алгоритмы машинного обучения

### Линейная регрессия

Алгоритм для задачи регрессии. Он предсказывает вещественное число, позволяет описывать линейную или биномиальную зависимость.  
Обучение происходит с помощью минимизации функции потерь, может быть две функции потерь.

Средняя квадратичная ошибка:  

<img src="https://render.githubusercontent.com/render/math?math=MSE = \Sigma_{i=1}^{n}(y_i - y_i^p)^2">

Средняя абсолютная ошибка:  

<img src="https://render.githubusercontent.com/render/math?math=MAE = \Sigma_{i=1}^{n} \left| y_i - y_i^p \right |">

Обучение происходит с помощью градиентного спуска, также возможно аналитическое решение этой задачи с помощью нахождения обратной матрицы. Но в реальноси оно не применятся, так как требует значительных вычислительных ресурсов, а также не для всех матриц можно найти обратную.

### Логистическая регрессия

Это алгоритм для задачи классификации. Отличается от линейной регресси тем, что тут есть функция активации. 

Для задач бинарной классификации используется сигмоида.  
Для задач многоклассовой классификации используется функция Softmax:  

<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ab3ef6ba51afd36c1d2baf06540022053b2dca73">

Функции потерь тоэе отличаются:  
Для задач бинарной классификации - это LogLoss:  

<img src="https://alexanderdyakonov.files.wordpress.com/2018/03/log_loss_23.png">  

Для задач многоклассовой классификации - это categorical cross entropy

## Обучение с помощью градиентного спуска

Сначала инициализируются веса модели. 

## Алгоритмы кластеризации такие как k-means и c-means, dbscan

## Иерархическая кластеризация

## Алгоритмы понижения размерности такие как PCA, t-SNE

## Алгоритмы для нейронных сетей

## Полносвязная нейронная сеть

## Свёрточная нейронная сеть

## Рекуррентная нейронная сеть

## Для каких задач подходит тот или иной алгоритм?

### Что такое градиент и для чего он нужен?

### Что такое функция активации?

<br/>

# Сеть
<a id="network"></a>

* [Что такое веб-сервисы?](#web-services)
* [REST](#rest)  
* [http](#http)
* [JSON](#json)
* [XML](#xml)
* [Очереди сообщений](#message-queues)
* [Что происходит в тот момент, когда вы вводите в адресной строке браузера URL сайта и нажимаете ввод?](#www)

## Что такое веб-сервисы?
<a id="web-services"></a>

Веб-сервисы (или веб-службы) — это технология, позволяющая системам обмениваться данными друг с другом через сетевое подключение. Обычно веб-сервисы работают поверх протокола HTTP или протокола более высокого уровня. Веб-сервис — просто адрес, ссылка, обращение к которому позволяет получить данные или выполнить действие.

Главное отличие веб-сервиса от других способов передачи данных: стандартизированность. Приняв решение использовать веб-сервисы, можно сразу переходить к структуре данных и доступным функциям. Например, В SOAP (как более строгом протоколе), уже решён вопрос уведомления об ошибках.

Самые известные способы реализации веб-сервисов:

* XML-RPC (XML Remote Procedure Call) — протокол удаленного вызова процедур с использованием XML. Прародитель SOAP. Предельно прост в реализации.

* SOAP (Simple Object Access Protocol) — стандартный протокол по версии W3C. Четко структурирован и задокументирован.

* JSON-RPC (JSON Remote Procedure Call) — более современный аналог XML-RPC. Основное отличие — данные передаются в формате JSON.

* REST (Representational State Transfer) — архитектурный стиль взаимодействия компьютерных систем в сети основанный на методах протокола HTTP.

* Специализированные протоколы для конкретного вида задач, такие как GraphQL.

* Менее распространенный, но более эффективный gRPC, передающий данные в бинарном виде и использующий HTTP/2 в качестве транспорта.

## REST
<a id="rest"></a>

REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем, таких как World Wide Web, который, как правило, используется для построения веб-служб (набор рекомендаций, который позволяет унифицировать взаимодействие клиентских и серверных приложений). Термин REST был введен в 2000 году Роем Филдингом, одним из авторов HTTP-протокола. Системы, поддерживающие REST, называются RESTful-системами. Единого стандарта у него нет — не протокол, а целый архитектурный стиль. Этим она отличается от многих аналогичных. При этом допустимо использовать XML, HTTP, JSON и URL.

REST не использует конвертацию данных при передаче, данные передаются в исходном виде — это снижает нагрузку на клиент веб-сервиса, но увеличивает нагрузку на сеть. Управление данными происходит с помощью методов HTTP:

GET — получить данные;

POST — добавить данные;

PUT — изменить данные;

DELETE — удалить данные.


В качестве пакета обычно отправляется JSON массив на указанный конкретный URL. Там срабатывает так называемая функция, а в зависимости от уже отправленных данных и текущего запроса начинается определенное действие.

Использование этих методов позволяет реализовать типичный CRUD (Create/Read/Update/Delete) для любой информации. Но это лишь соглашение: часто используются только 2 метода: GET для получения и POST для всего остального. Разобраться поможет такое понятие, как REST-Patterns . Паттерны связывают HTTP методы с тем, что они делают.

Преимущества:

* простота реализации;

* экономичность в плане ресурсов;

* не требует программных надстроек (json_decode есть почти в каждом языке).

Недостатки:

* отсутствие спецификации;

* неоднозначность методов управления данными.

Протокол по типу концентрированного REST API, работающий по HTTP = качественным веб-сервисам  

Так можно назвать веб-приложение, которое представляет ресурсы в формате, подходящем для других компьютеров. Они включают в себя разные интерфейсы.

Те варианты, которые применяются для транслирования, тоже можно учитывать как «веб-сервисы». Клиент, который пользуется этим, способен запросить все что угодно, а сервер ему отвечает и предоставляет результаты. Задействуют любой удобный язык программирования или подходящие платформы. Не имеет никакого значения, какой конкретно использовался, так как все выполняется через общий тип.

Когда API документируется, то неважно, чем пользовались разработчики при его создании — Ruby это был, Java или Python или что-то принципиально другое. Все запросы высылаются через один и тот же HTTP, решения приходят таким же способом.

## JSON
<a id="json"></a>

JSON это сокращение от JavaScript Object Notation — формата передачи данных. Как можно понять из названия, JSON произошел из JavaScript, но он доступен для использования на многих других языках, включая Python, Ruby, PHP и Java.  
JSON - один из самых популярных методов обмена данными между сервером и клиентом в Интернет (API и REST)

Сам по себе JSON использует расширение .json. Когда же он определяется в других файловых форматах, как .html, он появляется в кавычках как JSON строка или может быть объектом, назначенным на переменную. Такой формат легко передавать между сервером и клиентской частью, ну или браузером.  
Легкочитаемый и компактный, JSON представляет собой хорошую альтернативу XML и требует куда меньше форматирования контента. Это информативное руководство поможет вам быстрее разобраться с данными, которые вы можете использовать с JSON и основной структурой с синтаксисом этого же формата.

Анализ структура JSON
![Анализ структура JSON](https://habrastorage.org/webt/x6/q_/sg/x6q_sgnunckncpntu5xyf7zeu1i.png)

**Синтаксис и структура**

Объект JSON это формат данных — ключ-значение, который обычно рендерится в фигурных скобках. 

JSON объект:

```
{
  "first_name" : "Sammy",
  "last_name" : "Shark",
  "location" : "Ocean",
  "online" : true,
  "followers" : 987 
}
```
JSON может содержать другие вложенные объекты в JSON, в дополнение к вложенным массивам. Такие объекты и массивы будут передаваться, как значения назначенные ключам и будут представлять собой связку ключ-значение.

Вынесем имя из первого json объекта и добавим ещё три.
```
{ 
  "sammy" : {
    "username"  : "SammyShark",
    "location"  : "Indian Ocean",
    "online"    : true,
    "followers" : 987
  },
  "jesse" : {
    "username"  : "JesseOctopus",
    "location"  : "Pacific Ocean",
    "online"    : false,
    "followers" : 432
  },
  "drew" : {
    "username"  : "DrewSquid",
    "location"  : "Atlantic Ocean",
    "online"    : false,
    "followers" : 321
  },
  "jamie" : {
    "username"  : "JamieMantisShrimp",
    "location"  : "Pacific Ocean",
    "online"    : true,
    "followers" : 654
  }
}
```

Вложенные массивы
Данные также могут быть вложены в формате JSON, используя JavaScript массивы, которые передаются как значения. JavaScript использует квадратные скобки [ ] для формирования массива. Массивы по своей сути — это упорядоченные коллекции и могут включать в себя значения совершенно разных типов данных.  
Мы можем использовать массив при работе с большим количеством данных, которые могут быть легко сгруппированны вместе, как например, если есть несколько разных сайтов и профайлов в социальных сетях ассоциированных с одним пользователем.

```
{ 
  "first_name" : "Sammy",
  "last_name" : "Shark",
  "location" : "Ocean",
  "websites" : [ 
    {
      "description" : "work",
      "URL" : "https://www.digitalocean.com/"
    },
    {
      "desciption" : "tutorials",
      "URL" : "https://www.digitalocean.com/community/tutorials"
    }
  ],
  "social_media" : [
    {
      "description" : "twitter",
      "link" : "https://twitter.com/digitalocean"
    },
    {
      "description" : "facebook",
      "link" : "https://www.facebook.com/DigitalOceanCloudHosting"
    },
    {
      "description" : "github",
      "link" : "https://github.com/digitalocean"
    }
  ]
}
```

## XML
<a id="xml"></a>

Начнём с сравнения с JSON

XML расшифровывается как eXtensible Markup Language. Это способ хранения данных, которые могут быть прочитаны как людьми, так и машинами. Формат XML доступен для использования во многих языках программирования.  
Во многих случаях, XML очень схож с JSON. XML должен быть спарсен с XML парсером, но JSON может быть спарсен стандартным функционалом. Так же, в отличие от JSON, XML не может использовать массивы.
```
<users>
    <user>
        <username>SammyShark</username> <location>Indian Ocean</location>
    </user>
    <user>
        <username>JesseOctopus</username> <location>Pacific Ocean</location>
    </user>
    <user>
        <username>DrewSquir</username> <location>Atlantic Ocean</location>
    </user>
    <user>
        <username>JamieMantisShrimp</username> <location>Pacific Ocean</location>
    </user>
</users>
```

А вот это уже формат JSON:
```
{"users": [
  {"username" : "SammyShark", "location" : "Indian Ocean"},
  {"username" : "JesseOctopus", "location" : "Pacific Ocean"},
  {"username" : "DrewSquid", "location" : "Atlantic Ocean"},
  {"username" : "JamieMantisShrimp", "location" : "Pacific Ocean"}
] }
```
Простейший XML-документ выглядит следующим образом:
```
<?xml version="1.0" encoding="windows-1251"?>
<book category="WEB">
   <title lang="en">Learning XML</title>
   <author>Erik T. Ray</author>
   <year>2003</year>
   <price></price>
</book>
```

Первая строка — это XML декларация. Здесь определяется версия XML (1.0) и кодировка файла. На следующей строке описывается корневой элемент документа ```<book>``` (открывающий тег). Следующие 4 строки описывают дочерние элементы корневого элемента (```title```, ```author```, ```year```, ```price```). Последняя строка определяет конец корневого элемента ```</book>``` (закрывающий тег).

Документ XML состоит из элементов (elements). Элемент начинается открывающим тегом (start-tag) в угловых скобках, затем идет содержимое (content) элемента, после него записывается закрывающий тег (end-teg) в угловых скобках.

Информация, заключенная между тегами, называется содержимым или значением элемента: ```<author>Erik T. Ray</author>```. Т.е. элемент ```author``` принимает значение ```Erik T. Ray```. Элементы могут вообще не принимать значения.

Элементы могут содержать атрибуты, так, например, открывающий тег ```<title lang="en">``` имеет атрибут ```lang```, который принимает значение ```en```. Значения атрибутов заключаются в кавычки (двойные или ординарные).

Некоторые элементы, не содержащие значений, допустимо записывать без закрывающего тега. В таком случае символ ```/``` ставится в конце открывающего тега:

```<name first="Иван" second="Петрович" />```

**Структура XML**  

XML документ должен содержать корневой элемент. Этот элемент является «родительским» для всех других элементов.

Все элементы в XML документе формируют иерархическое дерево. Это дерево начинается с корневого элемента и разветвляется на более низкие уровни элементов.

Все элементы могут иметь подэлементы (дочерние элементы):

```
<корневой>
   <потомок>
     <подпотомок>.....</подпотомок>
   </потомок>
</корневой>
```

**Правила синтаксиса (Валидность)**  

Структура XML документа должна соответствовать определенным правилам. XML документ отвечающий этим правилам называется валидным (англ. Valid — правильный) или синтаксически верным. Соответственно, если документ не отвечает правилам, он является невалидным .

Основные правила синтаксиса XML:

1. Теги XML регистрозависимы — теги XML являются регистрозависимыми. Так, тег ```<Letter>``` не то же самое, что тег ```<letter>```.

Открывающий и закрывающий теги должны определяться в одном регистре:
```
<Message>Это неправильно</message>
<message>Это правильно</message>
```

2. XML элементы должны соблюдать корректную вложенность:
```
<b><i>Некорректная вложенность</b></i>
<b><i>Корректная вложенность</i></b>
```

3. У XML документа должен быть корневой элемент — XML документ должен содержать один элемент, который будет родительским для всех других элементов. Он называется корневым элементом.

4. Значения XML атрибутов должны заключаться в кавычки:

```
<note date="12/11/2007">Корректная запись</note>
<note date=12/11/2007>Некорреткная запись</note>
```

**Сущности**  

Некоторые символы в XML имеют особые значения и являются служебными. Если вы поместите, например, символ ```<``` внутри XML элемента, то будет сгенерирована ошибка, так как парсер интерпретирует его, как начало нового элемента.

В примере ниже будет сгенерирована ошибка, так как в значении ```"ООО<Мосавтогруз>"``` атрибута ```НаимОрг``` содержатся символы ```<``` и ```>```.  
```
<НПЮЛ ИННЮЛ="7718962261" КПП="771801001" НаимОрг="ООО<Мосавтогруз>"/>
```
Также ошибка будет сгенерирована и в слудющем примере, если название организации взять в обычные кавычки (английские двойные):
```
<НПЮЛ ИННЮЛ="7718962261" КПП="771801001" НаимОрг="ООО"Мосавтогруз""/>
```
Чтобы ошибки не возникали, нужно заменить символ ```<``` на его сущность. В XML существует 5 предопределенных сущностей:

| *Сущность*     | *Символ*      | *Значение*|
|:------------:|:--------------:| :---:|
| ```&lt;```        | 	<	        | меньше, чем |
| ```&gt;```        | 	>         | больше, чем |
| ```&amp;```        | 	&      | амперсанд|
| ```&apos;```     | 	'        | апостроф |
| ```&quot;```        | 	"        | кавычки |

Таким образом, корректными будут следующие формы записей:
``` 
<НПЮЛ ИННЮЛ="7718962261" КПП="771801001" НаимОрг="ООО&quot;Мосавтогруз&quot;"/>
``` 
или
``` 
<НПЮЛ ИННЮЛ="7718962261" КПП="771801001" НаимОрг="ООО«Мосавтогруз»"/>
``` 
В последнем примере английские двойные кавычки заменены на французские кавычки («ёлочки»), которые не являются служебными символами.

**XSD схема**  

XML Schema — язык описания структуры XML-документа, его также называют XSD. Как большинство языков описания XML, XML Schema была задумана для определения правил, которым должен подчиняться документ. Но, в отличие от других языков, XML Schema была разработана так, чтобы её можно было использовать в создании программного обеспечения для обработки документов XML.

После проверки документа на соответствие XML Schema читающая программа может создать модель данных документа, которая включает:

словарь (названия элементов и атрибутов);
модель содержания (отношения между элементами и атрибутами и их структура);
типы данных.
Каждый элемент в этой модели ассоциируется с определённым типом данных, позволяя строить в памяти объект, соответствующий структуре XML-документа. Языкам объектно-ориентированного программирования гораздо легче иметь дело с таким объектом, чем с текстовым файлом.

Простой пример схемы на XML Schema, расположенной в файле "country.xsd" и описывающей данные о населении страны:

``` 
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="country">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="country_name" type="xs:string"/>
        <xs:element name="population" type="xs:decimal"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
``` 
Пример документа, соответствующего этой схеме:

``` 
<?xml version="1.0" encoding="utf-8"?>
<country>
    <country_name>France</country_name>
    <population>59.7</population>
</country>
``` 

## http
<a id="http"></a>

HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser). Полученный итоговый документ будет (может) состоять из различных поддокументов, являющихся частью итогового документа: например, из отдельно полученного текста, описания структуры документа, изображений, видео-файлов, скриптов и многого другого.

Когда мы вводим в браузере URL-адрес, например www.google.com, на сервер отправляется запрос на веб-сайт, идентифицированный URL-адресом.
Затем этот сервер формирует и выдает ответ. Важным является формат этих запросов и ответов. Эти форматы определяются протоколом HTTP — Hyper Text Transfer Protocol.

Когда мы набираем URL в браузере, он отправляет запрос GET на указанный сервер. Затем сервер отвечает HTTP-ответом, который содержит данные в формате HTML — Hyper Text Markup Language. Затем браузер получает этот HTML-код и отображает его на экране.

Допустим, мы заполняем форму, присутствующую на веб-странице, со списком элементов. В таком случае, когда мы нажимаем кнопку «Submit» (Отправить), HTTP-запрос POST отправляется на сервер.

HTTP — это клиент-серверный протокол, то есть запросы отправляются какой-то одной стороной — участником обмена (user-agent) (либо прокси вместо него). Чаще всего в качестве участника выступает веб-браузер, но им может быть кто угодно, например, робот, путешествующий по Сети для пополнения и обновления данных индексации веб-страниц для поисковых систем.

Каждый запрос (англ. request) отправляется серверу, который обрабатывает его и возвращает ответ (англ. response). Между этими запросами и ответами как правило существуют многочисленные посредники, называемые прокси, которые выполняют различные операции и работают как шлюзы или кеш, например.

## Очереди сообщений
<a id="message-queues"></a>

**Sync vs Async: синхронное и асинхронное взаимодействие**

Очереди сообщений (Message Queue) — это форма асинхронной коммуникации между сервисами. Поэтому, прежде чем говорить о них, покажем на упрощенном, немного искусственном примере разницу между синхронным и асинхронным взаимодействием.

Предположим, вы разрабатываете сайт книжного магазина и у вас есть сервис, к которому обращается пользователь, например отправка рецензии на прочитанную книгу. При нажатии кнопки «Отправить» вызывается некоторый API, который, в свою очередь, может обратиться к другим API.

При синхронном взаимодействии все запросы в этой цепочке вызовов выполняются строго друг за другом, а при выполнении последнего запроса ответы последовательно передаются в обратном направлении. В итоге пользователь вынужден пару секунд ждать сообщения о публикации своего отзыва, хотя его не интересуют особенности серверной обработки и он вполне обоснованно хочет увидеть сообщение сразу после нажатия кнопки. Конечно, время ожидания будет во многом определяться мощностью оборудования, но при пиковых нагрузках оно может стать серьезной проблемой.

Еще один недостаток такой схемы — обработка сбоев. Если на одном из шагов возникнет исключение, оно каскадно возвратится назад, и пользователь получит уведомление об ошибке с просьбой повторно отправить рецензию. Вряд ли кого-то обрадует получение подобного сообщения после длительного ожидания.  

Синхронное взаимодействие на основе REST API  

![Синхронное взаимодействие на основе REST API](https://mcs.mail.ru/wp-content/uploads/2021/02/1-4.png)

Описанную схему можно изменить, добавив асинхронные вызовы. Достаточно вызвать в асинхронном режиме первый REST API и параллельно вернуть пользователю сообщение о том, что его рецензия принята и будет размещена, например, в течение суток. В итоге сайт не блокируется, а вызовы всех последующих API происходят независимо от пользователя.

Но у такой схемы также есть существенный недостаток: в случае сбоя в одном из API информация, введенная пользователем, будет потеряна. Если в первом примере в случае ошибок достаточно повторно отправить рецензию, то здесь ее необходимо заполнить заново.

Вариант асинхронного взаимодействия на основе REST API

![Вариант асинхронного взаимодействия на основе REST API](https://mcs.mail.ru/wp-content/uploads/2021/02/2-2.png)

Для устранения недостатков обеих схем как раз и предназначены очереди сообщений.

**Принципы работы очередей сообщений**

Очереди предоставляют буфер для временного хранения сообщений и конечные точки, которые позволяют подключаться к очереди для отправки и получения сообщений в асинхронном режиме.

В сообщениях могут содержаться запросы, ответы, ошибки и иные данные, передаваемые между программными компонентами. Компонент, называемый производителем (Producer), добавляет сообщение в очередь, где оно будет храниться, пока другой компонент, называемый потребителем (Consumer), не извлечет сообщение и не выполнит с ним необходимую операцию.

Очередь сообщений

![Очередь сообщений](https://mcs.mail.ru/wp-content/uploads/2021/02/3-2.png)

Очереди поддерживают получение сообщений как методом Push, так и методом Pull:  
* метод Pull подразумевает периодический опрос очереди получателем по поводу наличия новых сообщений;
* метод Push — отправку уведомления получателю в момент прихода сообщения. Второй метод реализует модель «Издатель/Подписчик» (Publisher/Subscriber).
Так как очереди могут использоваться несколькими производителями и потребителями одновременно, обычно их реализуют с помощью дополнительной системы, называемой брокером. Брокер сообщений (Message Broker) занимается сбором и маршрутизацией сообщений на основе предопределенной логики. Сообщения могут передаваться с некоторым ключом — по этому ключу брокер понимает, в какую из очередей (одну или несколько) должно попасть сообщение.

Вернемся к примеру с отправкой рецензии. Пусть та часть сервиса, к которому обращается пользователь, выступит в качестве производителя и будет направлять запросы на создание рецензий в очередь. Сразу после добавления сообщения в очередь пользователю можно направлять уведомление об успехе операции. Вся последующая логика обработки будет выполняться независимо от него на стороне потребителя, подписанного на очередь.

Завершив обработку, потребитель отправит подтверждение в очередь, после чего исходное сообщение будет удалено. Но если во время обработки произойдет сбой и подтверждение не будет получено вовремя, сообщение может быть повторно извлечено потребителем из очереди.

Вариант асинхронного взаимодействия на основе очереди сообщений

![Вариант асинхронного взаимодействия на основе очереди сообщений](https://i2.wp.com/mcsjournal.ru/wp-content/uploads/2021/02/4-3.png?resize=1024%2C112&ssl=1)

Таким образом, использование очередей сообщений решает сразу две задачи: сокращает время ожидания пользователя за счет асинхронной обработки и предотвращает потерю информации при сбоях. Но не следует рассматривать очереди как универсальное средство для любого вида приложений: как и у любого инструмента, у них есть свои преимущества и недостатки, о которых мы поговорим ниже.

**Польза и преимущества очередей сообщений в микросервисной архитектуре**

Используя очереди сообщений в качестве основного средства взаимодействия микросервисов (Microservices Communication), можно добиться следующих преимуществ:

1. Отделение логически независимых компонентов друг от друга (Decoupling)  
Отличительная черта микросервисов — их автономность. И очереди во многом помогают уменьшить зависимости между ними. Каждое сообщение, передаваемое в очереди, — это всего лишь массив байтов с некоторыми метаданными. Метаданные нужны для направления в конкретную очередь, а информация, содержащаяся в основной части (теле) сообщения, может быть практически любой. Брокер не анализирует данные, он выступает лишь в качестве маршрутизатора. Это позволяет настроить взаимодействие между компонентами, работающими даже на разных языках и платформах.

2. Улучшение масштабируемости  
Очереди сообщений упрощают независимое масштабирование микросервисов. Наблюдая за состоянием очередей, можно масштабировать те сервисы, на которые приходится большая часть нагрузки. Кроме этого, очереди легко позволяют не только увеличивать число экземпляров существующих сервисов, но и добавлять новые с минимальным временем простоя. Все, что для этого требуется, — добавить нового потребителя, прослушивающего события в очереди.

Однако сами очереди также необходимо масштабировать, и это может создать дополнительные сложности.

3. Балансировка нагрузки  
Если один из сервисов не справляется с нагрузкой, требуется возможность запускать больше его экземпляров быстро и без дополнительных настроек. Обычно для этих целей используют балансировщик нагрузки, интегрированный с сервером обнаружения служб и предназначенный для распределения трафика. При использовании очередей сообщений сам брокер по умолчанию является балансировщиком нагрузки. Если несколько потребителей слушают очередь одновременно, сообщения будут распределяться между ними в соответствии с настроенной стратегией.

4. Повышение надежности  
Выход из строя одного из компонентов не сказывается на работе всей системы: при восстановлении он обработает сообщение, находящееся в очереди. Ваш веб-сайт по-прежнему может работать, даже если задерживается часть обработки заказа, например, из-за проблем с сервером БД или системой электронной почты.

Правда, при этом очередь сама приобретает статус SPoF (Single Point Of Failure), поэтому необходимо заранее предусмотреть действия на случай ее аварийного отключения.

5. Безопасность
Большинство брокеров выполняют аутентификацию приложений, которые пытаются получить доступ к очереди, и позволяют использовать шифрование сообщений как при их передаче по сети, так и при хранении в самой очереди. Таким образом, очередь снимает с ваших сервисов бремя организации авторизации запросов.

**Варианты использования очередей сообщений**  

Очереди сообщений полезны в тех случаях, где возможна асинхронная обработка. Рассмотрим наиболее частые сценарии использования очередей сообщений (Message Queue use Cases):

1. Фоновая обработка долгосрочных задач на веб-сайтах
Сюда можно отнести задачи, которые не связаны напрямую с основным действием пользователя сайта и могут быть выполнены в фоновом режиме без необходимости ожидания с его стороны. Это обработка изображений, преобразование видео в различные форматы, создание отзывов, индексирование в поисковых системах после изменения данных, отправка электронной почты, формирование файлов и так далее.

2. Буферизация при пакетной обработке данных
Очереди можно использовать в качестве буфера для некоторой массовой обработки, например пакетной вставки данных в БД или HDFS. Очевидно, что гораздо эффективнее добавлять сто записей за раз, чем по одной сто раз, так как сокращаются накладные расходы на инициализацию и завершение каждой операции. Но для стандартной архитектуры может стать проблемой генерация данных клиентской службой быстрее, чем их может обработать получатель. Очередь же предоставляет временное хранилище для пакетов с данными, где они будут храниться до завершения обработки принимающей стороной.

3. Отложенные задачи
Многие системы очередей позволяют производителю указать, что доставка сообщений должна быть отложена. Это может быть полезно при реализации льготных периодов. Например, вы разрешаете покупателю отказаться от размещения заказа в течение определенного времени и ставите отложенное задание в очередь. Если покупатель отменит операцию в указанный срок, сообщение можно удалить из очереди.

4. Сглаживание пиковых нагрузок
Помещая данные в очередь, вы можете быть уверены, что данные будут сохранены и в конечном итоге обработаны, даже если это займет немного больше времени, чем обычно, из-за большого скачка трафика. Увеличить скорость обработки в таких случаях также возможно — за счет масштабирования нужных обработчиков.

5. Гарантированная доставка при нестабильной инфраструктуре
Нестабильная сеть в сочетании с очередью сообщений создает надежный системный ландшафт: каждое сообщение будет отправлено, как только это будет технически возможно.

6. Упорядочение транзакций
Многие брокеры поддерживают очереди FIFO, полезные в системах, где важно сохранить порядок транзакций. Если 1000 человек размещают заказ на вашем веб-сайте одновременно, это может создать некоторые проблемы с параллелизмом и не будет гарантировать, что первый заказ будет выполнен первым. С помощью очереди можно определить порядок их обработки.

7. Сбор аналитической информации
Очереди часто применяют для сбора некоторой статистики, например использования определенной системы и ее функций. Как правило, моментальная обработка такой информации не требуется. Когда сообщения поступают в веб-службу, они помещаются в очередь, а затем при помощи дополнительных серверов приложений обрабатываются и отправляются в базу данных.

8. Разбиение трудоемких задач на множество маленьких частей
Если у вас есть некоторая задача для группы серверов, то вам необходимо выполнить ее на каждом сервере. Например, при редактировании шаблона мониторинга потребуется обновить мониторы на каждом сервере, использующем этот шаблон. Вы можете поставить сообщение в очередь для каждого сервера и выполнять их одновременно в виде небольших операций.

9. Прочие сценарии, требующие гарантированной доставки информации и высокого уровня отказоустойчивости
Это обработка финансовых транзакций, бронирование авиабилетов, обновление записей о пациентах в сфере здравоохранения и так далее.

**Сложности использования и недостатки очередей сообщений: как с ними справляться**

Несмотря на многочисленные преимущества очередей сообщений, самостоятельное их внедрение может оказаться довольно сложной задачей по нескольким причинам:

* По сути, это еще одна система, которую необходимо купить/установить, правильно сконфигурировать и поддерживать. Также потребуются дополнительные мощности.
* Если брокер когда-либо выйдет из строя, это может остановить работу многих систем, взаимодействующих с ним. Как минимум необходимо позаботиться о резервном копировании данных.
* С ростом числа очередей усложняется и отладка. При синхронной обработке сразу очевидно, какой запрос вызвал сбой, например, благодаря иерархии вызовов в IDE. В очередях потребуется позаботиться о системе трассировки, чтобы быстро связать несколько этапов обработки одного запроса для обнаружения причины ошибки.
* При использовании очередей вы неизбежно столкнетесь с выбором стратегии доставки сообщений. В идеале сообщения должны обрабатываться каждым потребителем однократно. Но на практике это сложно реализовать из-за несовершенства сетей и прочей инфраструктуры. Большинство брокеров поддерживают две стратегии: доставка хотя бы раз (At-least-once) или максимум раз (At-most-once). Первая может привести к дубликатам, вторая — к потере сообщений. Обе требуют тщательного мониторинга. Некоторые брокеры также гарантируют строго однократную доставку (Exactly-once) с использованием порядковых номеров пакетов данных, но даже в этом случае требуется дополнительная проверка на стороне получателя.

**В каких случаях очереди неэффективны**  

Конечно, очереди не являются универсальным средством для любых приложений. Рассмотрим варианты, когда очереди не будут самым эффективным решением:

* У вашего приложения простая архитектура и функции, и вы не ожидаете его роста. Важно понимать, что очереди сообщений — это дополнительная сложность. Эту систему также необходимо настраивать, поддерживать, осуществлять мониторинг ее работы и так далее. Да, можно использовать Managed-решение, но вряд ли это будет оправдано для небольших приложений. Добавление очередей должно упрощать архитектуру, а не усложнять ее.
* Вы используете монолитное программное обеспечение, в котором развязка (Decoupling) невозможна или не приоритетна. Если вы не планируете разбивать монолит на микросервисы, но вам требуется асинхронность — для ее реализации обычно достаточно стандартной многопоточной модели. Очереди могут оказаться избыточным решением до тех пор, пока не возникнет явная необходимость в разделении приложения на автономные компоненты, способные независимо выполнять задачи.

## Что происходит в тот момент, когда вы вводите в адресной строке браузера URL сайта и нажимаете ввод?
<a id="www"></a>

# Big Data
<a id="Big-Data"></a>

* [Что такое DWH](#dwh)  
* [Data Lake](#data-lake)
* [Витрины данных](#data-marts)
* [ETL и ETL-запросы](#ETL)
* [Что такое Hadoop?](#hadoop)
* [Распределённая файловая система HDFS](#distributed-file-system-HDFS)

([наверх](#sections))

## Что такое DWH
<a id="dwh"></a>

DWH — Data warehouse — Корпоративное хранилище данных (КХД) — склад всех нужных и важных для принятия решений данных компании.  

Потребность в КХД сформировалась примерно в 90-х годах прошлого века, когда в секторе enterprise стали активно использоваться разные информационные системы для учета множества бизнес-показателей. Каждое такое приложение успешно решало задачу автоматизации локального производственного процесса, например, выполнение бухгалтерских расчетов, проведение транзакций, HR-аналитика и т.д.  

При этом схемы представления (модели) справочных и транзакционных данных в одной системе могут кардинально отличаться от другой, что влечет расхождение информации. Кроме того, большое разнообразие моделей данных затрудняет получение консолидированной отчетности, когда нужна целостная картина из всех прикладных систем. Поэтому возникли корпоративные хранилища данных (Data Warehouse, DWH) – предметно-ориентированные базы данных для консолидированной подготовки отчётов, интегрированного бизнес-анализа и оптимального принятия управленческих решений на основе полной информационной картины.

__Архитектура КХД__

Вышеприведенное определение DWH показывает, что это средство хранения данных является реляционным. Однако, не стоит считать КХД просто большой базой данных с множеством взаимосвязанных таблиц. В отличие от традиционной SQL-СУБД, Data Warehouse имеет сложную многоуровневую (слоеную) архитектуру, которая называется LSA – Layered Scalable Architecture. По сути, LSA реализует логическое деление структур с данными на несколько функциональных уровней. Данные копируются с уровня на уровень и трансформируются при этом, чтобы в итоге предстать в виде согласованной информации, пригодной для анализа.

Классически LSA реализуется в виде следующих уровней:

1. Операционный слой первичных данных(Primary Data Layer или стейджинг)  
Здесь выполняется загрузка информации из систем-источников в исходном качестве и сохранением полной истории изменений. Здесь происходит абстрагирование следующих слоев хранилища от физического устройства источников данных, способов их сбора и методов выделения изменений.
2. Ядро хранилища (Core Data Layer)  
Центральный компонент, который выполняет консолидацию данныхиз разных источников, приводя их к единым структурам и ключам. Именно здесь происходит основная работа с качеством данных и общие трансформации, чтобы абстрагировать потребителей от особенностей логического устройства источников данных и необходимости их взаимного сопоставления. Так решается задача обеспечения целостности и качества данных.
3. Аналитические витрины (Data Mart Layer)  
Тут данные преобразуются к структурам, удобным для анализа и использования в BI-дэшбордах или других системах-потребителях. Когда витрины берут данные из ядра, они называются регулярными. Если же для быстрого решения локальных задач не нужна консолидация данных, витрина может брать первичные данные из операционного слоя и называется соответственно операционной. Также бывают вторичные витрины, которые используются для представления результатов сложных расчетов и нетипичных трансформаций. Таким образом, витрины обеспечивают разные представления единых данных под конкретную бизнес-специфику.
4. Сервисный слой (Service Layer)  
Обеспечивает управление всеми вышеописанными уровнями. Он не содержит бизнес-данных, но оперирует метаданными и другими структурами для работы с качеством данных, позволяя выполнять сквозной аудит данных (data lineage), использовать общие подходы к выделению дельты изменений и управления загрузкой. Также здесь доступны средства мониторинга и диагностики ошибок, что ускоряет решение проблем.


__LSA – слоеная архитектура DWH: как устроено хранилище данных__  
![LSA – слоеная архитектура DWH: как устроено хранилище данных](https://www.bigdataschool.ru/wp-content/uploads/2020/04/%D0%B4%D0%B2%D1%85_1.png)

Все слои, кроме сервисного, состоят из области постоянного хранения данных и модуля загрузки и трансформации. Области хранения содержат технические (буферные) таблицы для трансформации данных и целевые таблицы, к которым обращается потребитель. Для обеспечения процессов загрузки и аудита ETL-процессов данные в целевых таблицах стейджинга, ядра и витринах маркируются техническими полями (мета-атрибутами). Еще выделяют слой виртуальных провайдеров данных и пользовательских отчетов для виртуального объединения (без хранения) данных из различных объектов. Каждый уровень может быть реализован с помощью разных технологий хранения и преобразования данных или универсальных продуктов, например, SAP NetWeaver Business Warehouse (SAP BW).

__В чём разница между обычной базой данных и DWH__

1. Типы хранимых данных.   
Обычные СУБД хранят данные строго для определенных подсистем. База данных склада хранит складские запасы и ничего более. База данных кадровиков хранит данные по персоналу, но не товары или сделки. DWH, как правило, хранит информацию разных подразделений — там найдутся данные и по товарам, и по персоналу, и по сделкам.
2. Объемы данных.  
Обычная БД, которая ведется в рамках стандартной деятельности компании, содержит только актуальную информацию, нужную в данный момент для функционирования определенной системы. В DWH пишутся не столько копии актуальных состояний, сколько исторические данные и агрегированные значения. Например, состояние запасов разных категорий товаров на конец смены за последние пять лет. Иногда в DWH пишутся и более крупные пачки данных, если они имеют критическое значение для бизнеса — допустим, полные данные по продажам и сделкам. То есть, по сути, это копия СУБД отдела продаж.
3. Место в рабочих процессах.  
Информация обычно сразу попадает в рабочие базы данных, а уже оттуда некоторые записи переползают в DWH. Склад данных, по сути, отражает состояние других БД и процессов в компании уже после того, как вносятся изменения в рабочих базах.

DWH — это система данных, отдельная от оперативной системы обработки данных. В корпоративных хранилищах в удобном для анализа виде хранятся архивные данные из разных, иногда очень разнородных источников. Эти данные предварительно обрабатываются и загружаются в хранилище в ходе процессов извлечения, преобразования и загрузки, называемых ETL. Решения ETL и DWH — это (упрощенно) одна система для работы с корпоративной информацией и ее хранения.

__Что дают DWH-решения для BI и принятия решений в компании__

Понятное дело, что просто так тратить деньги и время на консервирование кучи разных записей, которые и так можно накопать в других базах данных, никто не станет. Ответ заключается в том, что DWH необходима для того, чтобы делать BI — business intelligence.  

Что такое BI с DWH? Бизнес-аналитика (BI) — это процесс анализа данных и получения информации, помогающей компаниям принимать решения.  

Допустим, у вас в онлайн-магазине упала выручка. Менеджеры зовут на помощь бизнес-аналитика и просят его разобраться. Тот идет в DWH, вынимает оттуда данные по продажам, выручке, количеству пользователей, расходам — и собирает отчет, который в подробностях и с цифрами говорит о причинах падения финансовых показателей. Менеджеры внимательно смотрят на эту информацию и принимают решения по реорганизации ассортимента товаров и маркетинговых политик.
Если бы такого аналитического отчета не было — управленцам пришлось бы искать проблему наугад.

Логичный вопрос: казалось бы, зачем держать для этого всего DWH? Аналитики вполне могут ходить в базы данных разных систем и просто выдергивать оттуда то, что им надо.

Ответ: так, конечно, тоже можно делать. Но — не нужно. И вот почему:

1. Доступ к нужным данным.   
Если компания большая, на получение данных из разных источников нужно собирать разрешения и доступы. У каждого подразделения в такой ситуации, как правило, свои базы данных со своими паролями, которые надо будет запрашивать отдельно. В DWH все нужное уже будет под рукой в готовом виде. Можно просто пойти и дернуть там необходимую статистику.
2. Сохранность нужных данных.   
Данные в DWH не теряются и хранятся в виде, удобном для принятия решений: есть исторические записи, есть агрегированные значения. В операционной базе данных такой информации может и не быть. Например, админы уж точно не будут хранить на складском сервере архив запасов за 10 лет — БД склада в таком случае была бы слишком тяжелой. А вот хранить агрегированные запасы со склада в DWH — это нормально.
3. Устойчивость работы бизнес-систем.   
DWH оптимизируется для работы аналитиков, а эти ребята могут запрашивать очень большие объемы информации. Если они будут делать это с помощью DWH — ничего страшного, даже если их запрос будет обрабатываться очень долго. А если запросить слишком много записей с боевой базы данных сервера — он может уйти в отказ до конца выполнения запроса от аналитики и создать проблемы для других систем. DWH исключает риск того, что аналитики что-то повесят или сломают.   

__Почему бизнес-аналитика невозможна без DWH__

DWH и бизнес-аналитики переводят управление компаниями из искусства в науку. Имея под рукой результаты измерений по сотням показателей, можно выдвигать гипотезы и ставить эксперименты. Правильные решения легко подтверждаются объективными цифрами, которые достают аналитики из DWH.

Оптимальные управленческие решения — это не всегда максимизация прибыли. Это еще и выращивание новых производственных мощностей, минимизация негативного влияния на экологию, достойное качество жизни сотрудников, лояльность клиентов и стабильность бизнеса в долгосрочной перспективе. Все эти, казалось бы, сложные и эфемерные показатели можно анализировать с помощью BI и данных из DWH.

Без DWH и аналитиков управление бизнесом превращается в слепую езду по льду — возможно, при определенной сноровке вы попадете куда надо, но шансов улететь в сугроб или в столб все же куда больше.  

## Data Lake
<a id="data-lake"></a>
([наверх](#sections))

В 2010-х годах, с наступлением эпохи Big Data, фокус внимания от традиционных DWH сместился озерам данных (Data Lake). Однако, считать озеро данных новым поколением КХД не совсем корректно по следующим причинам:

1. Разное целевое назначение  
DWH используется менеджерами, аналитиками и другими конечными бизнес-пользователями, тогда как озеро данных – в основном Data Scientist’ами. Напомним, в Data Lake хранится неструктурированная, т.н. сырая информация: видеозаписи с беспилотников и камер наружного наблюдения, транспортная телеметрия, графические изображения, логи пользовательского поведения, метрики сайтов и информационных систем, а также прочие данные с разными форматами хранения (схемами представления). Они пока непригодны для ежедневной аналитики в BI-системах, но могут использоваться Data Scientist’ами для быстрой отработки новых бизнес-гипотез с помощью алгоритмов машинного обучения;
2. Разные подходы к проектированию   
Дизайн DWH основан на реляционной логике работы с данными – третья нормальная форма для нормализованных хранилищ, схемы звезды или снежинки для хранилищ с измерениями. При проектировании озера данных архитектор Big Data и Data Engineer большее внимание уделяют ETL-процессам с учетом многообразия источников и приемников разноформатной информации. А вопрос ее непосредственного хранения решается достаточно просто – требуется лишь масштабируемая, отказоустойчивая и относительно дешевая файловая система, например, HDFS или Amazon S3;
3. Цена  
обычно Data Lake строится на базе бюджетных серверов с Apache Hadoop, без дорогостоящих лицензий и мощного оборудования, в отличие от больших затрат на проектирование и покупку специализированных платформ класса Data Warehouse, таких как SAP, Oracle, Teradata и пр.

Таким образом, озеро данных существенно отличается от КХД. Тем не менее, архитектурный подход LSA может использоваться и при построении Data Lake. Например, именно такая слоенная структура была принята за основу озера данных в Тинькоф-банке:

* на уровне RAW хранятся сырые данные различных форматов (tsv, csv, xml, syslog, json и т.д.);
* на операционном уровне (ODD, Operational Data Definition) сырые данные преобразуются в приближенный к реляционному формат;
* на уровне детализации (DDS, Detail Data Store) собирается консолидированная модель детальных данных;
* уровень MART выполняет роль прикладных витрин данных для бизнес-пользователей и моделей машинного обучения.  

В данном примере для структурированных запросов к большим данным используется Apache Hive – популярное средство класса SQL-on-Hadoop. Само файловое хранилище организовано в кластере Hadoop на основе коммерческого дистрибутива от Cloudera (CDH). Традиционное DWH банка реализовано на массивно-параллельной СУБД Greenplum. От себя добавим, что альтернативой Apache Hive могла выступить Cloudera Impala, которая также, как Greenplum, Arenadata DB и Teradata, основана на массивно-параллельной архитектуре. Впрочем, выбор Hive обоснован, если требовалась высокая отказоустойчивость и большая пропускная способность. Подробнее о сходствах и различиях Apache Hive и Cloudera Impala мы рассказывали здесь. Возвращаясь к кейсу Тинькофф-банка, отметим, что BI-инструменты считывают данные из озера и классического DWH, обогащая типичные OLAP-отчеты информацией из хранилища Big Data. Это используется для анализа интересов, прогнозирования поведения, а также выявления текущих и будущих потребностей, которые возникают у посетителей сайта банка.

## Витрины данных
<a id="data-marts"></a>
([наверх](#sections))

## ETL и ETL-запросы
<a id="ETL"></a>
([наверх](#sections))

__ETL__

В переводе ETL (Extract, Transform, Load) — извлечение, преобразование и загрузка. То есть процесс, с помощью которого данные из нескольких систем объединяют в единое хранилище данных.

Представьте ритейлера с розничными и интернет-магазинами. Ему нужно анализировать тенденции продаж и онлайн, и офлайн. Но бэкэнд-системы для них, скорее всего, будут отдельными. Они могут иметь разные поля или форматы полей для сбора данных, использовать системы, которые не могут «общаться» друг с другом.

И вот тогда наступает момент для ETL.

ETL-система извлекает данные из обеих систем, преобразует их в соответствии с требованиями к формату хранилища данных, а затем загружает в это хранилище.

Схема всегда выглядит так: сначала извлечение данных из одного или нескольких источников, потом их подготовка к интеграции, после этого идет загрузка, и извлеченные данные попадают в общую базу.

__ETL на практике__  

Современные инструменты ETL собирают, преобразуют и хранят данные из миллионов транзакций в самых разных источниках данных и потоках. Эта возможность предоставляет множество новых возможностей: анализ исторических записей для оптимизации процесса продаж, корректировка цен и запасов в реальном времени, использование машинного обучения и искусственного интеллекта для создания прогнозных моделей, разработка новых потоков доходов, переход в облако и многое другое.

**Облачная миграция** Процесс переноса данных и приложений в облако называют облачной миграцией. Она помогает сэкономить деньги, сделать приложения более масштабируемыми и защитить данные. ETL в таком случае используют для перемещения данных в облако.

**Хранилище данных** Хранилище данных — база данных, куда передают данные из различных источников, чтобы их можно было совместно анализировать в коммерческих целях. Здесь ETL используют для перемещения данных в хранилище данных.

**Машинное обучение** Машинное обучение — метод анализа данных, который автоматизирует построение аналитических моделей. ETL может использоваться для перемещения данных в одно хранилище для машинного обучения.

**Интеграция маркетинговых данных** Маркетинговая интеграция включает в себя перемещение всех маркетинговых данных — о клиентах, продажах, из социальных сетей и веб-аналитики — в одно место, чтобы вы могли проанализировать их. ETL используют для объединения маркетинговых данных.

**Интеграция данных IoT** То есть данных, собранных различными датчиками, в том числе встроенными в оборудование. ETL помогает перенести данные от разных IoT в одно место, чтобы вы могли сделать их подробный анализ.

**Репликация базы данных** — данные из исходных баз данных копируют в облачное хранилище. Это может быть одноразовая операция или постоянный процесс, когда ваши данные обновляются в облаке сразу же после обновления в исходной базе. ETL можно использовать для осуществления процесса репликации данных.

**Бизнес-аналитика** Бизнес-аналитика — процесс анализа данных, позволяющий руководителям, менеджерам и другим заинтересованным сторонам принимать обоснованные бизнес-решения. ETL можно использовать для переноса нужных данных в одно место, чтобы их можно было использовать.

__Популярные ETL-системы__  

**Cloud Big Data** — PaaS-сервис для анализа больших данных (big data) на базе Apache Hadoop, Apache Spark, ClickHouse. Легко масштабируется, позволяет заменить дорогую и неэффективную локальную инфраструктуру обработки данных на мощную облачную инфраструктуру. Помогает обрабатывать структурированные и неструктурированные данные из разных источников, в том числе в режиме реального времени. Развернуть кластер интеграции и обработки данных в облаках можно за несколько минут, управление осуществляется через веб-интерфейс, командную строку или API.

**IBM InfoSphere** — инструмент ETL, часть пакета решений IBM Information Platforms и IBM InfoSphere. Доступен в различных версиях (Server Edition, Enterprise Edition и MVS Edition). Помогает в очистке, мониторинге, преобразовании и доставке данных, среди преимуществ: масштабируемость, возможность интеграции почти всех типов данных в режиме реального времени.

**PowerCenter** — набор продуктов ETL, включающий клиентские инструменты PowerCenter, сервер и репозиторий. Данные хранятся в хранилище, где к ним получают доступ клиентские инструменты и сервер. Инструмент обеспечивает поддержку всего жизненного цикла интеграции данных: от запуска первого проекта до успешного развертывания критически важных корпоративных приложений.

**iWay Software** предоставляет возможность интеграции приложений и данных для удобного использования в режиме реального времени. Клиенты используют их для управления структурированной и неструктурированной информацией. В комплект входят: iWay DataMigrator, iWay Service Manager и iWay Universal Adapter Framework.

**Microsoft SQL Server** — платформа управления реляционными базами данных и создания высокопроизводительных решений интеграции данных, включающая пакеты ETL для хранилищ данных.

**OpenText** — платформа интеграции, позволяющая извлекать, улучшать, преобразовывать, интегрировать и переносить данные и контент из одного или нескольких хранилищ в любое новое место назначения. Позволяет работать со структурированными и неструктурированными данными, локальными и облачными хранилищами.

**Oracle GoldenGate** — комплексный программный пакет для интеграции и репликации данных в режиме реального времени в разнородных IT-средах. Обладает упрощенной настройкой и управлением, поддерживает облачные среды.

**Pervasive Data Integrator** — программное решение для интеграции между корпоративными данными, сторонними приложениями и пользовательским программным обеспечением. Data Integrator поддерживает сценарии интеграции в реальном времени.

**Pitney Bowes** предлагает большой набор инструментов и решений, нацеленных на интеграцию данных. Например, Sagent Data Flow — гибкий механизм интеграции, который собирает данные из разнородных источников и предоставляет полный набор инструментов преобразования данных для повышения их коммерческой ценности.

**SAP Business Objects** — централизованная платформа для интеграции данных, качества данных, профилирования данных, обработки данных и отчетности. Предлагает бизнес-аналитику в реальном времени, приложения для визуализации и аналитики, интеграцию с офисными приложениями.

**Sybase** включает Sybase ETL Development и Sybase ETL Server. Sybase ETL Development — инструмент с графическим интерфейсом для создания и проектирования проектов и заданий по преобразованию данных. Sybase ETL Server — масштабируемый механизм, который подключается к источникам данных, извлекает и загружает данные в хранилища.

__Open source ETL-средства__

Большинство инструментов ETL с открытым исходным кодом помогают в управлении пакетной обработкой данных и автоматизации потоковой передачи информации из одной системы данных в другую. Эти рабочие процессы важны при создании хранилища данных для машинного обучения.  

Некоторые из бесплатных и открытых инструментов ETL принадлежат поставщикам, которые в итоге хотят продать корпоративный продукт, другие обслуживаются и управляются сообществом разработчиков, стремящихся демократизировать процесс.  

Open source ETL-инструменты интеграции данных:  

**Apache Airflow** — платформа с удобным веб-интерфейсом, где можно создавать, планировать и отслеживать рабочие процессы. Позволяет пользователям объединять задачи, которые нужно выполнить в строго определенной последовательности по заданному расписанию. Пользовательский интерфейс поддерживает визуализацию рабочих процессов, что помогает отслеживать прогресс и видеть возникающие проблемы.  

**Apache Kafka** — распределенная потоковая платформа, которая позволяет пользователям публиковать и подписываться на потоки записей, хранить потоки записей и обрабатывать их по мере появления. Kafka используют для создания конвейеров данных в реальном времени. Он работает как кластер на одном или нескольких серверах, отказоустойчив и масштабируем.  

**Apache NiFi** — распределенная система для быстрой параллельной загрузки и обработки данных с большим числом плагинов для источников и преобразований, широкими возможностями работы с данными. Пользовательский веб-интерфейс NiFi позволяет переключаться между дизайном, управлением, обратной связью и мониторингом.  

**CloverETL** (теперь CloverDX) был одним из первых инструментов ETL с открытым исходным кодом. Инфраструктура интеграции данных, основанная на Java, разработана для преобразования, отображения и манипулирования данными в различных форматах. CloverETL может использоваться автономно или встраиваться и подключаться к другим инструментам: RDBMS, JMS, SOAP, LDAP, S3, HTTP, FTP, ZIP и TAR. Хотя продукт больше не предлагается поставщиком, его можно безопасно загрузить с помощью SourceForge. CloverDX по-прежнему поддерживает CloverETL в соответствии со стандартным соглашением о поддержке.  

**Jaspersoft ETL** — один из продуктов с открытым исходным кодом TIBCO Community Edition, позволяет пользователям извлекать данные из различных источников, преобразовывать их на основе определенных бизнес-правил и загружать в централизованное хранилище данных для отчетности и аналитики. Механизм интеграции данных инструмента основан на Talend. Community Edition прост в развертывании, позволяет создавать витрины данных для отчетности и аналитики.  

**Apatar** — кроссплатформенный инструмент интеграции данных с открытым исходным кодом, который обеспечивает подключение к различным базам данных, приложениям, протоколам, файлам. Позволяет разработчикам, администраторам баз данных и бизнес-пользователям интегрировать информацию разного формата из различных источников данных. У инструмента интуитивно понятный пользовательский интерфейс, который не требует кодирования для настройки заданий интеграции данных. Инструмент поставляется с предварительно созданным набором инструментов интеграции и позволяет пользователям повторно использовать ранее созданные схемы сопоставления.

## Что такое Hadoop?
<a id="hadoop"></a>
([наверх](#sections))

Hadoop - инструмент для обработки Big Data. Hadoop - это проект Apache, является системой для распределённых вычислений. При этом эта система является масштабируемой и отказоустойчивой. 

__История Hadoop__  
Начинался как проект в Apache Nutch  
В 2004 году Google публикует статьи про GFS и MapReduce  
На основе этих статей формируется распределённая файловая система  

__Системные принципы Hadoop__  
* Горизонтальное (Scale-out) масштабирование вместо вертикального (Scale-Up)
* Отправление кода к данным
* Умение обрабатывать падения нод и отказы оборудования
* Инкапсуляция сложности работы распределённых и многопоточных приложений

__Масштабирование__  
* Вертикальное  
  - Добавить дополнительные ресурсы к существующему железу (CPU, RAM)  
  - Если нельзя улучшить железо, то надо покупать более мощное новое  
  - Закон Мура не успевает за ростом объёма данных  
* Горизонтальное 
  - Добавить больше машин к существующему кластеру
  - Приложение поддерживает добавлние/удаление серверов
  - Просто масштабировать "вниз"

## Распределённая файловая система HDFS
<a id="distributed-file-system-HDFS"></a>
* [Архитектура HDFS](#HDFS-architecture)  

([наверх](#sections))

### Архитектура HDFS
<a id="HDFS-architecture"></a>

HDFS (Hadoop Distributed File System) - это распределённая файловая система в hadoop. Как и любая другая файловая система она служит для хранения данных.

HDFS:
* Работает на кластере серверов
* Для пользователя как "Один большой диск"
* Работает поверх обычных файловых систем (ext3, ext4, XFS)  
* Не теряет данные если выходят из строя диски или сервера

HDFS подходит для:  
* Хранения больших данных
   - Терабайты, петабайты
   - Миллионы файлов
   - Файлы размером от 100 Мбэ
* Стриминга данных
   - Паттерн "write once / read many times"
   - Оптимизация под последовательное чтение

HDFS не подходит для:  
* Low-latency reads
   - Высокая пропускная способность вместо быстрого доступа к данным
   - HBase помогает решить эту задачу
* Большого количество небольших файлов
   - Лучше миллион больших файлов, чем миллиард маленьких
* Многопоточная запись
   - Один процесс записи на файл
   - данные дописываются в конец файла

__Демоны HDFS__  
![Демоны HDFS](https://russianblogs.com/images/753/dc2fb07713850c486dd1e421bc6843d9.png)

**Namenode**  
Отвечает за:
* Файловое пространство
* Мета-информацию
* Расположение блоков файлов  
Запускается на 1й выделенной машине

**Datanode**  
Отвечает за:
* Хранение и передачу блоков данных
* Отправку сообщений о состоянии на Namenode

Запускается на каждой машине кластера

# Бизнес
<a id="business"></a>
([наверх](#sections))

* [UML-диаграммы](#uml)  

## UML-диаграммы
<a id="uml"></a>

* [Диаграмма классов](#class-diagram)  
* [Диаграмма компонентов](#component-diagram)
* [Диаграмма развертывания](#deployment-diagram)
* [Диаграмма объектов](#object-diagram)
* [Диаграмма пакетов](#package-diagram)
* [Диаграмма составной структуры](#composite-structure-diagram)
* [Диаграмма профилей](#profile-diagram)
* [Диаграмма прецедентов](#use-case-diagram)
* [Диаграмма деятельности](#activity-diagram)
* [Диаграмма состояний](#state-diagram)
* [Диаграмма последовательности](#sequence-diagram)
* [Диаграмма Коммуникации](#communication-diagram)
* [Диаграмма обзора взаимодействия](#interaction-overview-chart)
* [Временная диаграмма](#timing-diagram)

Unified Modeling Language (UML) — унифицированный язык моделирования. Modeling подразумевает создание модели, описывающей объект. Unified (универсальный, единый) — подходит для широкого класса проектируемых программных систем, различных областей приложений, типов организаций, уровней компетентности, размеров проектов. UML описывает объект в едином заданном синтаксисе, поэтому где бы вы не нарисовали диаграмму, ее правила будут понятны для всех, кто знаком с этим графическим языком — даже в другой стране.

**Для чего используется UML?**

Одна из задач UML — служить средством коммуникации внутри команды и при общении с заказчиком. Рассмотрим возможные варианты использования диаграмм. 

* Проектирование. UML-диаграммы помогут при моделировании архитектуры больших проектов, в которой можно собрать как крупные, так и более мелкие детали и нарисовать каркас (схему) приложения. По нему впоследствии будет строиться код.  

* Реверс-инжиниринг — создание UML-модели из существующего кода приложения, обратное построение. Может применяться, например, на проектах поддержки, где есть написанный код, но документация неполная или отсутствует. 

* Из моделей можно извлекать текстовую информацию и генерировать относительно удобочитаемые тексты — документировать. Текст и графика будут дополнять друг друга.
  
![Типы UML диаграмм](https://habrastorage.org/webt/ry/i-/-p/ryi--p6wtfhvszjhcbhaogsdz8w.png)

### Диаграмма классов
<a id="class-diagram"></a>

Диаграмма классов — это центральная методика моделирования, которая используется практически во всех объектно-ориентированных методах. Эта диаграмма описывает типы объектов в системе и различные виды статических отношений, которые существуют между ними.

Три наиболее важных типа отношений в диаграммах классов (на самом деле их больше), это:

* Ассоциация, которая представляет отношения между экземплярами типов, к примеру, человек работает на компанию, у компании есть несколько офисов.

* Наследование, которое имеет непосредственное соответствие наследованию в Объектно-Ориентированном дизайне.

* Агрегация, которая представляет из себя форму композиции объектов в объектно-ориентированном дизайне.

![Диаграммка классов](https://habrastorage.org/webt/_f/xw/jo/_fxwjox5thnp7l9c5yayfy4pa4m.jpeg)

### Диаграмма компонентов
<a id="component-diagram"></a>

На языке унифицированного моделирования диаграмма компонентов показывает, как компоненты соединяются вместе для формирования более крупных компонентов или программных систем.

Она иллюстрирует архитектуры компонентов программного обеспечения и зависимости между ними.

Эти программные компоненты включают в себя компоненты времени выполнения, исполняемые компоненты, а также компоненты исходного кода.

![Диаграмма компонентов](https://habrastorage.org/webt/ff/dr/83/ffdr83yesqcv78hua6zxt45tbye.jpeg)

### Диаграмма развертывания
<a id="deployment-diagram"></a>

Диаграмма развертывания помогает моделировать физический аспект объектно-ориентированной программной системы. Это структурная схема, которая показывает архитектуру системы, как развертывание (дистрибуции) программных артефактов.

Артефакты представляют собой конкретные элементы в физическом мире, которые являются результатом процесса разработки.

Диаграмма моделирует конфигурацию времени выполнения в статическом представлении и визуализирует распределение артефактов в приложении.

В большинстве случаев это включает в себя моделирование конфигураций оборудования вместе с компонентами программного обеспечения, на которых они размещены.

![Диаграмма развертывания](https://habrastorage.org/webt/hu/eq/h9/hueqh9ow4b15ivon2h5jahaxyck.jpeg)

### Диаграмма объектов
<a id="object-diagram"></a>

Статическая диаграмма объектов является экземпляром диаграммы класса; она показывает снимок подробного состояния системы в определенный момент времени. Разница в том, что диаграмма классов представляет собой абстрактную модель, состоящую из классов и их отношений.

Тем не менее, диаграмма объекта представляет собой экземпляр в конкретный момент, который имеет конкретный характер.Использование диаграмм объектов довольно ограничено, а именно — чтобы показать примеры структуры данных.

![Диаграмма объектов](https://habrastorage.org/webt/4v/lq/wn/4vlqwntp_ip8_jyyqm3s2goxk9a.jpeg)

### Диаграмма пакетов
<a id="package-diagram"></a>

Диаграмма пакетов — это структурная схема UML, которая показывает пакеты и зависимости между ними.

Она позволяет отображать различные виды системы, например, легко смоделировать многоуровневое приложение.

![Диаграмма пакетов](https://habrastorage.org/webt/x2/sm/5t/x2sm5tb7tz6lgeg0opfnrqmxnm8.jpeg)

### Диаграмма составной структуры
<a id="composite-structure-diagram"></a>

Диаграмма составной структуры аналогична диаграмме классов и является своего рода диаграммой компонентов, используемой в основном при моделировании системы на микроуровне, но она изображает отдельные части вместо целых классов. Это тип статической структурной диаграммы, которая показывает внутреннюю структуру класса и взаимодействия, которые эта структура делает возможными.

Эта диаграмма может включать внутренние части, порты, через которые части взаимодействуют друг с другом или через которые экземпляры класса взаимодействуют с частями и с внешним миром, и соединители между частями или портами. Составная структура — это набор взаимосвязанных элементов, которые взаимодействуют во время выполнения для достижения какой-либо цели. Каждый элемент имеет определенную роль в сотрудничестве.

![Диаграмма составной структуры](https://habrastorage.org/webt/xe/_q/mb/xe_qmbmhorarotvrzrzj-owtrtq.jpeg)

### Диаграмма профилей
<a id="profile-diagram"></a>

Диаграмма профилей позволяет нам создавать специфичные для домена и платформы стереотипы и определять отношения между ними. Мы можем создавать стереотипы, рисуя формы стереотипов и связывая их с композицией или обобщением через интерфейс, ориентированный на ресурсы. Мы также можем определять и визуализировать значения стереотипов.

![Диаграмма профилей](https://habrastorage.org/webt/jn/c2/8v/jnc28vsuumwxobgsxmvvszusz1i.jpeg)

### Диаграмма прецедентов
<a id="use-case-diagram"></a>

Диаграмма прецедентов описывает функциональные требования системы с точки зрения прецедентов. По сути дела, это модель предполагаемой функциональности системы (прецедентов) и ее среды (актеров).

Прецеденты позволяют связать то, что нам нужно от системы с тем, как система удовлетворяет эти потребности.

![Диаграмма прецедентов](https://habrastorage.org/webt/q7/tm/yr/q7tmyr_d_aosxppt8i6rbk20ggq.jpeg)

### Диаграмма деятельности
<a id="activity-diagram"></a>

Диаграммы деятельности представляют собой графическое представление рабочих процессов поэтапных действий и действий с поддержкой выбора, итерации и параллелизма.
Они описывают поток управления целевой системой, такой как исследование сложных бизнес-правил и операций, а также описание прецедентов и бизнес-процессов.
В UML диаграммы деятельности предназначены для моделирования как вычислительных, так и организационных процессов.

![Диаграмма деятельности](https://habrastorage.org/webt/5h/dm/mh/5hdmmhiwtzdrswnnw6vgqy8ezzw.jpeg)

### Диаграмма состояний
<a id="state-diagram"></a>

Диаграмма состояний — это тип диаграммы, используемый в UML для описания поведения систем, который основан на концепции диаграмм состояний Дэвида Харела. Диаграммы состояний отображают разрешенные состояния и переходы, а также события, которые влияют на эти переходы. Она помогает визуализировать весь жизненный цикл объектов и, таким образом, помогает лучше понять системы, основанные на состоянии.

![Диаграмма состояний](https://habrastorage.org/webt/wf/67/mr/wf67mrwroyogobe5agpoaj2juy8.jpeg)

### Диаграмма последовательности
<a id="sequence-diagram"></a>

Диаграмма последовательности моделирует взаимодействие объектов на основе временной последовательности. Она показывает, как одни объекты взаимодействуют с другими в конкретном прецеденте.

![Диаграмма последовательности](https://habrastorage.org/webt/wr/6n/26/wr6n26qbnsdpvlknj151uwatzvw.jpeg)

### Диаграмма Коммуникации
<a id="communication-diagram"></a>

Как и диаграмма последовательности, диаграмма коммуникации также используется для моделирования динамического поведения прецедента. Если сравнивать с Диаграммой последовательности, Диаграмма коммуникации больше сфокусирована на показе взаимодействия объектов, а не временной последовательности. На самом деле, диаграмма коммуникации и диаграмма последовательности семантически эквивалентны и могут перетекать одна в другую.

![Диаграмма Коммуникации](https://habrastorage.org/webt/sj/6h/gz/sj6hgzpzw-zsymldpiizkaap2rg.jpeg)

### Диаграмма обзора взаимодействия
<a id="interaction-overview-chart"></a>

Диаграмма обзора взаимодействий фокусируется на обзоре потока управления взаимодействиями. Это вариант Диаграммы деятельности, где узлами являются взаимодействия или события взаимодействия. Диаграмма обзора взаимодействий описывает взаимодействия, в которых сообщения и линии жизни скрыты. Мы можем связать «реальные» диаграммы и добиться высокой степени навигации между диаграммами внутри диаграммы обзора взаимодействия.

![Диаграмма обзора взаимодействия](https://habrastorage.org/webt/rk/8i/9l/rk8i9lhvjrrvsu8cuthg50fdx0s.jpeg)

### Временная диаграмма
<a id="timing-diagram"></a>

Временная диаграмма показывает поведение объекта (ов) в данный период времени. По сути — это особая форма диаграммы последовательности и различия между ними состоят в том, что оси меняются местами так, что время увеличивается слева направо, а линии жизни отображаются в отдельных отсеках, расположенных вертикально.

![Временная диаграмма](https://habrastorage.org/webt/fy/ea/gv/fyeagvt6jnk57o6hdkegem61lyi.jpeg)

# Источники
<a id="sources"></a>
([наверх](#sections))

* [Документация python](https://docs.python.org/3/library/)
* ["Как устроен Python. Гид для разработчиков, программистов и интересующихся" Мэтт Харрисон](https://t.me/pythonbooks/389)  
* [Магические методы Rafe Kettler](https://rszalski.github.io/magicmethods/)  
* [Техническая документация по SQL Server](https://docs.microsoft.com/ru-ru/sql/sql-server/?view=sql-server-ver15)  
* [SQL и NoSQL: разбираемся в основных моделях баз данных](https://tproger.ru/translations/sql-nosql-database-models/)  
* [Основные команды SQL, которые должен знать каждый программист](https://tproger.ru/translations/sql-recap/)  
* [Профессиональный информационно-аналитический ресурс, посвященный машинному обучению, распознаванию образов и интеллектуальному анализу данных](https://www.machinelearning.ru/)
* [Inside the Python GIL](http://www.dabeaz.com/python/GIL.pdf)
* [Журнал Mail.ru Cloud Solutions об IT-бизнесе, технологиях и цифровой трансформации](https://mcs.mail.ru/blog/)
* [Школа больших данных](https://www.bigdataschool.ru/)
* [Блог компании Тинькофф](https://habr.com/ru/company/tinkoff/profile/)
