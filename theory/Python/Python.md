# Python

## Содержание:
<a id="sections"></a>

* [Разница 2 и 3 версии python](#Difference-2-and-3-python-version)  
* [ООП](#oop)  
  - [SOLID](#SOLID)  
  - [Что такое классы?](#classes)  
  - [Что такое магические методы?](#magic-methods)  
  - [Что такое миксин?](#mixin) 
* [Типы и структуры данных в python](#Types-and-data-structures-in-python)  
  - [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
  - [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
  - [Что может быть в качестве ключа словаря?](#dictionary-key)  
  - [Что такое хеш-функция?](#python-hash)  
  - [В чём особенность словаря в python?](#dictionary-in-python)  
  - [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets) 
* [GIL](#GIL) 
  - [Что такое GIL?](#what-is-GIL)  
  - [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
  - [Разница между потоками и процессами](#difference-between-threads-and-processes)  
  - [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
  - [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  
* [GC](#GC)  
  - [Как в питоне обстоят дела с памятью (управлением памятью)](#memory-management-in-python)  
  - [Сколько стоит проверка элемента в нотации?](#how-much-does-it-cost-to-validate-an-element-in-notation)  
  - [Если есть два объекта и они указывают друг на друга](#two-objects) 
* [Итераторы, декораторы и генераторы](#Iterators-decorators-and-generators)  
  - [Что такое итератор?](#what-is-iterator)  
  - [Что такое генератор?](#what-is-generator)
  - [Что такое декоратор?](#what-is-decorator)  
  - [Какие декораторы стандартной библиотеки вы знаете?](#standard-library-decorators) 
  - [Что такое list comprehension, какой синтаксис создания генераторов?](list-comprehension)
  - [Является ли range итератором?](is-range-an-iterator)
* [Алгоритмы](#Algorithms)  


<a id="Python"></a>


## Разница 2 и 3 версии python
<a id="Difference-2-and-3-python-version"></a>

В Python 2 print был оператором: ```print "Hello, world"```  
В Python 3 print - функция: ```print ("Hello, world")```

В Python 2 были две функции: range - возвращает список; xrange - возвращает итератор  
В Python 3 есть только функция range, и она возвращает итератор

В Python 2 при делении целых чисел возвращает целоче число  
В Python 3 при делении целых чисел возвращает вещественное число

**Магические методы**

* Так как в Питоне 3 различий между строкой и юникодом больше нет, ``` __unicode__```  исчез, а появился ``` __bytes__```  (который ведёт себя так же как ``` __str__```  и ``` __unicode__```  в 2.7) для новых встроенных функций построения байтовых массивов.  
* Так как деление в Питоне 3 теперь по-умолчанию «правильное деление», ``` __div__```  больше нет.  
* ``` __coerce__```  больше нет, из-за избыточности и странного поведения.  
* ``` __cmp__```  больше нет, из-за избыточности.  
* ``` __nonzero__```  было переименовано в ``` __bool__``` .  
* ``` next```  у итераторов был переименован в ``` __next__``` .

## ООП
<a id="oop"></a>
* [SOLID](#SOLID)  
* [Что такое классы?](#classes)  
* [Магические методы](#magic-methods)  
* [Что такое миксин?](#mixin)  

([наверх](#sections))

### SOLID
<a id="SOLID"></a>

S - Принцип единственной ответственности (single responsibility principle)
Для каждого класса должно быть определено единственное назначение. Не должно возникать God object, который занимается всем в программе. 

O - Принцип открытости/закрытости (open–closed principle)
«программные сущности … должны быть открыты для расширения, но закрыты для модификации». Мы должны иметь возможность добавлять функциональность. 

L - Принцип подстановки Барбары Лисков (Liskov substitution principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения 
правильности выполнения программы». У объекта есть тип, но сами классы выстраиваются в иерархию классов. Подтип типа всю старую функциональность должен выполнять. 

I - Принцип разделения интерфейса (interface segregation principle)
«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс 
общего назначения». Интерфейс - способ провзаимодействовать с какой-то программной действующей функцией. 

D - Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». 

### Что такое классы?
<a id="classes"></a>
([наверх](#sections))

Класс — тип, описывающий устройство объектов. Объект — это экземпляр класса.
```
class C: 
  pass
имя_объекта = имя_класса()
```
У класса может не быть тела. 

Простейший пример класса:
```
class Rectangle:
  default_color = "green" # статический атрибут
  def __init__(self, width, height): # конструктор класса
    self.width = width # динамический атрибут
    self.height = height # динамический атрибут
```
В python нет возможности сделать несколько конструкторов. 

### Магические методы
<a id="magic-methods"></a>
([наверх](#sections))

Если какой-то идентификатор начинается с двух подчёркиваний, дальше пишется что-либо, потом снова два подчёркивания, то это спец метод. 

**Какие магические методы и для чего используются?**
```
class FileObject:
  def __init__(self, filepath='~', filename='sample.txt'): # Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.
    self.file = open(join(filepath, filename), 'r+') # Открыть файл filename в filepath в режиме чтения и записи
  def __del__(self):
    self.file.close()
    del self.file
``` 
Метод, который будет вызван при инициализации объекта.  
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в ``` __init__``` . ``` __new__```  используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка.
``` 
__new__(cls, [...])
``` 
Инициализатор класса. Самый базовый магический метод, ``` __init__``` . С его помощью мы можем инициализировать объект.
``` 
__init__(self, [...]) 
``` 
Деструктор объекта
``` 
__del__
``` 

Самый базовый из методов сравнения ``` __cmp__(self, other)``` . Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). ``` __cmp__```  должен вернуть отрицательное число, если ``` self < other``` , ноль, если ``` self == other``` , и положительное число в случае ``` self > other``` . Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в ``` __cmp__``` . Но ``` __cmp__```  может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперируют одним критерием.

* ``` __eq__(self, other)``` 
Определяет поведение оператора равенства, ==.

* ``` __ne__(self, other)``` 
Определяет поведение оператора неравенства, !=.

* ``` __lt__(self, other)``` 
Определяет поведение оператора меньше, <.

* ``` __gt__(self, other)``` 
Определяет поведение оператора больше, >.

* ``` __le__(self, other)``` 
Определяет поведение оператора меньше или равно, <=.

* ``` __ge__(self, other)``` 
Определяет поведение оператора больше или равно, >=.

**Унарные операторы и функции**

Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.

* ``` __pos__(self)``` 
Определяет поведение для унарного плюса ```(+some_object)```

* ``` __neg__(self)``` 
Определяет поведение для отрицания```(-some_object)```

* ``` __abs__(self)``` 
Определяет поведение для встроенной функции ```abs()```.

* ``` __invert__(self)``` 
Определяет поведение для инвертирования оператором ~. Для объяснения что он делает смотри статью в Википедии о бинарных операторах.

* ``` __round__(self, n)``` 
Определяет поведение для встроенной функции ```round()```. n это число знаков после запятой, до которого округлить.

* ``` __floor__(self)``` 
Определяет поведение для ```math.floor()```, то есть, округления до ближайшего меньшего целого.

* ``` __ceil__(self)``` 
Определяет поведение для ```math.ceil()```, то есть, округления до ближайшего большего целого.

* ``` __trunc__(self)``` 
Определяет поведение для ```math.trunc()```, то есть, обрезания до целого.

**Обычные арифметические операторы**

* ```__add__(self, other)```
Сложение.

* ```__sub__(self, other)```
Вычитание.

* ```__mul__(self, other)```
Умножение.

* ```__floordiv__(self, other)```
Целочисленное деление, оператор //.

* ```__div__(self, other)```
Деление, оператор /.

* ```__truediv__(self, other)```
Правильное деление. Заметьте, что это работает только когда используется ```from __future__ import division```.

* ```__mod__(self, other)```
Остаток от деления, оператор %.

* ```__divmod__(self, other)```
Определяет поведение для встроенной функции divmod().

* ```__pow__```
Возведение в степень, оператор **.

* ```__lshift__(self, other)```
Двоичный сдвиг влево, оператор <<.

* ```__rshift__(self, other)```
Двоичный сдвиг вправо, оператор >>.

* ```__and__(self, other)```
Двоичное И, оператор &.

* ```__or__(self, other)```
Двоичное ИЛИ, оператор |.

* ```__xor__(self, other)```
Двоичный xor, оператор ^.

**Магические методы преобразования типов**

В Питоне множество магических методов, предназначенных для определения поведения для встроенных функций преобразования типов.

* ```__int__(self)```
Преобразование типа в int.

* ```__long__(self)```
Преобразование типа в long.

* ```__float__(self)```
Преобразование типа в float.

* ```__complex__(self)```
Преобразование типа в комплексное число.

* ```__oct__(self)```
Преобразование типа в восьмеричное число.

* ```__hex__(self)```
Преобразование типа в шестнадцатеричное число.

* ```__index__(self)```
Преобразование типа к int, когда объект используется в срезах (выражения вида ```[start:stop:step]```). Если вы определяете свой числовой тип, который может использоваться как индекс списка, вы должны определить ```__index__```.

* ```__trunc__(self)```
Вызывается при ```math.trunc(self)```. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

* ```__coerce__(self, other)```
Метод для реализации арифметики с операндами разных типов. ```__coerce__``` должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.

**Представление своих классов**

Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.

* ```__str__(self)```
Определяет поведение функции ```str()```, вызванной для экземпляра вашего класса.

* ```__repr__(self)```
Определяет поведение функции ```repr()```, вызванной для экземпляра вашего класса. Главное отличие от ```str()``` в целевой аудитории. ```repr()``` больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне), а ```str()``` предназначен для чтения людьми.

* ```__unicode__(self)```
Определяет поведение функции ```unicode()```, вызванной для экземпляра вашего класса. ```unicode()``` похож на ```str()```, но возвращает строку в юникоде. Если клиент вызывает ```str()``` на экземпляре вашего класса, а вы определили только ```__unicode__()```, то это не будет работать. Постарайтесь всегда определять ```__str__()``` для случая, когда кто-то не имеет такой роскоши как юникод.

* ```__format__(self, formatstr)```
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, ```"Hello, {0:abc}!".format(a)``` приведёт к вызову ``` a.__format__("abc")```. Это может быть полезно для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.

* ```__hash__(self)```
Определяет поведение функции ```hash()```, вызванной для экземпляра вашего класса. Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно нужно определять и ```__eq__``` тоже. Руководствуйтесь следующим правилом: ```a == b``` подразумевает ```hash(a) == hash(b)```.

* ```__nonzero__(self)```
Определяет поведение функции ```bool()```, вызванной для экземпляра вашего класса. Должна вернуть ```True``` или ```False```, в зависимости от того, когда вы считаете экземпляр соответствующим ```True``` или ```False```.

* ```__dir__(self)```
Определяет поведение функции ```dir()```, вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю список атрибутов. Обычно, определение ```__dir__``` не требуется, но может быть жизненно важно для интерактивного использования вашего класса, если вы переопределили ```__getattr__``` или ```__getattribute__```.

* ```__sizeof__(self)```
Определяет поведение функции``` sys.getsizeof()```, вызванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах.

**Магия контейнеров**

Магические методы, используемые контейнерами.

* ```__len__(self)```
Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.

* ```__getitem__(self, key)```
Определяет поведение при доступе к элементу, используя синтаксис ```self[key]```. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: TypeError если неправильный тип ключа и KeyError если ключу не соответствует никакого значения.

* ```__setitem__(self, key, value)```
Определяет поведение при присваивании значения элементу, используя синтаксис ```self[nkey] = value```. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать KeyError и TypeError в соответствующих случаях.

* ```__delitem__(self, key)```
Определяет поведение при удалении элемента (то есть ```del self[key]```). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.

* ```__iter__(self)```
Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции ```iter()``` и в случае перебора элементов контейнера выражением ```for x in container:```. Итераторы сами по себе объекты и они тоже должны определять метод ```__iter__```, который возвращает ```self```.

* ```__reversed__(self)```
Вызывается чтобы определить поведения для встроенной функции ```reversed()```. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.

* ```__contains__(self, item)```
```__contains__``` предназначен для проверки принадлежности элемента с помощью in и not in. Вы спросите, почему же это не часть протокола последовательности? Потому что когда ```__contains__``` не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает True если находит нужный.

* ```__missing__(self, key)```
```__missing__``` используется при наследовании от ```dict```. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь ```d``` и я пишу ```d["george"]``` когда "george" не является ключом в словаре, вызывается ```d.__missing__("george"))```.

**Построение дескрипторов**

Дескрипторы — это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).

Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из ```__get__```, ```__set__``` или ```__delete__```. 

* ```__get__(self, instance, instance_class)```
Определяет поведение при возвращении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. owner это тип (класс) объекта.

* ```__set__(self, instance, value)```
Определяет поведение при изменении значения из дескриптора. ```instance``` это объект, для чьего атрибута-дескриптора вызывается метод. value это значение для установки в дескриптор.

* ```__delete__(self, instance)```
Определяет поведение для удаления значения из дескриптора. ```instance``` это объект, владеющий дескриптором.

**Как вызывать магические методы** 

| **Магический метод**                  |	**Когда он вызывается (пример)**        |	**Объяснение**                                       |
|:--------------------------------------|:----------------------------------------|:-----------------------------------------------------| 
| ```__new__(cls [,...])```             |	```instance = MyClass(arg1, arg2)```    |	```__new__``` вызывается при создании экземпляра     |
| ```__init__(self [,...])```           |	```instance = MyClass(arg1, arg2)```    |	```__init__``` вызывается при создании экземпляра    |
| ```__cmp__(self, other)```            |	```self == other, self > other, etc.```	| Вызывается для любого сравнения                      |
| ```__pos__(self)```                   |	```+self```                            	| Унарный знак плюса                                   |
| ```__neg__(self)```                   |	```-self```	                            | Унарный знак минуса                                  |
| ```__invert__(self)```                |	```~self```	                            | Побитовая инверсия                                   |
| ```__index__(self)```                 |	```x[self]```	                          | Преобразование, когда объект используется как индекс |
| ```__nonzero__(self)```               |	```bool(self), if self:```             	| Булевое значение объекта                             |
| ```__getattr__(self, name)```         |	```self.name # name не определено```	  | Пытаются получить несуществующий атрибут             |
| ```__setattr__(self, name, val)```    |	```self.name = val```	                  | Присвоение любому атрибуту                           |
| ```__delattr__(self, name)```         |	```del self.name```	                    | Удаление атрибута                                    |
| ```__getattribute__(self, name)```    |	```self.name```	                        | Получить любой атрибут                               |
| ```__getitem__(self, key)```          |	```self[key]```	                        | Получение элемента через индекс                      |
| ```__setitem__(self, key, val)```     |	```self[key] = val```                  	| Присвоение элементу через индекс                     |
| ```__delitem__(self, key)```          |	```del self[key]```	                    | Удаление элемента через индекс                       |
| ```__iter__(self)```                  |	```for x in self```	                    | Итерация                                             |
| ```__contains__(self, value)```       |	```value in self, value not in self```	| Проверка принадлежности с помощью in                 |
| ```__call__(self [,...])```           |	```self(args)```	                      | «Вызов» экземпляра                                   |
| ```__enter__(self)```                 |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__exit__(self, exc, val, trace)``` |	```with self as x:```	                  | ```with``` оператор менеджеров контекста             |
| ```__getstate__(self)```              |	```pickle.dump(pkl_file, self)```	      | Сериализация                                         |
| ```__setstate__(self)```              |	```data = pickle.load(pkl_file)```	    | Сериализация                                         |

### Что такое миксин?
<a id="mixin"></a>
([наверх](#sections))

Это класс, который реализует несколько методов, которые ты добавляешь к разным классам для того, чтобы они унаследовали и тоже получили какие-то методы. 

## Типы и структуры данных в python
<a id="Types-and-data-structures-in-python"></a>

* [Какие типы и структуры данных бывают в python?](#Types-and-data-structures)  
* [Что такое мутабельные и иммутабельные типы данных?](#mutable-and-immutable-data-types)  
* [Что может быть в качестве ключа словаря?](#dictionary-key)  
* [Что такое хеш-функция?](#python-hash)  
* [В чём особенность словаря в python?](#dictionary-in-python)  
* [Списки, кортежи и множества в чём их отличие?](#lists-tuples-and-sets)  

([наверх](#sections))

### Какие типы и структуры данных бывают в python?
<a id="Types-and-data-structures"></a>

| *Объект*                          | *Тип*                      | 
|:---------------------------------:|:--------------------------:| 
| Строка                            | str                        |
| Целое число                       | int                        |
| Число с плавающей точкой          | float                      |
| Список                            | list                       |
| Кортеж                            | tuple                      |
| Словарь                           | dict                       |
| Множество                         | set                        |
| Логический                        | bool                       |
| Функция                           | function                   |
| Класс, определяемый пользователем | type                       |
| Экземпляр класса                  | class                      |
| Встроенная функция                | builtin_function_or_method |
| type                              | type                       |

### Что такое мутабельные и иммутабельные типы данных?
<a id="mutable-and-immutable-data-types"></a>
([наверх](#sections))

Объекты в питоне бывают двух значительно отличающихся сортов: изменяемые (mutable) и неизменяемые (immutable). Неизменяемыми являются целые и действительные числа (int, float), строки (str), последовательности байтов (бинарные данные, bytes), а также кортежи, все элементы которых неизменяемы (tuple). Напротив, списки (list), словари (dict) и множества (set) являются изменяемыми.

### Что может быть в качестве ключа словаря?
<a id="dictionary-key"></a>
([наверх](#sections))

Только неизменяемые типы данных. Ключами словаря могут являться только объекты, поддерживающие хеширование. Таким образом, использовать в качестве ключей списки, словари и другие изменяемые типы не получится. Если в словарь будут добавлены несколько значений с одним и тем же ключом, словарь сохранит последнее.

Не рекомендуется использоваться в качестве ключей числа с плавающей запятой, так как они хранятся в памяти в виде приближений.

### Что такое хеш-функция?
<a id="python-hash"></a>
([наверх](#sections))

Хэш-функция - это функция, которая принимает на вход какие-либо данные (например, строки) и возвращает число по некоторому заданному алгоритму.  
Назначением хэш-функций является возможность помещения некоторого элемента (например, строки) в хэш-таблицу, на основе которых реализованы, например, словари и множества в Python. 

Одинаковые данные будут иметь одинаковое хеш-значение.  
* Даже небольшое изменение исходных данных может привести к совершенно иному хеш-значению.  
* Хеш получается из хеш-функции, в обязанности которой входит преобразование данной информации в закодированный хеш.   
* Очевидно, что количество объектов может быть намного больше, чем количество хеш-значений, и поэтому два объекта могут хешировать одно и то же. Это называется конфликтом хэша. Это означает, что если два объекта имеют одинаковый хэш-код, они не обязательно имеют одно и то же значение.  

Cрок жизни хэша зависит только от области действия программы, и он может измениться, как только программа завершится.

### В чём особенность словаря в python?
<a id="dictionary-in-python"></a>
([наверх](#sections))

Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.  

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами:  

* Во-первых, с помощью литерала:

  ```python
  d = {}
  print(d)
  {}
  d = {'dict': 1, 'dictionary': 2}
  prtin(d)
  {'dict': 1, 'dictionary': 2}
  ```
  
* Во-вторых, с помощью функции dict:

```python
  d = dict(short='dict', long='dictionary')
  prtin(d)
  {'short': 'dict', 'long': 'dictionary'}
  d = dict([(1, 1), (2, 4)])
  prtin(d)
  {1: 1, 2: 4}
```

* В-третьих, с помощью метода fromkeys:

```python
  d = dict.fromkeys(['a', 'b'])
  prtin(d)
  {'a': None, 'b': None}
  d = dict.fromkeys(['a', 'b'], 100)
  prtin(d)
  {'a': 100, 'b': 100}
```

* В-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.

```python
  d = {a: a ** 2 for a in range(7)}
  prtin(d)
  {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

**Методы словарей**  

* ```dict.clear()``` - очищает словарь.
* ```dict.copy()``` - возвращает копию словаря.
* ```classmethod dict.fromkeys(seq[, value])``` - создает словарь с ключами из ```seq``` и значением ```value``` (по умолчанию ```None```).
* ```dict.get(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает ```default``` (по умолчанию ```None```).
* ```dict.items()``` - возвращает пары (ключ, значение).
* ```dict.keys()``` - возвращает ключи в словаре.
* ```dict.pop(key[, default])``` - удаляет ключ и возвращает значение. Если ключа нет, возвращает ```default``` (по умолчанию бросает исключение).
* ```dict.popitem()``` - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение ```KeyError```. Важно помнить, что словари неупорядочены.
* ```dict.setdefault(key[, default])``` - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением ```default``` (по умолчанию ```None```).
* ```dict.update([other])``` - обновляет словарь, добавляя пары (ключ, значение) из ```other```. Существующие ключи перезаписываются. Возвращает ```None``` (не новый словарь!).
* ```dict.values()``` - возвращает значения в словаре.

### Списки, кортежи и множества в чём их отличие?
<a id="lists-tuples-and-sets"></a>
([наверх](#sections))

_List (список)_
Базовая структура данных в python. Элементы в списке хранятся последовательно, каждому из них присвоены индексы, начиная с нуля. В отличие от массива, список может хранить объекты любого типа.

Создание списка

```python
my_list = [] # Создание пустого списка с помощью литерала списка
my_list = list() # Создание пустого списка с помощью встроенной функции

my_list = [1,2,['a','b'],4,5] # Инициализация списка

my_list = list('hello world') # Создание списка из итерируемого объекта
print(my_list)
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

my_list = [x for x in range(10)] # Генератор списков в действии
print(my_list)

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Доступные методы
* ```my_list.append(x)``` - добавляет x в конец списка
* ```my_list.clear()``` - очищает 
* ```my_list.copy()``` - возвращает копию списка ```my_list```
* ```my_list.count(x)``` - возвращает кол-во элементов со значением x
* ```my_list.extend(x)``` - добавляет элементы списка x к концу списка ```my_list```
* ```my_list.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)
* ```my_list.insert(index, x)``` - вставляет x на заданную позицию
* ```my_list.pop(index)``` - возвращает элемент с указанным индексом и удаляет его, если индекс не указан - возвращается и удаляется последний элемент
* ```my_list.remove(x)``` - удаляет первый элемент со значением x
* ```my_list.reverse()``` - инвертирует порядок элементов в списке
* ```my_list.sort(key=x)``` сортирует список на основе функции x  

В каких случаях использовать?
Для хранения элементов, объединенных каким либо признаком. В случае, если изменение элементов и/или расширение списка не предполагается, следует использовать неизменяемый аналог - кортеж.

_Tuple (кортёж)_
Кортеж - это неизменяемый и более быстрый аналог списка. Он защищает хранимые данные от непреднамеренных изменений и может использоваться в качестве ключа в словарях (словарь - ассоциативный массив в python).

Создание кортежа.

```python
my_tuple = () # Создание кортежа с помощью литерала
my_tuple = tuple() # Создание кортежа с помощью встроенной функции

my_tuple = (1,2,['a','b'],4,5) # Инициализация кортежа

my_tuple = tuple('hello world') # Создание кортежа из итерируемого объекта
print(my_tuple)
('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')

my_tuple = tuple(2**x for x in [0, 1, 2, 3]) # Генератор кортежей
print(my_tuple)
(1, 2, 4, 8)
```

Доступные методы

* ```my_tuple.count(x)``` - возвращает кол-во элементов со значением x
* ```my_tuple.index(x,start,end)``` - возвращает индекс первого найденного x, можно задать промежуток для поиска (опционально)  

В каких случаях использовать?
Для хранения данных вместо списка (если они не предполагают изменений).

_Set (множество)_
Множество - это набор уникальных элементов в случайном порядке (неупорядоченный список). Множества примечательны тем, что операция проверки "принадлежит ли объект множеству" происходит значительно быстрее аналогичных операций в других структурах данных.

Создание множества

```python
my_something = {} # !!! Попытка создать множество при помощи литерала даст нам словарь
type(my_something)
<class 'dict'> 

my_set = set() # Создание при помощи встроенной функции

my_set = {1,2,3,4,5} # Инициализация множества

my_set = set('hello world') # Создания множества из итерируемого объекта
print(my_set)
{'r', 'o', 'e', 'h', 'd', 'w', 'l', ' '}

my_set = {x for x in range(10)} # Генератор множеств
print(my_set)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```
Доступные методы
* ```my_set.add(x)``` - добавляет x во множество
* ```my_set.difference(x)``` - возвращает множество элементов ```my_set```, которые не входят во множество ```x```
* ```my_set.difference_update(x)``` - удаляет из множества my_set все элементы, которые входят во множество ```x```
* ```my_set.discard(x)``` - удаляет элемент ```x``` из ```my_set```
* ```my_set.intersection(x)``` - возвращает элементы общие для множеств ```my_set``` и ```x```
* ```my_set.intersection_update(x)``` - удаляет из множества ```my_set``` элементы, которых нет во множестве ```x```
* ```my_set.isdisjoint(x)``` - возвращает ```true``` если ```my_set``` и ```x``` не содержат одинаковых значений
* ```my_set.issubset(x)``` - возвращает true если все элементы ```my_set``` входят во множество ```x```
* ```my_set.issuperset(x)``` - возвращает ```true``` если все элементы x входят во множество ```my_set```
* ```my_set.pop()``` - возвращает и удаляет первый (на данный момент) элемент множества
* ```my_set.remove(x)``` - удаляет ```x``` из множества
* ```my_set.symmetric_difference(x)``` - возвращает все элементы из ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.symmetric_difference_update(x)``` - обновляет исходное множество таким образом, что оно будет состоять из всех элементов ```x``` и ```my_set```, которые встречаются только в одном из множеств
* ```my_set.union(x)``` - возвращает новое множество, состоящее из всех элементов ```x``` и ```my_set```
* ```my_set.update(x)``` - добавляет в ```my_set``` все элементы ```x``` 

В каких случаях использовать?
Когда необходимо проверять принадлежит ли значение набору уникальных элементов и отсутствует необходимость поддерживать порядок в данном наборе.

## GIL
<a id="GIL"></a>

* [Что такое GIL?](#what-is-GIL)  
* [Многопоточные и многопроцессорные программы в python](#multithreaded-and-multiprocessing-programs-in-python)  
* [Разница между потоками и процессами](#difference-between-threads-and-processes)  
* [Что такое условия гонки и потокобезопасность?](#what-are-race-conditions-and-thread-safety)  
* [Алгоритм планирования доступа потоков к общим данным](#algorithm-for-scheduling-access-of-streams-to-shared-data)  

([наверх](#sections))

### Что такое GIL?
<a id="what-is-GIL"></a>

В Python используется глобальная блокировка интерпретатора (Global Interpreter Lock — GIL), накладывающая некоторые ограничения на потоки. А именно, нельзя использовать несколько процессоров одновременно. Блокировка, позволяет только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток. Из этого следует, что с потоками невозможно использовать несколько ядер процессора.

GIL был введен в Python потому, что управление памятью CPython не является потокобезопасным. Имея такую блокировку Python может быть уверен, что никогда не будет условий гонки. (об условиях гонки в следующем разделе)

Во многопоточных программах отсутствие GIL может негативно сказываться на производительности процессоро-зависымых программ.

![image](https://user-images.githubusercontent.com/54559853/127723378-17c5daa9-46c0-4a24-b493-de66914bd3b1.png)  

Python подсчитывает количество ссылок для корректного управления памятью. Это означает, что созданные в Python объекты имеют переменную подсчёта ссылок, в которой хранится количество всех ссылок на этот объект. Как только эта переменная становится равной нулю, память, выделенная под этот объект, освобождается.

### Многопоточные и многопроцессорные программы в python
<a id="multithreaded-and-multiprocessing-programs-in-python"></a>
([наверх](#sections))

Параллелизм дает возможность работать над несколькими вычислениями одновременно в одной программе. Такого поведения в Python можно добиться несколькими способами:  
* Используя многопоточность ```threading```, позволяя нескольким потокам работать по очереди.  
* Используя несколько ядер процессора ```multiprocessing```. Делать сразу несколько вычислений, используя несколько ядер процессора. Это и называется параллелизмом.  
* Используя асинхронный ввод-вывод с модулем ```asyncio```. Запуская какую то задачу, продолжать делать другие вычисления, вместо ожидания ответа от сетевого подключения или от операций чтения/записи.  

### Разница между потоками и процессами
<a id="difference-between-threads-and-processes"></a>
([наверх](#sections))

Поток ```threading``` - это независимая последовательность выполнения каких то вычислений. Поток ```thread``` делит выделенную память ядру процессора, а так же его процессорное время со всеми другими потоками, которые создаются программой в рамках одного ядра процессора. Программы на языке Python имеют, по умолчанию, один основной поток. Можно создать их больше и позволить Python переключаться между ними. Это переключение происходит очень быстро и кажется, что они работают параллельно.

Понятие процесс в ```multiprocessing``` - представляет собой так же независимую последовательность выполнения вычислений. В отличие от потоков threading, процесс имеет собственное ядро и следовательно выделенную ему память, которое не используется совместно с другими процессами. Процесс может клонировать себя, создавая два или более экземпляра в одном ядре процессора.

Асинхронный ввод-вывод не является ни потоковым (```threading```), ни многопроцессорным (```multiprocessing```). По сути, это однопоточная, однопроцессная парадигма и не относится к параллельным вычислениям.

### Что такое условия гонки и потокобезопасность?
<a id="what-are-race-conditions-and-thread-safety"></a>
([наверх](#sections))

* Состояние гонки возникает, когда несколько потоков могут одновременно получать доступ к общей структуре данных или местоположению в памяти и изменять их, в следствии чего могут произойти непредсказуемые вещи.
  
  Если два пользователя одновременно редактируют один и тот же документ онлайн и второй пользователь сохранит данные в базу, то перезапишет работу первого пользователя. Чтобы избежать условий гонки, необходимо заставить второго пользователя ждать, пока первый закончит работу с документом и только после этого разрешить второму пользователю открыть и начать редактировать документ.

* Потокобезопасность работает путем создания копии локального хранилища в каждом потоке, чтобы данные не сталкивались с другим потоком.

### Алгоритм планирования доступа потоков к общим данным
<a id="algorithm-for-scheduling-access-of-streams-to-shared-data"></a>
([наверх](#sections))

Потоки используют одну и ту же выделенную память. Когда несколько потоков работают одновременно, то нельзя угадать порядок, в котором потоки будут обращаются к общим данным. Результат доступа к совместно используемым данным зависит от алгоритма планирования. который решает, какой поток и когда запускать. Если такого алгоритма нет, то конечные данные могут быть не такими как ожидаешь.

## GC
<a id="GC"></a>

* [Как в питоне обстоят дела с памятью (управлением памятью)](#memory-management-in-python)  
* [Сколько стоит проверка элемента в нотации?](#how-much-does-it-cost-to-validate-an-element-in-notation)  
* [Если есть два объекта и они указывают друг на друга](#two-objects)  

([наверх](#sections))

### Как в питоне обстоят дела с памятью (управлением памятью)
<a id="memory-management-in-python"></a>

### Сколько стоит проверка элемента в нотации?
<a id="how-much-does-it-cost-to-validate-an-element-in-notation"></a>
([наверх](#sections))

### Если есть два объекта и они указывают друг на друга
<a id="two-objects"></a>
([наверх](#sections))

## Итераторы, декораторы и генераторы
<a id="Iterators-decorators-and-generators"></a>
([наверх](#sections))

* [Что такое итератор?](#what-is-iterator)  
* [Что такое генератор?](what-is-generator)
* [СЧто такое декоратор?](#what-is-decorator)  
* [Какие декораторы стандартной библиотеки вы знаете?](#standard-library-decorators) 
* [Что такое list comprehension, какой синтаксис создания генераторов?](list-comprehension)
* [Является ли range итератором?](is-range-an-iterator)

([наверх](#sections))

### Что такое итератор?
<a id="what-is-iterator"></a>

Итераторы — объекты, которые позволяют обходить коллекции. Коллекции не должны обязательно существовать в памяти и быть конечными.

Итерируемый — объект, в котором есть метод ```__iter__```. В свою очередь, итератор — объект, в котором есть два метода: ```__iter__``` и ```__next__```. Почти всегда ```iterator``` возвращает себя из метода ```__iter__```, так как они выступают итераторами для самих себя, но есть исключения.

В целом стоит избегать прямого вызова ```__iter__``` и ```__next__```. При использовании ```for``` или генераторов списков Python вызывает эти методы сам. Если всё-таки необходимо вызвать методы напрямую, лучше использовать встроенные функции ```iter``` и ```next``` и в параметрах передаём итератор или контейнер. Например, если ```c``` — итерируемый, используем```iter(c)``` вместо ```c.__iter__()```. Если ```a``` — итератор, используем ```next(a)```, а не ```a.__next__()```. Это похоже на использование ```len```.

Раз уж речь зашла о ```len```, то стоит упомянуть, что итераторы не должны иметь и часто не имеют определённой длины. Поэтому в них часто нет имплементации ```__len__```. Чтобы подсчитать количество элементов в итераторе, приходится делать это вручную или использовать ```sum```. 

Некоторые итерируемые ```(iterable)``` не являются итераторами, но используют другие объекты как итераторы. Например, объект ```list``` относится к итерируемым, но не является итератором. В нём реализован метод ```__iter__```, но отсутствует метод ```__next__```. Итераторы объектов ```list``` относятся к типу ```listiterator```. У объектов ```list``` есть определённая длина, а у ```listiterator``` нет.

```python
>>> a = [1, 2]
>>> type(a)
<type 'list'>
>>> type(iter(a))
<type 'listiterator'>
>>> it = iter(a)
>>> next(it)
1
>>> next(it)
2
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> len(a)
2
>>> len(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object of type 'listiterator' has no len()
```

Когда итератор завершает работу, интерпретатор Python ожидает возбуждения исключения ```StopIteration```. Однако,  итераторы могут работать с бесконечными множествами. В таких случаях надо позаботиться о выходе из цикла.

Пример итератора - считает с нуля до бесконечности. Это упрощённая версия ```itertools.count```.

```python
class count_iterator:
    n = 0

    def __iter__(self):
        return self

    def __next__(self):
        y = self.n
        self.n += 1
        return y
```

Пример использования. В последней строке сделана попытка превратить итератор в список. Это приводит к бесконечному циклу.

```python
>>> counter = count_iterator()
>>> next(counter)
0
>>> next(counter)
1
>>> next(counter)
2
>>> next(counter)
3
>>> list(counter)  # Бесконечный цикл
```

Если у объекта нет метода ```__iter__```, его можно обойти, если определить метод ```__getitem__```. В этом случае встроенная функция iter возвращает итератор с типом ```iterator```, который использует ```__getitem__``` для обхода элементов списка. Этот метод возвращает ```StopIteration``` или ```IndexError```, когда обход завершается. Пример:

```python
class SimpleList(object):
    def __init__(self, *items):
        self.items = items

    def __getitem__(self, i):
        return self.items[i]
```

И пример использования:

```python
>>> a = SimpleList(1, 2, 3)
>>> it = iter(a)
>>> next(it)
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

Ещё один интересный пример: генерация [последовательности Хофштадтера](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%A5%D0%BE%D1%84%D1%88%D1%82%D0%B0%D0%B4%D1%82%D0%B5%D1%80%D0%B0). В приведённом ниже коде итератор используется для генерации последовательности с помощью вложенных повторений.

```
Q(n)=Q(n−Q(n−1))+Q(n−Q(n−2))
```

Например, ```qsequence([1, 1])``` генерирует точную последовательность Хофштадтера. Мы используем исключение ```StopIteration```, чтобы показать, что последовательность не может продолжаться, так как для генерации следующего элемента должен использоваться несуществующий индекс. Если в параметрах укзать значения [1, 2], последовательность немедленно заканчивается.

```python
class qsequence:
    def __init__(self, s):
        self.s = s[:]

    def __next__(self):
        try:
            q = self.s[-self.s[-1]] + self.s[-self.s[-2]]
            self.s.append(q)
            return q
        except IndexError:
            raise StopIteration()

    def __iter__(self):
        return self

    def current_state(self):
        return self.s
```

Пример использования:

```python
>>> Q = qsequence([1, 1])
>>> next(Q)
2
>>> next(Q)
3
>>> [next(Q) for __ in range(10)]
[3, 4, 5, 5, 6, 6, 6, 8, 8, 8]
```

### Что такое генератор?
<a id="what-is-generator"></a>
([наверх](#sections))

Генераторами называют итераторы, определение которых выглядит как определение функций.  
Ещё одно определение: генераторы — функции, которые внутри используют выражение ```yield```. Генераторы не могут возвращать значения, вместо этого выдают элементы по готовности. Python автоматизирует запоминание контекста генератора, то есть текущий поток управления, значение локальных переменных и так далее. Каждый вызов метода ```__next__``` у объекта генератора возвращает следующее значение. Метод ```__iter__``` также реализуется автоматически. То есть генераторы можно использовать везде, где требуются итераторы.

```python
def count_generator():
   n = 0
   while True:
     yield n
     n += 1
```

Как это применяется на практике.

```python
>>> counter = count_generator()
>>> counter
<generator object count_generator at 0x106bf1aa0>
>>> next(counter)
0
>>> next(counter)
1
>>> iter(counter)
<generator object count_generator at 0x106bf1aa0>
>>> iter(counter) is counter
True
>>> type(counter)
<type 'generator'>
```

Теперь посмотрим на реализацию последовательности Q Хофштадтера с помощью генератора. Заметьте, эта реализация значительно проще использованного выше подхода. Однако здесь уже невозможно использовать методы типа current_state. Извне невозможно получить доступ к переменным, которые хранятся в контексте генератора.

Существует словарь ```gi_frame.f_locals```, но он относится к CPython, но не входит в стандарт языка Python.

Одно из возможных решений — получение одновременно списка и результата.

```python
def hofstadter_generator(s):
    a = s[:]
    while True:
        try:
            q = a[-a[-1]] + a[-a[-2]]
            a.append(q)
            yield q
        except IndexError:
            Return
```

Итерация в данном примере завершается простым ```return``` без параметров. Внутри происходит возбуждение исключения ```StopIteration```. Следующий пример связан с [распределением Бернулли](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%91%D0%B5%D1%80%D0%BD%D1%83%D0%BB%D0%BB%D0%B8), которое реализуется с помощью двух генераторов. Речь идёт о бесконечной последовательности случайных булевых значений. При этом вероятность ```True``` равна ```p```, а вероятность ```False``` определяется формулой ```q=1-p```. Затем применяется экстрактор фон Неймана, который принимает процесс Бернулли с ```0 < p < 1``` как источник энтропии и возвращает чистый процесс Бернулли с ```p = 0.5```.

```python
import random

def bernoulli_process(p):
    if p > 1.0 or p < 0.0:
        raise ValueError("p should be between 0.0 and 1.0.")

    while True:
        yield random.random() < p

def von_neumann_extractor(process):
    while True:
        x, y = next(proccess), next(process)
        if x != y:
            yield x
```

C помощью генераторов удобно реализовывать дискретные динамические системы. Пример ниже показывает, как с помощью генераторов реализуется [отображение тент](https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D1%82%D0%B5%D0%BD%D1%82).

```python
>>> def tent_map(mu, x0):
...    x = x0
...    while True:
...        yield x
...        x = mu * min(x, 1.0 - x)
...
>>>
>>> t = tent_map(2.0, 0.1)
>>> for __ in range(30):
...    print(next(t))
...
0.1
0.2
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.8
0.4
0.799999999999
0.400000000001
0.800000000003
0.399999999994
0.799999999988
0.400000000023
0.800000000047
0.399999999907
0.799999999814
0.400000000373
0.800000000745
0.39999999851
0.79999999702
```
Ещё один пример касается [последовательности Коллатца](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%9A%D0%BE%D0%BB%D0%BB%D0%B0%D1%82%D1%86%D0%B0).

```python
def collatz(n):
   yield n
   while n != 1:
     n = n / 2 if n % 2 == 0 else 3 * n + 1
     yield n
```

В этом примере не нужно вручную использовать ```StopIteration```. Это исключение срабатывает автоматически, когда поток управления достигает конца функции.

Пример использования генератора:

```python
>>> # Если гипотеза Коллатца верна, list(collatz(n)) с любым n 
... # всегда завершается
>>> list(collatz(7))
[7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
>>> list(collatz(13))
[13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
>>> list(collatz(17))
[17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
>>> list(collatz(19))
[19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```

### Что такое декоратор?
<a id="what-is-decorator"></a>
([наверх](#sections))

### Какие декораторы стандартной библиотеки вы знаете?
<a id="standard-library-decorators"></a>
([наверх](#sections))

### Что такое list comprehension, какой синтаксис создания генераторов?
<a id="list-comprehension"></a>
([наверх](#sections))

### Является ли range итератором?
<a id="is-range-an-iterator"></a>
([наверх](#sections))

## Алгоритмы
<a id="Algorithms"></a>

<br/>
